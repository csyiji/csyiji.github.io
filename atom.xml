<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>戈吉</title>
  
  <subtitle>thinkings</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.godjiyi.cn/"/>
  <updated>2020-05-09T00:51:04.545Z</updated>
  <id>https://www.godjiyi.cn/</id>
  
  <author>
    <name>戈吉</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>国际标准化组织发展史</title>
    <link href="https://www.godjiyi.cn/2020/05/09/standards_organization/"/>
    <id>https://www.godjiyi.cn/2020/05/09/standards_organization/</id>
    <published>2020-05-09T00:07:25.000Z</published>
    <updated>2020-05-09T00:51:04.545Z</updated>
    
    <content type="html"><![CDATA[<p>最近在了解 HTTP 协议的时候知道了 <strong>IETF</strong> 标准化组织，而前端中的 <strong>W3C</strong>，以及 <strong>EMCA</strong> 这些组织也在网上经常看到，还有国际标准化组织 <strong>ISO</strong> 这些到底有什么关系呢？下面记录下自己的了解。</p><p>主要关键词: <strong>IEC、ISA、ISO、ITU、EMCA 、IETF、W3C</strong> 等说明;</p><ul><li>IEC: 国际电工委员会</li><li>ISA: 国家标准化协会的国际联盟</li><li>ISO: 国际标准化组织</li><li>ITU: 国际电信联盟</li><li>EMCA: 欧洲计算机制造商协会</li><li>IETF: 互联网工程任务组</li><li>W3C: 万维网联盟</li></ul><p>时间线图示:</p><p><img src="http://img.godjiyi.cn/jy_20200509001118.png" alt></p><p>下面会分别对各个组织进行详细介绍。</p><a id="more"></a><h2 id="国际电工委员会-IEC"><a href="#国际电工委员会-IEC" class="headerlink" title="国际电工委员会( IEC )"></a>国际电工委员会( IEC )</h2><ul><li>英文: International Electrotechnical Commission ( <strong>IEC</strong> ) </li><li>主页: <a href="https://www.iec.ch/" target="_blank" rel="noopener">https://www.iec.ch/</a></li><li>成立时间: <strong>1906 年</strong></li><li>设立总部: <strong>日内瓦</strong></li><li>标准内容: <strong>负责有关电工、电子领域的国际标准化工作</strong></li></ul><p><strong>IEC</strong> 成立于 <strong>1906</strong> 年，是世界上最早的国际性电工标准化机构，总部设在日内瓦。但由于 IEC 只关注电工领域标准化，而其他方面缺少标准化组织进行全球化规范。而直到 <strong>1947 年</strong> 国际化标准组织 ISO(下面会介绍) 成立，其关注全方面的标准化内容。</p><p>而 <strong>IEC</strong> 既然已经在电工领域进行标准化运作了，因此，IEC 作为电工部门并入 ISO，但在技术上、财务上仍保持其独立性。根据 1976 年 ISO 与 <strong>IEC</strong> 的新协议，两组织都是法律上独立的组织，<strong>IEC</strong> 负责有关电工、电子领域的国际标准化工作，其他领域则由 ISO 负责。 <strong>IEC</strong> 的工作领域包括了电力、电子、电信和原子能方面的电工技术。现已制订国际电工标准 3000 多个。</p><p><strong>IEC</strong> 是世界上最早的国际性标准化组织了，也是因为全球化的发展起源于电力的运用，因此电力领域是最早进行规范化的部分，而其他部分随着历史的发展也不得不成立新的组织。</p><h2 id="国家标准化协会的国际联盟-ISA-已终止"><a href="#国家标准化协会的国际联盟-ISA-已终止" class="headerlink" title="国家标准化协会的国际联盟 ( ISA ) (已终止)"></a><del>国家标准化协会的国际联盟 ( ISA ) (已终止)</del></h2><ul><li>英文: International Federation of the National Standardizing Associations ( <strong>ISA</strong> ) </li><li>成立时间: <strong>1926 年</strong></li><li>标准内容: <strong>负责有关机械工程方面</strong></li><li>终止时间: <strong>1942 年</strong></li></ul><p>前面 <strong>1906 年</strong> 成立的国际电工委员会 ( <strong>IEC</strong> ) 是世界上最早的国际标准化机构， 但它主要专注于<strong>电子领域</strong>。其他技术领域的工作还没有标准化组织进行规定约束，因此在 <strong>1926 年</strong>成立了 <strong>国家标准化协会的国际联盟 ( ISA )</strong> 来承担该角色，<strong>ISA</strong> 的重点在于<strong>机械工程</strong>方面。直到 <strong>1939.9.1-1945.9.2</strong> 爆发的第二次世界大战，<strong>ISA</strong> 的工作最终在 <strong>1942 年</strong>终止运行。</p><h2 id="国际标准化组织-ISO"><a href="#国际标准化组织-ISO" class="headerlink" title="国际标准化组织 ( ISO )"></a>国际标准化组织 ( ISO )</h2><ul><li>英文: International Organization for Standardization ( <strong>ISO</strong> ) </li><li>主页: <a href="https://www.iso.org/home.html" target="_blank" rel="noopener">https://www.iso.org/home.html</a></li><li>成立时间: <strong>1947 年</strong></li><li>设立总部: <strong>日内瓦</strong></li><li>标准内容: <strong>负责有关工业方面的国际标准化工作</strong></li></ul><p>上面也说了 <strong>ISA</strong> 由于二战最终终止运行了，那非电子领域的国际标准化工作总的有人来做吧。于是，在二战后一年的 1946 年，来自 25 个国家的代表在伦敦召开会议，决定成立一个新的国际组织，其目的是促进国际间的合作和<strong>工业标准的统一</strong>。于是，<strong>ISO</strong> 这一新组织于<strong>1947年2月23日</strong>正式成立，总部设在瑞士的日内瓦。</p><p>ISO 标准的内容涉及广泛，从基础的紧固件、轴承各种原材料到半成品和成品，其技术领域涉及信息技术、交通运输、农业、保健和环境等。</p><p>多人注意到<strong>国际标准化组织( International Organization for Standardization )</strong>的全名与缩写之间存在差异，为什么不是“IOS”呢? 其实，“ISO”并不是首字母缩写，而是一个词 ，它来源于希腊语，意为“相等”，现在有一系列用它作前缀的词，诸如“isometric”(意为“尺寸相等”)、“isonomy”(意为“法律平等”)。从“相等”到“标准”，内涵上的联系使“ISO”成为组织的名称。</p><p>说到 ISO 作为计算机专业的大家是不是一下子就能想到一个互联网基础协议– <strong>OSI 七层网络互联协议</strong>，这里的 OSI 是指<strong>开放系统互联( Open System Interconnection )</strong> 的意思，也是英文缩写，并且该标准就是 ISO 这一标准组织设定的。虽然这七层互联协议在工业实践中被 <strong>TCP/IP</strong> (<em>注: TCP/IP 协议不是由组织定义的而由罗伯特·卡恩、温顿·瑟夫在1978年发明的</em>)协议超越，但它提供的分层设计思想为后来很多系统和协议提供了很大的帮助。</p><p>目前，ISO已经发布了至少 17000多个国际标准，如 <strong>ISO公制螺纹</strong>、<strong>ISO的A4纸张尺寸</strong>、<strong>ISO的集装箱系列（世界上95%的海运集装箱都符合ISO标准）</strong>、<strong>ISO的胶片速度代码</strong>，以及最出名的<strong>ISO9000 品质保证标准</strong>也是由 ISO 发布的。</p><p>由于 ISO 是国际标准，有的时候并不适合国内，因此我国一般会对国际标准进行修改以适应国内情况，为避免国内标准与国际标准不一致，因此国内命名的标准一般以 <strong>GB/T</strong> (<em>GB 国标的首字母，T 表示推荐标准</em>) 开头，对于国际标准的，一般后面接 1+ 国际标准代号，如 <strong>ISO9000</strong> 在国内则叫 <strong>GB/T19000</strong>。</p><h2 id="国际电信联盟-ITU"><a href="#国际电信联盟-ITU" class="headerlink" title="国际电信联盟 ( ITU )"></a>国际电信联盟 ( ITU )</h2><ul><li>英文: International Telecommunications Union ( <strong>ITU</strong> ) </li><li>主页: <a href="https://www.itu.int/zh/Pages/default.aspx" target="_blank" rel="noopener">https://www.itu.int/zh/Pages/default.aspx</a></li><li>成立时间: <strong>1934 年</strong></li><li>设立总部: <strong>日内瓦</strong></li><li>标准内容: <strong>负责有关电信(电通信)方面的国际标准化工作</strong></li></ul><p><strong>ITU</strong> 的历史可追溯到 1865 年。为了顺利实现国际电报通信(<em>注: 1864年，麦克斯韦建立电磁理论</em>)，<strong>1865年5月17日</strong>。当时有20个国家的代表在巴黎签订了一个<strong>《国际电报公约》</strong>。</p><p>之后，</p><ul><li>1875年，<strong>贝尔</strong>发明<strong>电话</strong>。</li><li>1887年，<strong>赫兹</strong>证明<strong>电磁波</strong>的存在。</li><li>1896年，<strong>马可尼</strong>发明无线电报。</li></ul><p>这使得电通信得到长足发展，而无线通信也逐渐步入人类生活。于是，</p><ul><li><strong>1906年</strong>有27个国家代表在柏林签订了一个<strong>《国际无线电报公约》</strong>。</li><li>1924年在巴黎成立了国际电话咨询委员会。</li><li>1925年成立了国际电报咨询委员会。</li><li>1927年在华盛顿成立了国际无线电咨询委员会。</li></ul><p><strong>1932年</strong>, 70多个国家代表在西班牙马德里开会，决定把上述两个公约合并为一个《国际电信公约》，并将电报、电话、无线电咨询委员会改为“国际电信联盟”。并决定自<strong>1934年1月1日</strong>起正式改称为<strong>“国际电信联盟 (ITU)”</strong>。</p><p><strong>1947年10月15日</strong>，经联合国统一，<strong>国际电信联盟( ITU )</strong>成为联合国的一个专门机构，其总部由瑞士伯尔尼迁至到<strong>日内瓦</strong>。ITU 是联合国的15个专门机构之一，但在法律上不是联合国附属机构，它的决议和活动不需联合国批准，但每年要向联合国提出工作报告。</p><p>对于 ITU 的标准规范，我们最熟悉的莫过于无线网络的传输方面的规划了，比如频谱管理、无线电波传播、卫星业务等。未来的 5G 相关传输标准和频率划分也离不开 ITU 的规范。</p><h2 id="ECMA"><a href="#ECMA" class="headerlink" title="ECMA"></a>ECMA</h2><ul><li>英文: European Computer Manufacturers Association ( <strong>ECMA</strong> ) </li><li>中文: 欧洲计算机制造商协会</li><li>主页: <a href="https://www.ecma-international.org/" target="_blank" rel="noopener">https://www.ecma-international.org/</a></li><li>成立时间: <strong>1961 年</strong></li><li>设立总部: <strong>日内瓦</strong></li><li>标准内容: <strong>目标是评估、开发和认可电信和计算机标准</strong></li></ul><p>这个机构我们一般都比较熟悉其下的一个标准 <strong>ECMA-262 ECMAScript 标准</strong>，因为 <strong>JavaScript</strong> 语法就是由其标准化的。</p><p><strong>ECMA</strong> 是 <strong>1961 年</strong> 成立的，与前面的 <strong>IEC、ISO、ITU</strong> 等机构不同，它本身并不是官方机构，而是由主流厂商组成的一个非盈利组织。旨在建立统一的电脑操作格式标准(包括程序语言和输入输出)的组织。该组织的目标是<strong>评估、开发和认可电信和计算机标准</strong>。</p><p>简单说吧，就是 <strong>IEC、ISO、ITU</strong> 等官方机构定义基础设施标准，比如安全级别、通用尺寸、频谱划分等，各种类别都有定义，而 <strong>ECMA</strong> 则只关注计算机方面的基础设施标准，并进一步对应用层方面进行更细致的标准定义，一般由谷歌、微软、苹果等大厂通过实践经验进行提交参议稿，大家可以看<a href="https://baike.baidu.com/item/ECMA" target="_blank" rel="noopener">百度百科 ECMA</a>, 已发布的标准名单里基本都是编码、磁带、软盘、磁盘、文件系统等与计算机相关的标准。</p><p>由于 <strong>ECMA</strong> 也是跟随国际组织的标准的，为便于跟进国际标准，大家决定把 <strong>ECMA</strong> 的总部设在日内瓦，因为这样能够让它与其它与之协同工作的标准制定组织更接近一些，比方说国际标准化组织（<strong>ISO</strong>）和国际电工委员会（<strong>IEC</strong>）。</p><p>对于前面讲的 <strong>ECMAScript</strong> 标准与 <strong>JavaScript</strong> 的关系这里也说下。在 1995 年时，网景公司发布了世界上第一个商用浏览器 <strong>Netscape</strong>, 并同时发明了 <strong>JavaScript</strong> 以便于用户网页动态交互。之后微软发现浏览器的重要性，于是就爆发了世界著名的浏览器大战。微软在 <strong>IE</strong> 中也发布自家的 <strong>JScript</strong> 脚本，之后还有其他的脚本语言出现，如: CEnvi 的 <strong>ScriptEase</strong>。</p><p>这么多脚本语言的出现，导致不同浏览器的脚本写法各不相同，因此，急需一个标准来规范各种网页脚本语言。</p><ul><li>1997 年，JavaScript 1.1 作为一个草案提交给 ECMA，ECMA 的第 39 技术委员会（TC39）被委派来“标准化一个通用、跨平台、中立于厂商的脚本语言的语法和语义”。 锤炼出了 <strong>ECMA-262</strong> 第一版( <strong>ES1</strong> )。而 ECMA 为了避免 JavaScript 版权名问题，于是就将标准定义为 <strong>ECMAScript</strong>，作为全新脚本语言规范。</li><li>1998 年，国际标准化组织及国际电工委员会（ <strong>ISO/IEC</strong> ）也采纳 <strong>ECMAScript</strong> 作为标准（ISO/IEC-16262）。同年发布了 <strong>ECMA-262</strong> 第二个版( <strong>ES2</strong> )</li><li>2002 年，ECMA-262 第三版( <strong>ES3</strong> )，新增引入了强大的正则表达式，更好的字符串处理，新的控制语句，<code>try / catch</code> 异常处理，更严格的错误定义，数字输出的格式化以及预期未来语言增长的微小变化。第三版在当时应用非常广泛，几乎所有的浏览器都支持 <strong>ES3</strong> 的标准。</li></ul><p>ECMA-262 第四版本( <strong>ES4</strong> )夭折，部分功能被迁移到ES6中。</p><ul><li>2009 年：ECMA-262 第五版( <strong>ES5</strong> )发布。在 <strong>ES3</strong> 的基础上增加了很多功能：包括访问器属性，对象的反射创建和检查，属性的程序控制，附加的数组操作函数，对 JSON 对象编码格式的支持以及提供增强的错误检查和程序安全性的严格模式。</li><li>2011 年：被批准为国际标准 ISO/IEC 16262，同年发布 <strong>ES5.1</strong> 版本（对 <strong>ES5</strong> 做一些升级优化）同时被 MCMA-262 和 ISO/IEC 批准</li><li>2015 年：ECMA-262 第六版（ <strong>ES6</strong> 或者叫 <strong>ES 2015 语言规范</strong>），ES6 可以说从2000 年，<strong>ES3</strong> 发布之后就开始沉淀，由于 <strong>ES4</strong> 的夭折，<strong>ES4</strong> 中的一些功能特性一直等到 <strong>ES6</strong> 才发布，所以第六版的完全是十五年的努力的结果。</li></ul><p><strong>ES6</strong> 主要新增了如下功能：主要增强包括模块，类声明，词法块范围，迭代器和生成器，异步编程的承诺，解构模式和适当的尾部调用。内置的 ECMAScript 库被扩展为支持额外的数据抽象，包括映射，集合和二进制数值数组，以及对字符串和正则表达式的使用。</p><p>从 <strong>ES1 到 ES6</strong> ( <strong>ES4</strong> 除外)，不管大家有没有亲身经历过，至少到现在为止我们可以使用由 ECMA 制定好的标准规范，而无需担心各种兼容性问题了。</p><h2 id="互联网工程任务组"><a href="#互联网工程任务组" class="headerlink" title="互联网工程任务组"></a>互联网工程任务组</h2><ul><li>英文: The Internet Engineering Task Force ( <strong>IETF</strong> ) </li><li>主页: <a href="https://www.ietf.org/" target="_blank" rel="noopener">https://www.ietf.org/</a></li><li>成立时间: <strong>1985 年</strong></li><li>标准内容: <strong>负责互联网相关技术规范的研发和制定</strong></li></ul><p><strong>IETF</strong> 也是<strong>非官方机构</strong>，它也只是一个公开性质的<strong>大型民间国际团体</strong>，汇集了与互联网架构和互联网顺利运作相关的网络设计者、运营者、投资人和研究人员，并欢迎所有对此行业感兴趣的人士参与。</p><p>IETF 内部引领者也基本都是苹果、谷歌、微软等公司员工。因为 IETF 的目标是互联网中的技术规范，而互联网中最具影响力的就是操作系统与浏览器(包括搜索引擎)，而这些工具都被苹果、微软、谷歌牢牢掌握住了。也正因为此，这些巨头也希望规范标准向着有利于自身的利益方向发展，从而很多新的规范标准得建议稿以及代码实现、测评也都是由这些巨头公司完成的，毕竟他们的用户都是覆盖全球的、网络流量也都是数一数二的，从这些公司中测试的结果中才能更好地体现标准的性能或优劣。</p><p>就比如我们最常用的 HTTP 协议吧，从 <strong>1999 年</strong> HTTP 1.1 标准发布后，经过了 16 年，直到 <strong>2015 年</strong>才发布 HTTP2。而其中对其贡献最大的莫过于 Google 公司了。因为 <strong>HTTP2</strong> 是基于 Google 在 2009 年提出的 <strong>Spdy</strong> 协议的。而未来的 <strong>HTTP3</strong> 也是基于 Google 提出的 <strong>QUIC</strong> 协议进行设计的，<strong>HTTP3</strong> 的草案也是由 Google 在 2015 年提交给 IETF 的。</p><p>为什么谷歌能引领 HTTP 协议呢？最主要的就是谷歌浏览器占有时长 80% 以上的市场份额，因为 HTTP 新协议的测试必须有两个要素，第一个就是浏览器、第二个就是服务端。服务端很好控制，新协议部署就行，但是浏览器要修改新协议则必须是自家的才行。而 Google 正是因为拥有了大量的浏览器市场份额，才能很早就设计并实验超高性能的新协议。</p><p>正因为有这些巨头乐意参与标准的制定，才会推出性能越来越好、适用范围越来越广的标准规范，推动着时代进步。</p><p><strong>IETF</strong> 制定的是整个互联网的标准，比下面讲的 W3C 机构的范围更广。因为 21 世纪是“万物基于互联网”的时代，而 <strong>W3C</strong> 负责的仅仅是网页内容的规范制定，虽然网页是互联网中最大的应用场景，但仍然有很多其他互联网应用，比如：FTP，邮件，DNS 等等。简单来说，W3C 制定的仅仅是基于 HTTP 协议的网页方面的规范标准，而 IETF 则制定互联网互联互通规范标准，包括各种协议，比如 HTTP 就是 IETF 制定的。另外 IP（包括 IPv4, IPv6）、DNS、SMTP 也都是由 IETF 制定。目前 IETF 的最新工作内容则是 <strong>HTTP3</strong>，还没有发布正式版本。</p><h2 id="W3C"><a href="#W3C" class="headerlink" title="W3C"></a>W3C</h2><ul><li>英文: World Wide Web Consortium ( <strong>WWWC</strong> 又称 <strong>W3C</strong> ) </li><li>中文: 万维网联盟</li><li>主页: <a href="https://www.w3.org/" target="_blank" rel="noopener">https://www.w3.org/</a></li><li>成立时间: <strong>1994 年</strong></li><li>成立地点: <strong>麻省理工学院计算机科学实验室</strong></li><li>标准内容: <strong>最重要的工作是发展 Web 规范，主要包括 HTML、CSS的规范标准</strong></li></ul><p>万维网联盟，又称 <strong>W3C 理事会</strong>。<strong>1994 年</strong>10月在麻省理工学院计算机科学实验室成立。建立者是万维网的发明者<strong>蒂姆·伯纳斯·李</strong>。到目前，W3C 已成为 Web 技术领域最具权威和影响力的<strong>国际中立性技术标准机构</strong>。到目前为止，W3C 已发布了200多项影响深远的 Web 技术标准及实施指南，包括 HTML、XML、WCAG，而最新的 <strong>HTML5</strong>、<strong>CSS3</strong> 分别在 <strong>2014年10月28日</strong>和 <strong>2015年5月20日</strong>由 W3C 组织正式发布。</p><p>W3C 主要关注前端 Web 方面的规范制定，基本上都是静态渲染的语言规范。JavaScript 这个则不是由 W3C 制定的，这个是由前面的<strong>欧洲计算机制造商协会( ECMA )</strong> 制定的，目前已到 <strong>ECMAScript6</strong>，也是 2015 年提出的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.dqzyxy.net/bzh/info/1024/2489.htm" target="_blank" rel="noopener">全球常见十大标准化组织，你都知道吗？</a></li><li><a href="https://www.woyaoce.cn/news/465859.html" target="_blank" rel="noopener">全球常见标准化组织TOP10</a></li><li><a href="http://www.ccsa.org.cn/organization/index.php3" target="_blank" rel="noopener">国际标准化组织</a></li><li><a href="https://www.un.org/chinese/aboutun/uninbrief/institutions.shtml" target="_blank" rel="noopener">联合国专门机构</a></li><li><a href="https://www.jianshu.com/p/8c0cdcb21789" target="_blank" rel="noopener">国际三大标准化组织</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在了解 HTTP 协议的时候知道了 &lt;strong&gt;IETF&lt;/strong&gt; 标准化组织，而前端中的 &lt;strong&gt;W3C&lt;/strong&gt;，以及 &lt;strong&gt;EMCA&lt;/strong&gt; 这些组织也在网上经常看到，还有国际标准化组织 &lt;strong&gt;ISO&lt;/strong&gt; 这些到底有什么关系呢？下面记录下自己的了解。&lt;/p&gt;
&lt;p&gt;主要关键词: &lt;strong&gt;IEC、ISA、ISO、ITU、EMCA 、IETF、W3C&lt;/strong&gt; 等说明;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IEC: 国际电工委员会&lt;/li&gt;
&lt;li&gt;ISA: 国家标准化协会的国际联盟&lt;/li&gt;
&lt;li&gt;ISO: 国际标准化组织&lt;/li&gt;
&lt;li&gt;ITU: 国际电信联盟&lt;/li&gt;
&lt;li&gt;EMCA: 欧洲计算机制造商协会&lt;/li&gt;
&lt;li&gt;IETF: 互联网工程任务组&lt;/li&gt;
&lt;li&gt;W3C: 万维网联盟&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;时间线图示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.godjiyi.cn/jy_20200509001118.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;下面会分别对各个组织进行详细介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="History" scheme="https://www.godjiyi.cn/categories/History/"/>
    
    
      <category term="国际组织" scheme="https://www.godjiyi.cn/tags/%E5%9B%BD%E9%99%85%E7%BB%84%E7%BB%87/"/>
    
      <category term="standardization" scheme="https://www.godjiyi.cn/tags/standardization/"/>
    
  </entry>
  
  <entry>
    <title>基于 gitbook 的项目文档设计</title>
    <link href="https://www.godjiyi.cn/2019/09/15/project-doc/"/>
    <id>https://www.godjiyi.cn/2019/09/15/project-doc/</id>
    <published>2019-09-15T11:07:25.000Z</published>
    <updated>2020-05-02T17:04:24.543Z</updated>
    
    <content type="html"><![CDATA[<p align="center" style="margin: 30px 0 35px;">基于 Gitbook 的开源生态，更具美观的项目文档设计</p><p><img src="http://img.godjiyi.cn/jy_blog-project-doc.jpg" alt></p><p><strong>项目源码地址</strong>：<a href="https://github.com/jiyiren/ProjectDoc" target="_blank" rel="noopener">https://github.com/jiyiren/ProjectDoc</a></p><p><strong>有色Demo预览地址</strong>：<a href="https://jiyiren.github.io/project-doc/" target="_blank" rel="noopener">https://jiyiren.github.io/project-doc/</a></p><p><strong>无色Demo预览地址</strong>：<a href="https://jiyiren.github.io/project-doc-plain/" target="_blank" rel="noopener">https://jiyiren.github.io/project-doc-plain/</a></p><a id="more"></a><p>无色样式：</p><p><img src="http://img.godjiyi.cn/jy_blog-project-doc-plain.jpg" alt></p><h2 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h2><h3 id="安装-Nodejs"><a href="#安装-Nodejs" class="headerlink" title="安装 Nodejs"></a>安装 Nodejs</h3><ul><li>全球官网：<a href="https://nodejs.org/en" target="_blank" rel="noopener">https://nodejs.org/en</a></li><li>中文官网：<a href="http://nodejs.cn/" target="_blank" rel="noopener">http://nodejs.cn/</a></li></ul><p>下载安装后测试下 Node 是否安装成功：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v10.15.3</span><br></pre></td></tr></table></figure></div><p>如果提示命令没找到，那么是由于 Node 没有加入环境变量，大家将安装的 Node 环境地址放在环境变量里就可以了。</p><h3 id="安装-gitbook"><a href="#安装-gitbook" class="headerlink" title="安装 gitbook"></a>安装 gitbook</h3><p>直接输入命令进行安装：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install gitbook-cli -g</span><br></pre></td></tr></table></figure></div><p><code>npm</code> 也是和 <code>node</code> 一起安装的，<code>node</code> 存在 <code>npm</code> 就存在。<code>-g</code> 参数表示全局安装，也就是模块包会安装到全局环境里，这个是推荐做法，因为像这种工具命令全局安装是最好的。而项目依赖模块则项目内安装即可。</p><p>测试 gitbook 命令是否安装成功：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gitbook -V</span><br><span class="line">CLI version: 2.3.2</span><br><span class="line">GitBook version: 3.2.3</span><br></pre></td></tr></table></figure></div><h3 id="使用-gitbook"><a href="#使用-gitbook" class="headerlink" title="使用 gitbook"></a>使用 gitbook</h3><p>任意找一个空目录，执行：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gitbook init</span><br><span class="line">warn: no summary file <span class="keyword">in</span> this book </span><br><span class="line">info: create README.md </span><br><span class="line">info: create SUMMARY.md </span><br><span class="line">info: initialization is finished</span><br></pre></td></tr></table></figure></div><p>会在当前目录下创建出两个文件，分别是：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">README.md</span><br><span class="line">SUMMARY.md</span><br></pre></td></tr></table></figure></div><p>暂且先不管其他的，我们现在可以直接运行试试，先把流程走通：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gitbook build</span><br><span class="line">$ gitbook serve</span><br></pre></td></tr></table></figure></div><p>上面的 <code>gitbook build</code> 是编译整个 <code>markdown</code> 文件，然后在当前目录生成 <code>_book</code> 目录，里面是 html 页面。这个主要在部署的时候用到。</p><p>而 <code>gitbook serve</code> 是本地调试开启服务命令，项目最终是要成网站的，因此, 该命令可以开启本地 <code>http://127.0.0.1:4000</code> 地址作为网站浏览地址。</p><p>假如大家执行 <code>gitbook serve</code> 出错，建议大家先 <code>gitbook build</code> 在 <code>gitbook serve</code>.</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>我们上面通过 <code>gitbook init</code> 生成的只有下面两个文件：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">README.md</span><br><span class="line">SUMMARY.md</span><br></pre></td></tr></table></figure></div><p>但实际上我们要定制我们的 gitbook 项目，项目还有一个配置文件的: <strong>book.json</strong>，只不过 <code>gitbook init</code> 没有自动创建出来。我们一看这文件名就应该知道这个配置文件就是 <code>json</code> 格式的。最基本的 <strong>book.json</strong> 长什么样子呢？如下所示：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"ProjectDoc"</span>,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"jiyiren"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"ProjectDoc"</span>,</span><br><span class="line">  <span class="attr">"language"</span>: <span class="string">"zh-hans"</span>,</span><br><span class="line">  <span class="attr">"links"</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"styles"</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"pluginsConfig"</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>基本 book.json 内容：</p><ul><li><strong>title</strong>: 网站标题;</li><li><strong>author</strong>: 网站作者;</li><li><strong>description</strong>: 网站描述;</li><li><strong>language</strong>: 网站语言;</li><li><strong>links</strong>: 侧边栏配置项;</li><li><strong>styles</strong>: 全局自定义网站样式;</li><li><strong>plugins</strong>: 插件配置项;</li><li><strong>pluginsConfig</strong>: 配置插件的配置项，为一些插件传入参数的;</li></ul><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>上面最基本的 <strong>book.json</strong>，对默认界面基本无变动，其界面显示为：</p><p><img src="http://img.godjiyi.cn/jy_projectddocbasic.jpg" alt></p><p>我们来一个简单 gitbook 定制，<strong>book.json</strong> 如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"title"</span>: <span class="string">"ProjectDoc"</span>,</span><br><span class="line"><span class="attr">"author"</span>: <span class="string">"jiyiren"</span>,</span><br><span class="line"><span class="attr">"description"</span>: <span class="string">"ProjectDoc"</span>,</span><br><span class="line"><span class="attr">"language"</span>: <span class="string">"zh-hans"</span>,</span><br><span class="line"><span class="attr">"links"</span>: &#123;</span><br><span class="line">  <span class="attr">"sidebar"</span>: &#123;</span><br><span class="line">    <span class="attr">"本文托管"</span>: <span class="string">"https://github.com/jiyiren/ProjectDoc"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"styles"</span>: &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"anchor-navigation-ex@0.1.8"</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">"pluginsConfig"</span>: &#123;</span><br><span class="line">    <span class="attr">"anchor-navigation-ex"</span>: &#123;</span><br><span class="line">        <span class="attr">"isRewritePageTitle"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"isShowTocTitleIcon"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"tocLevel1Icon"</span>: <span class="string">"fa fa-hand-o-right"</span>,</span><br><span class="line">        <span class="attr">"tocLevel2Icon"</span>: <span class="string">"fa fa-hand-o-right"</span>,</span><br><span class="line">        <span class="attr">"tocLevel3Icon"</span>: <span class="string">"fa fa-hand-o-right"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其界面为如下，多出左侧栏 <strong>本文托管</strong>，和文章右侧的 <strong>目录以及回到开头</strong> 按钮。</p><p><img src="http://img.godjiyi.cn/jy_projectdocselfdefine.jpg" alt></p><h2 id="必备插件"><a href="#必备插件" class="headerlink" title="必备插件"></a>必备插件</h2><p>插件使用</p><ul><li><p>插件添加：插件的使用就放在 <strong>book.json</strong> 的 <strong>plugins</strong> 和 <strong>pluginsConfig</strong> 键中，形式如：<code>pluginName@versionName</code> 也就是<strong>插件名@版本</strong>，当然没有版本时，采用最新默认版本。</p></li><li><p>插件删除：要删除自带的插件则使用 <code>-pluginName</code> 即 <strong>-插件名</strong></p></li></ul><p>下面介绍本文档使用到的插件。</p><h3 id="splitter"><a href="#splitter" class="headerlink" title="splitter"></a>splitter</h3><p>使侧边栏的宽度可以自由调节</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">    &quot;splitter&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><h3 id="simple-page-toc"><a href="#simple-page-toc" class="headerlink" title="simple-page-toc"></a>simple-page-toc</h3><p>文章页面右上角显示目录，这个目前已经被废弃，建议每个页面自己生成 md 目录。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"plugins"</span> : [</span><br><span class="line">        <span class="string">"simple-page-toc"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"pluginsConfig"</span>: &#123;</span><br><span class="line">        <span class="attr">"simple-page-toc"</span>: &#123;</span><br><span class="line">            <span class="attr">"maxDepth"</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">"skipFirstH1"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="search-plus"><a href="#search-plus" class="headerlink" title="search-plus"></a>search-plus</h3><p>支持中文搜索, 需要将默认的 search 和 lunr 插件去掉</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"plugins"</span>: [<span class="string">"-lunr"</span>, <span class="string">"-search"</span>, <span class="string">"search-plus"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="tbfed-pagefooter"><a href="#tbfed-pagefooter" class="headerlink" title="tbfed-pagefooter"></a>tbfed-pagefooter</h3><p>为页面添加页脚</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"plugins": [</span><br><span class="line">   <span class="string">"tbfed-pagefooter"</span></span><br><span class="line">],</span><br><span class="line">"pluginsConfig": &#123;</span><br><span class="line">    "tbfed-pagefooter": &#123;</span><br><span class="line">        "copyright":"Copyright &amp;copy zhangjikai.com 2017",</span><br><span class="line">        "modify_label": "该文件修订时间：",</span><br><span class="line">        "modify_format": "YYYY-MM-DD HH:mm:ss"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="anchor-navigation-ex"><a href="#anchor-navigation-ex" class="headerlink" title="anchor-navigation-ex"></a>anchor-navigation-ex</h3><p>添加Toc到侧边悬浮导航以及回到顶部按钮，这个自动生成的悬浮目录必须以下面形式书写，也就是一定要有一个是 <strong>h1</strong> 开头的，否则不能识别。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># h1</span><br><span class="line">## h2</span><br><span class="line">### h3</span><br></pre></td></tr></table></figure></div><p>配置代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"plugins"</span>: [</span><br><span class="line">        <span class="string">"anchor-navigation-ex"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"pluginsConfig"</span>: &#123;</span><br><span class="line">        <span class="attr">"anchor-navigation-ex"</span>: &#123;</span><br><span class="line">            <span class="attr">"isRewritePageTitle"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"isShowTocTitleIcon"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"tocLevel1Icon"</span>: <span class="string">"fa fa-hand-o-right"</span>,</span><br><span class="line">            <span class="attr">"tocLevel2Icon"</span>: <span class="string">"fa fa-hand-o-right"</span>,</span><br><span class="line">            <span class="attr">"tocLevel3Icon"</span>: <span class="string">"fa fa-hand-o-right"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="prism"><a href="#prism" class="headerlink" title="prism"></a>prism</h3><p>使用 <code>Prism.js</code> 为语法添加高亮显示，需要将 <code>highlight</code> 插件去掉。该插件自带的主题样式较少，可以再安装 <code>prism-themes</code> 插件，里面多提供了几种样式，具体的样式可以参考 <a href="https://github.com/PrismJS/prism-themes" target="_blank" rel="noopener">这里</a>，在设置样式时要注意设置 css 文件名，而不是样式名。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"-highlight"</span>,</span><br><span class="line">    <span class="string">"prism@^2.1.0"</span>,</span><br><span class="line">    <span class="string">"prism-themes@^0.0.2"</span></span><br><span class="line">  ],</span><br><span class="line"><span class="attr">"pluginsConfig"</span>: &#123;</span><br><span class="line"><span class="attr">"prism"</span>: &#123;</span><br><span class="line">      <span class="attr">"css"</span>: [</span><br><span class="line">        <span class="string">"prism-themes/themes/prism-a11y-dark.css"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其他插件大家可以参考这个博主的：<a href="http://gitbook.zhangjikai.com/plugins.html" target="_blank" rel="noopener">http://gitbook.zhangjikai.com/plugins.html</a></p><p>最终的页面示例</p><p>有配色见：<a href="https://jiyiren.github.io/project-doc/" target="_blank" rel="noopener">https://jiyiren.github.io/project-doc/</a></p><p>无配色见：<a href="https://jiyiren.github.io/project-doc-plain/" target="_blank" rel="noopener">https://jiyiren.github.io/project-doc-plain/</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></li><li><a href="https://jiyiren.github.io/2018/08/04/kafka/" target="_blank" rel="noopener">https://jiyiren.github.io/2018/08/04/kafka/</a></li><li><a href="http://gitbook.zhangjikai.com/themes.html" target="_blank" rel="noopener">http://gitbook.zhangjikai.com/themes.html</a></li><li><a href="http://www.chengweiyang.cn/gitbook/" target="_blank" rel="noopener">http://www.chengweiyang.cn/gitbook/</a></li><li><a href="https://www.cnblogs.com/YangJieCheng/p/7991660.html" target="_blank" rel="noopener">https://www.cnblogs.com/YangJieCheng/p/7991660.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot; style=&quot;margin: 30px 0 35px;&quot;&gt;基于 Gitbook 的开源生态，更具美观的项目文档设计&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.godjiyi.cn/jy_blog-project-doc.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目源码地址&lt;/strong&gt;：&lt;a href=&quot;https://github.com/jiyiren/ProjectDoc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/jiyiren/ProjectDoc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有色Demo预览地址&lt;/strong&gt;：&lt;a href=&quot;https://jiyiren.github.io/project-doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://jiyiren.github.io/project-doc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无色Demo预览地址&lt;/strong&gt;：&lt;a href=&quot;https://jiyiren.github.io/project-doc-plain/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://jiyiren.github.io/project-doc-plain/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Gitbook" scheme="https://www.godjiyi.cn/categories/Gitbook/"/>
    
    
      <category term="project" scheme="https://www.godjiyi.cn/tags/project/"/>
    
      <category term="report" scheme="https://www.godjiyi.cn/tags/report/"/>
    
  </entry>
  
  <entry>
    <title>无版权图库资源收集</title>
    <link href="https://www.godjiyi.cn/2019/09/15/openimage/"/>
    <id>https://www.godjiyi.cn/2019/09/15/openimage/</id>
    <published>2019-09-15T10:55:25.000Z</published>
    <updated>2019-09-15T10:50:07.162Z</updated>
    
    <content type="html"><![CDATA[<p>我平常自己在写文档时，常常会搭配一些图片来展示。一般我都会去 <strong>无版权图片库</strong> 找一张搭配，毕竟程序员老是敲代码和文字打交道，已经苦不堪言了，来一点 <em>色彩图像</em> 刺激真的会让人耳目一新。很多时候程序员不仅仅应该是实现功能方，我们也应该要把自己当做甲方或者用户，去体验什么样的设计才能让自己感觉舒适。<strong>我喜欢有自己的个性，有自己的配色配图</strong>。</p><h1 id="pixabay"><a href="#pixabay" class="headerlink" title="pixabay"></a>pixabay</h1><ul><li><strong>推荐</strong>：★★★★★</li><li>地址：<a href="https://pixabay.com/" target="_blank" rel="noopener">https://pixabay.com/</a></li><li>主页：<img src="http://img.godjiyi.cn/jy_open-pixabay.jpg" alt></li></ul><h1 id="pexels"><a href="#pexels" class="headerlink" title="pexels"></a>pexels</h1><ul><li><strong>推荐</strong>：★★★★★</li><li>地址：<a href="https://www.pexels.com" target="_blank" rel="noopener">https://www.pexels.com/</a></li><li>主页：<img src="http://img.godjiyi.cn/jy_open-pexels.jpg" alt></li></ul><a id="more"></a><h1 id="isorepublic"><a href="#isorepublic" class="headerlink" title="isorepublic"></a>isorepublic</h1><ul><li><strong>推荐</strong>：★★★★★</li><li>地址：<a href="https://isorepublic.com/" target="_blank" rel="noopener">https://isorepublic.com/</a></li><li>主页：<img src="http://img.godjiyi.cn/jy_open-isorepublic.jpg" alt></li></ul><h1 id="gratisography"><a href="#gratisography" class="headerlink" title="gratisography"></a>gratisography</h1><ul><li><strong>推荐</strong>：★★★★</li><li>地址：<a href="https://gratisography.com/" target="_blank" rel="noopener">https://gratisography.com/</a></li><li>主页：<img src="http://img.godjiyi.cn/jy_open-gratisography.jpg" alt></li></ul><h1 id="rawpixel"><a href="#rawpixel" class="headerlink" title="rawpixel"></a>rawpixel</h1><ul><li><strong>推荐</strong>：★★★★</li><li>地址：<a href="https://www.rawpixel.com/" target="_blank" rel="noopener">https://www.rawpixel.com/</a></li><li>主页：<img src="http://img.godjiyi.cn/jy_open-rawpixel.jpg" alt></li></ul><h1 id="polayoutu"><a href="#polayoutu" class="headerlink" title="polayoutu"></a>polayoutu</h1><ul><li><strong>推荐</strong>：★★★★</li><li>地址：<a href="http://www.polayoutu.com/collections" target="_blank" rel="noopener">http://www.polayoutu.com/collections</a></li><li>主页：<img src="http://img.godjiyi.cn/jy_open-polayoutu.jpg" alt></li></ul><h1 id="pxhere"><a href="#pxhere" class="headerlink" title="pxhere"></a>pxhere</h1><ul><li><strong>推荐</strong>：★★★★</li><li>地址：<a href="https://pxhere.com/" target="_blank" rel="noopener">https://pxhere.com/</a></li><li>主页：<img src="http://img.godjiyi.cn/jy_open-pxhere.jpg" alt></li></ul><h1 id="picjumbo"><a href="#picjumbo" class="headerlink" title="picjumbo"></a>picjumbo</h1><ul><li><strong>推荐</strong>：★★★</li><li>地址：<a href="https://picjumbo.com/" target="_blank" rel="noopener">https://picjumbo.com/</a></li><li>主页：<img src="http://img.godjiyi.cn/jy_open-picjumbo.jpg" alt></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://pixabay.com/" target="_blank" rel="noopener">https://pixabay.com/</a></li><li><a href="https://www.pexels.com" target="_blank" rel="noopener">https://www.pexels.com/</a></li><li><a href="https://isorepublic.com/" target="_blank" rel="noopener">https://isorepublic.com/</a></li><li><a href="https://gratisography.com/" target="_blank" rel="noopener">https://gratisography.com/</a></li><li><a href="https://www.rawpixel.com/" target="_blank" rel="noopener">https://www.rawpixel.com/</a></li><li><a href="http://www.polayoutu.com/collections" target="_blank" rel="noopener">http://www.polayoutu.com/collections</a></li><li><a href="https://pxhere.com/" target="_blank" rel="noopener">https://pxhere.com/</a></li><li><a href="https://picjumbo.com/" target="_blank" rel="noopener">https://picjumbo.com/</a></li><li><a href="https://www.yuque.com/ruanyf/weekly/free-photos" target="_blank" rel="noopener">https://www.yuque.com/ruanyf/weekly/free-photos</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我平常自己在写文档时，常常会搭配一些图片来展示。一般我都会去 &lt;strong&gt;无版权图片库&lt;/strong&gt; 找一张搭配，毕竟程序员老是敲代码和文字打交道，已经苦不堪言了，来一点 &lt;em&gt;色彩图像&lt;/em&gt; 刺激真的会让人耳目一新。很多时候程序员不仅仅应该是实现功能方，我们也应该要把自己当做甲方或者用户，去体验什么样的设计才能让自己感觉舒适。&lt;strong&gt;我喜欢有自己的个性，有自己的配色配图&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;pixabay&quot;&gt;&lt;a href=&quot;#pixabay&quot; class=&quot;headerlink&quot; title=&quot;pixabay&quot;&gt;&lt;/a&gt;pixabay&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;推荐&lt;/strong&gt;：★★★★★&lt;/li&gt;
&lt;li&gt;地址：&lt;a href=&quot;https://pixabay.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pixabay.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;主页：&lt;img src=&quot;http://img.godjiyi.cn/jy_open-pixabay.jpg&quot; alt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;pexels&quot;&gt;&lt;a href=&quot;#pexels&quot; class=&quot;headerlink&quot; title=&quot;pexels&quot;&gt;&lt;/a&gt;pexels&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;推荐&lt;/strong&gt;：★★★★★&lt;/li&gt;
&lt;li&gt;地址：&lt;a href=&quot;https://www.pexels.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.pexels.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;主页：&lt;img src=&quot;http://img.godjiyi.cn/jy_open-pexels.jpg&quot; alt&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="资源" scheme="https://www.godjiyi.cn/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="无版权" scheme="https://www.godjiyi.cn/tags/%E6%97%A0%E7%89%88%E6%9D%83/"/>
    
      <category term="图片" scheme="https://www.godjiyi.cn/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>2019-07-28 日志</title>
    <link href="https://www.godjiyi.cn/2019/07/28/life_work/"/>
    <id>https://www.godjiyi.cn/2019/07/28/life_work/</id>
    <published>2019-07-28T07:16:40.000Z</published>
    <updated>2019-11-06T13:08:51.348Z</updated>
    
    <content type="html"><![CDATA[<p>最近，我也毕业入职了，用了一个月时间熟悉了身边新环境，虽说还可以，但仍旧心有不安。</p><p>今年都说工作形式不好，多家互联网企业被爆裁员。互联网，曾今是多么充满活力的名词，基本上是”万众创业”的根本，而现在给人的则是”赢者通吃”的感觉，再无敢与巨头相争，百花齐放的景象了。</p><p>虽说现在巨头当道，创业热情没有以前的高，但互联网仍然是最大的创业领域。目前，移动互联的创业确实少了，但是 5G、IoT、人工智能的创业项目却有很多。</p><p>很多时候我们都在以我们自己能看到的信息进行评判和决策的，由于我们都处于历史长河中的一部分，在那一部分中我们的绝大部分技能、信息都聚焦于某一种东西上，如果时代改变了这种东西的价值，那我们自身的价值也会相应变化，最坏的情况就是贬值，而这正是互联网的特性。</p><p>心有不安，不安在时代正在极速地改变着最吃香的技能，而自己的技能却在逐步被淘汰！很多人怕的不是被裁，而是怕自己已经适应不了社会的需求了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近，我也毕业入职了，用了一个月时间熟悉了身边新环境，虽说还可以，但仍旧心有不安。&lt;/p&gt;
&lt;p&gt;今年都说工作形式不好，多家互联网企业被爆裁员。互联网，曾今是多么充满活力的名词，基本上是”万众创业”的根本，而现在给人的则是”赢者通吃”的感觉，再无敢与巨头相争，百花齐放的景象
      
    
    </summary>
    
    
      <category term="日志" scheme="https://www.godjiyi.cn/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="Life" scheme="https://www.godjiyi.cn/tags/Life/"/>
    
      <category term="日志" scheme="https://www.godjiyi.cn/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="Work" scheme="https://www.godjiyi.cn/tags/Work/"/>
    
  </entry>
  
  <entry>
    <title>一份 LaTeX 报告形式模板</title>
    <link href="https://www.godjiyi.cn/2018/12/13/report_paper/"/>
    <id>https://www.godjiyi.cn/2018/12/13/report_paper/</id>
    <published>2018-12-13T02:07:25.000Z</published>
    <updated>2018-12-13T03:10:48.370Z</updated>
    
    <content type="html"><![CDATA[<p align="center" style="margin: 30px 0 35px;">A LaTeX Template for Report, With Supporting Chinese Language</p><p><img src="http://img.godjiyi.cn/jy_hothit.jpg" alt></p><p><strong>项目源码地址</strong>：<a href="https://github.com/jiyiren/ReportPaper" target="_blank" rel="noopener">https://github.com/jiyiren/ReportPaper</a></p><p><strong>文档预览地址</strong>：<a href="http://img.godjiyi.cn/report_paper.pdf" target="_blank" rel="noopener">http://img.godjiyi.cn/report_paper.pdf</a></p><a id="more"></a><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>需要先安装 LaTeX 环境，而支持中文的 LaTeX 为 <a href="http://www.ctex.org/HomePage" target="_blank" rel="noopener">CTeX</a>，CTeX 也只是一种标准定义，其通常分为两个发行版：</p><ul><li>TeXLive: <a href="http://tug.org/texlive/" target="_blank" rel="noopener">http://tug.org/texlive/</a> </li><li>MiKTeX: <a href="https://miktex.org/" target="_blank" rel="noopener">https://miktex.org/</a></li></ul><p>两个发行版都是全平台支持的，很多人会将 <a href="http://tug.org/mactex/" target="_blank" rel="noopener">MacTex</a> 也作为一种发行版，但我喜欢将其归类于 TeXLive 发行版中，这看自己的意愿。</p><p>因此，环境的话大家可以自行选择，这里为使用 TeXLive，下面为安装包地址，大概有 3 GB 左右：</p><ul><li>MacOS: <a href="http://tug.org/mactex/" target="_blank" rel="noopener">MacTex</a></li><li>Windows: <a href="http://mirrors.hust.edu.cn/CTAN/systems/texlive/Images/" target="_blank" rel="noopener">TeXLive.iso</a></li></ul><p>安装后将命令加入环境变量，并使之生效，通过 <code>which latex</code> 可查看是否设置成功：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> latex</span><br><span class="line">/usr/<span class="built_in">local</span>/texlive/2018/bin/x86_64-darwin/latex</span><br></pre></td></tr></table></figure></div><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>LaTeX 实际上如果 Java 语言一样，都需要先配置环境，然后选择一款自己喜欢的 IDE 进行编写“代码”。</p><p>当然所有文本编辑器都可以编写 LaTeX 或者 Java 等其他语言“代码”。这里的 IDE 指集成了一些语言本地化的功能，比如编译、特殊符号等等。</p><p>LaTeX 的发行版中会自带一款编辑器，用 TexLive 的话，MacOS 上会有个叫 <strong>TexShop</strong> 的编辑器，而 Windows 上则会是一个叫 <strong>TexWorker</strong> 的编辑器，这些是都可以胜任编写工作的。</p><p>另外，对于第三的 LaTeX 编辑器，笔者也用的不多，这里我推荐两个：</p><ul><li>TeXMaker: <a href="http://www.xm1math.net/texmaker/" target="_blank" rel="noopener">http://www.xm1math.net/texmaker/</a>, 全平台，免费，强烈推荐；</li><li>TeXStudio: <a href="http://texstudio.sourceforge.net/" target="_blank" rel="noopener">http://texstudio.sourceforge.net/</a> , 全平台，免费，推荐；</li><li>WinEdt: <a href="http://www.winedt.com/index.html" target="_blank" rel="noopener">http://www.winedt.com/index.html</a> , 只支持 Windows，收费，自己选；</li></ul><p>我个人推荐前两个，因为第三个收费且不跨平台，之所以写上第三个，主要是因为网络上很多博客或用户都推荐用第三个，这个我使用时也感觉不错，但每次我使用都得到 Windows 上使用，比较麻烦。当然，如果你使用 Windows 且有钱，WinEdt 确实使用体验和功能都是比较好的。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>上面两点都讲了没实际作用的环境配置，对于使用本项目实际上很简单：</p><ul><li><p>使用 XeLaTeX 编译：</p>  <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xelatex report_paper.tex</span><br></pre></td></tr></table></figure></div></li><li><p>用 BiBTeX 再次编译生成的 <code>report_paper.aux</code> 文件：</p>  <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bibtex report_paper.aux</span><br></pre></td></tr></table></figure></div></li><li><p>之后再次用 XeLaTeX 编译：</p>  <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xelatex report_paper.tex</span><br></pre></td></tr></table></figure></div></li></ul><p>这时候生成的 <code>pdf</code> 文件是最全和完整的文档。</p><p>上面是命令行编译的，大家若使用 IDE 则是比较简单的操作：</p><ul><li>编译选择 XeLaTeX 编译一次；</li><li>再选择 BiBTeX 编译一次；</li><li>再选择 XeLaTeX 编译一次；</li></ul><p>这时产生的 <code>pdf</code> 和上面一致；通过编辑器形式不用自己指定文件名，因此更简单方便。</p><p>最终生成的 pdf 文档示例：</p><ul><li>github: <a href="https://github.com/jiyiren/ReportPaper/blob/master/report_paper.pdf" target="_blank" rel="noopener">report_paper.pdf</a></li><li>七牛：<a href="http://img.godjiyi.cn/report_paper.pdf" target="_blank" rel="noopener">report_paper.pdf</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.ctex.org/HomePage" target="_blank" rel="noopener">CTeX</a></li><li><a href="http://tug.org/texlive/" target="_blank" rel="noopener">TexLive</a></li><li><a href="https://miktex.org/" target="_blank" rel="noopener">MiKTeX</a></li><li><a href="http://www.tug.org/mactex/index.html" target="_blank" rel="noopener">MacTeX</a></li><li><a href="http://www.xm1math.net/texmaker/index.html" target="_blank" rel="noopener">TexMaker(全平台支持编辑器)</a></li><li><a href="http://texstudio.sourceforge.net/" target="_blank" rel="noopener">TeXstudio(全平台支持编辑器)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot; style=&quot;margin: 30px 0 35px;&quot;&gt;A LaTeX Template for Report, With Supporting Chinese Language&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;http://img.godjiyi.cn/jy_hothit.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目源码地址&lt;/strong&gt;：&lt;a href=&quot;https://github.com/jiyiren/ReportPaper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/jiyiren/ReportPaper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文档预览地址&lt;/strong&gt;：&lt;a href=&quot;http://img.godjiyi.cn/report_paper.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://img.godjiyi.cn/report_paper.pdf&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LaTeX" scheme="https://www.godjiyi.cn/categories/LaTeX/"/>
    
    
      <category term="report" scheme="https://www.godjiyi.cn/tags/report/"/>
    
      <category term="latex" scheme="https://www.godjiyi.cn/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="https://www.godjiyi.cn/2018/08/04/kafka/"/>
    <id>https://www.godjiyi.cn/2018/08/04/kafka/</id>
    <published>2018-08-04T04:07:25.000Z</published>
    <updated>2018-09-18T12:32:32.190Z</updated>
    
    <content type="html"><![CDATA[<p align="center" style="margin: 30px 0 35px;">分布式消息系统，解耦模块的桥梁</p><p><strong><a href="http://kafka.apache.org/" target="_blank" rel="noopener">Kafka</a></strong> 是一个基于 <strong>发布-订阅</strong> 的分布式消息系统，主要面向于大数据应用场景。它最初由 <em>LinkedIn</em> 公司开发，之后成为 <em>Apache</em> 项目的一部分。<strong>Kafka</strong> 是一种快速、可扩展、本身就专注于分布式的、实时消息流系统。<strong>Kafka</strong> 在2010 年正式向 <em>Apache</em> 社区开源，目前社区活跃。目前在互联网公司使用非常广泛，已经成为大数据分析的基础服务。</p><a id="more"></a><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>Kafka 是众多消息系统中的一种实现方式，那我们为什么需要用到 <strong>消息系统</strong> ？这里我列出以下几种在业务中常常碰到的场景，分别从 <strong>系统架构视角</strong>、<strong>消息传播视角</strong>、<strong>消息处理视角</strong>、<strong>自身系统结构视角</strong> 共四个角度的应用场景来说明：</p><!-- more --><h3 id="模块解耦"><a href="#模块解耦" class="headerlink" title="模块解耦"></a>模块解耦</h3><blockquote><p>从系统架构视角看</p></blockquote><p>这个我想是最明显的一点了，在业务系统上通常会存在一些系统产生数据，一些系统消费数据，这实际上就是 <strong>生产者–消费者</strong> 模式。这里的解耦是什么意思呢？我把消息系统独立出来了，那我的消息系统则会依赖生产者系统，消费系统则会依赖消息系统，不是多出了两个依赖，何为 <strong>解耦</strong> 呢？</p><p>这里的解耦实际上是解耦 <strong>不等速率依赖</strong> (这个名词是我造的，纯属个人观点)。也就是说生产者系统和消费者系统之间会有 <em>生产和消费速度不一致</em> 而导致消息丢失的情况。而消息系统与生产者系统、消息系统与消费者系统之间则没有这种情况，即使有也不会造成消息丢失(只会暂存下来)。因此，破除了生产者系统和消费者系统的依赖关系就叫 <strong>解耦</strong>，而消息系统正是为此而生。</p><h3 id="异步通信-缓冲队列"><a href="#异步通信-缓冲队列" class="headerlink" title="异步通信/缓冲队列"></a>异步通信/缓冲队列</h3><blockquote><p>从消息传播视角看</p></blockquote><p>很多时候，或并发达到一定量级的时候，系统是不能完全提供 <strong>实时消息</strong> 处理的能力的。这时不能立即处理的消息我们必须把这些请求放入 <strong>缓冲队列</strong> 中以等待处理。这种场景在一个公司中可能会有多种业务都会涉及到，因此，领先者们自然想到可以将缓冲队列设计成一个独立的平台，以满足各种业务的接入，从而，<strong>消息系统作为缓冲异步队列轰然降临</strong>。</p><p>这里我使用的是 <strong>缓冲</strong> 队列而非 <strong>缓存</strong> 队列，主要是因为通常我们所说的缓存都是基于内存的，而 <strong>缓冲</strong> 则更普遍一点，你可以让它基于内存，也可以让它基于 <strong>硬盘</strong> 的。通常消息系统基本上都是基于硬盘存储的，包括 Kafka 其也是持久化到硬盘的。</p><p>那 <strong>缓冲队列</strong> 与我们的 <strong>Redis/Memcached 缓存</strong> 或者 <strong>DB 数据库</strong> 有什么区别呢，为什么不用 Redis/Memcached 或者 DB 实现 <strong>缓冲</strong> 功能呢？</p><p>这里我也大概谈下自己的看法：</p><ol><li>先说 <em>基于内存的缓存</em> 吧，缓存的出现都是为了用昂贵的内存代价换来性能上的提升的，缓存通常是暂存那些常被访问的数据以提升较好的用户体验而设计，我们的 <strong>消息系统</strong> 并不是为了 <strong>快</strong>，而是为了 <strong>数据完整性，不丢失</strong> 而作的缓冲设计。因此，我们无需用如此昂贵的内存来作为消息系统的存储介质。另外一点就是缓冲的队列有可能会很大，达到<strong>千万甚至更多级别</strong>，这样如果用内存，那么代价就更昂贵了。</li><li>再说 <em>DB 数据库</em>，上面讲了内存昂贵，那我用数据库总可以了吧！那我们还是先想想数据库的原生作用：数据库是为持久化，通常是恒久的持久化而生的，也就是数据存下去，基本就不用变了，只会少量的修改删除。我们再想想缓冲队列，它是为 <strong>临时存储</strong> 而生的。用持久化的数据库来存临时数据，那会造成频繁的增删操作，势必会给数据库带来极大的性能消耗。</li><li>总结下，缓冲队列目标是：<strong>数据完整性</strong> (而非存读的快速性，不是缓存)，<strong>临时存储能力</strong> (而非恒久持久性，不是数据库)。</li></ol><h3 id="数据一致性保障"><a href="#数据一致性保障" class="headerlink" title="数据一致性保障"></a>数据一致性保障</h3><blockquote><p>从消息处理视角看</p></blockquote><p>有些情况下，我们将数据提交给某个系统处理，有可能那个系统突然崩溃了，那传给它的数据就都覆灭了，这可是企业不能容忍的！因此，我们可以利用消息系统，作为临时备份处，将消息同时发送给消息系统以及那个处理系统，当处理系统处理成功后，发送确认操作让消息系统删除那条消息，也就是采用 “<strong>插入-获取-删除</strong>“ 范式。这样，假如处理系统崩溃，那数据仍然在消息队里中，重启处理系统就可以了。</p><p>这里，我们都是假设消息系统很可靠，比处理系统更可靠！为什么有这个依据呢？这实际上也是消息系统的另一大特性，就是可扩展性强，部分组件失效可容忍。</p><h3 id="可扩展性强，部分组件失效可容忍"><a href="#可扩展性强，部分组件失效可容忍" class="headerlink" title="可扩展性强，部分组件失效可容忍"></a>可扩展性强，部分组件失效可容忍</h3><blockquote><p>从自身结构视角看</p></blockquote><p>这部分的内容我们在后面几节进行说明。</p><h2 id="消息模式"><a href="#消息模式" class="headerlink" title="消息模式"></a>消息模式</h2><p>消息模式就是消息系统实现时需要考虑的业务场景中的不同情况。由于生产者(系统)和消费者(系统)都可能是多个，那么就会产生一些微妙的不同。这里我们只考虑它们都处理相同的消息。对于多个生产者而言，消息系统就是不断接受消息的一个存储域，因此没有什么不同。而对于多个消费者而言就会有两种情况了：</p><ol><li>一个消息只给一个消费者消费：这个是最常见的情况了，一个消息无法被重复消费的，因此这种情况对应到消息模式就是 <strong>点对点模式或者叫队列模式</strong>。</li><li>一个消息可以给多个消费者消费：这个情况类比订阅付费服务，比如我是一家报社，有很多人订阅了我的报纸，只要我这边有新报纸刊登，我就需要把这些新报纸寄送给每一个订阅的人。因此这种情况对应到消息模式就叫 <strong>发布/订阅模式</strong>。</li></ol><p>以上两种模式就是消息模式最常见的两种，所有的消息系统的实现都会考虑这两种模式的，因此大家在学习一个新的消息系统的时候就可以考虑这个消息系统 <strong>如何实现者两种情况的</strong>。对于 Kafka 我们会在下面讲到其对应的两种模式。</p><h2 id="平台对比"><a href="#平台对比" class="headerlink" title="平台对比"></a>平台对比</h2><p>消息系统目前最有名气的大概有四个：<strong>ActiveMQ</strong>、<strong>RabbitMQ</strong>、<strong>Kafka</strong>、<strong>RocketMQ</strong>. 它们的对比网上也应该有很多了，我就不一一列举了。</p><p>这里我将我之前做过的 PPT 拿过来放这里作下对比，我简单说明下：</p><ul><li>下图各个消息系统从左到右，支持的消息量级越来越大，<strong>ActiveMQ</strong> 最小，<strong>RocketMQ</strong> 最大；</li><li><strong>ActiveMQ、RabbitMQ</strong> 稳定性是相对较好的，<strong>RabbitMQ</strong> 稳定性更好同时数据安全性最高，如果对实时性、数据不允许丢失要求高时，可以用 <strong>RabbitMQ</strong>；</li><li><strong>RocketMQ</strong> 是阿里开源的，其处理量是最高的，但是生态比较少，因此若使用过程中出现问题，你只能找原开发者或维护者了；</li><li><strong>Kafka</strong> 是目前生态链最广、社区最活跃的消息系统了。但是其会存在消息丢失情况，通常应用在分布式日志消息处理等这些对消息丢失可容忍性的场景。目前，大数据已成主流的今天，<em>Kafka 也逐渐成为使用的主流消息系统</em>，因为大数据对消息丢失一般都是可容忍的，比如训练集中丢了几条数据等等，都是无相关的。而对于 <strong>支付、会员</strong> 等这些消息则不推荐用 Kafka ，可转用其他 MQ 系统。</li></ul><p><img src="img.godjiyi.cn/csdnblogdistribute_msg.jpg" alt></p><h2 id="宏观结构"><a href="#宏观结构" class="headerlink" title="宏观结构"></a>宏观结构</h2><p>下图是 Kafka 消息系统的 <strong>分布式宏观架构图</strong>，这里分别讲下各个组件的作用及其关系：</p><ol><li><em>Producer</em>: 数据的生产客户端，生产数据发送到 <strong>Kafka Cluster</strong>；</li><li><em>Zookeeper</em>: 负责整体集群的协调工作，保存 <strong>Broker</strong> 与 <strong>Consumer</strong> 交互的元信息，并进行数据变更监控；</li><li><em>Broker</em>: <strong>Broker</strong> 实际上就是单台服务器，其主要接收 <strong>Producer</strong> 和 <strong>Consumer</strong> 请求，持久化<strong>Message</strong>，其中会通过选举产生一个 <strong>Controller</strong>，来主持协调工作；</li><li><em>Kafka Cluster</em>: 由多个 <strong>Borker</strong> 和一套 <strong>Zookeeper</strong> 组成，<strong>Broker</strong> 之间无主从关系，地位平等，可任意增删节点，这主要由 <strong>Zookeeper</strong> 维护；</li><li><em>Consumer</em>: 数据的消费客户端，用于从 <strong>Broker</strong> 中订阅/拉取消息；</li></ol><p><img src="http://img.godjiyi.cn/csdnblog20180805003823.png" alt></p><h2 id="微观设计"><a href="#微观设计" class="headerlink" title="微观设计"></a>微观设计</h2><p>Kafka <strong>内部消息传递流程</strong> 如下图所示：</p><p><img src="http://img.godjiyi.cn/csdnblogkafka-arc.jpg" alt></p><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>一个 <strong>消息主题</strong>，也就是一个分布式业务消息队列。不同的生产者将不同的业务消息分发到不同的 <strong>topic</strong> 上，这样，消费者就可以根据 <strong>topic</strong> 进行对应的业务消息消费了。</p><h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p>这个就是 topic 分布式的体现，由于一个 topic 就是一个业务消息，这些消息可能会源源不断来，并且有可能会同时并发很大地进入队列，将这些消息合理地分布在分布式机器中则可以保证机器的负载均衡性，同时也可以使得不同的消费者可以同时拉取不同 partition 中的消息，可提升消费者并发性能，这里总结下 <strong>partition</strong> 特性：</p><ul><li>一个 <strong>topic</strong> 分成多个 <strong>partion</strong>；</li><li>多个 <strong>producer</strong> 生产消息可以并行入队，多个 <strong>Consumer</strong> 可并行消费；</li><li>同一个 <strong>partition</strong> 里保证消息有序, 不同 <strong>partition</strong> 则不能完全保证有序；</li></ul><h3 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h3><p>消费者组应该是 Kafka 最大的特色了，消费者组就是消费者组成的一个组，消费者在向 Kafka 拉取数据的时候需要提供一个组名，这个名称就是消费者组名，上面的两种消息模式都可以在消费者组中得到实现：</p><ol><li><em>点对点/队列模式</em>：一个消息只能被一个消费者消费，我们只需要将这些消费者放在同一个消费者组里就可以了，这样消费者在同一个组中，那么 topic 中的一条消息只会向一个消费者组发送一次；</li><li><em>发布-订阅模式</em>：一个消息可被多个消费者消费，这种情况，我们只需要将各个消费者放在各自单独的组中，各个组均订阅了此消息 topic 就可以了。</li></ol><p>这里还有如下注意点：</p><ul><li>一个消费组消费一个 <strong>topic</strong> 的全量数据；</li><li>组内消费者消费一个或多个 <strong>partition</strong> 数据，如果一个组里的消费者数量少于订阅的 topic 的 partition 数量，那么组中必有一个消费者要消费多个 partion 数据；</li><li>一个组里的消费者应小于等于 <strong>topic</strong> 的 <strong>partition</strong> 数量，这是因为一个 partition 最多只能与一个 consumer 连接，那么如果 partition 数量大于 consumer 数量，则必定有 consumer 是空闲的，因此尽量避免这种情况；</li></ul><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="http://opentsdb.net/docs/build/html/index.html" target="_blank" rel="noopener">http://opentsdb.net/docs/build/html/index.html</a></li><li><a href="http://liubin.org/blog/2016/03/05/tsdb-opentsdb/" target="_blank" rel="noopener">http://liubin.org/blog/2016/03/05/tsdb-opentsdb/</a></li><li><a href="https://www.jianshu.com/p/0bafd0168647" target="_blank" rel="noopener">https://www.jianshu.com/p/0bafd0168647</a></li><li><a href="http://www.nosqlnotes.com/technotes/opentsdb-tabledesign/" target="_blank" rel="noopener">http://www.nosqlnotes.com/technotes/opentsdb-tabledesign/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot; style=&quot;margin: 30px 0 35px;&quot;&gt;分布式消息系统，解耦模块的桥梁&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://kafka.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kafka&lt;/a&gt;&lt;/strong&gt; 是一个基于 &lt;strong&gt;发布-订阅&lt;/strong&gt; 的分布式消息系统，主要面向于大数据应用场景。它最初由 &lt;em&gt;LinkedIn&lt;/em&gt; 公司开发，之后成为 &lt;em&gt;Apache&lt;/em&gt; 项目的一部分。&lt;strong&gt;Kafka&lt;/strong&gt; 是一种快速、可扩展、本身就专注于分布式的、实时消息流系统。&lt;strong&gt;Kafka&lt;/strong&gt; 在2010 年正式向 &lt;em&gt;Apache&lt;/em&gt; 社区开源，目前社区活跃。目前在互联网公司使用非常广泛，已经成为大数据分析的基础服务。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kafka" scheme="https://www.godjiyi.cn/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="https://www.godjiyi.cn/tags/Kafka/"/>
    
      <category term="Message" scheme="https://www.godjiyi.cn/tags/Message/"/>
    
  </entry>
  
  <entry>
    <title>OpenTSDB 存储结构</title>
    <link href="https://www.godjiyi.cn/2018/07/03/opentsdb-store/"/>
    <id>https://www.godjiyi.cn/2018/07/03/opentsdb-store/</id>
    <published>2018-07-03T04:07:25.000Z</published>
    <updated>2018-09-18T12:32:49.400Z</updated>
    
    <content type="html"><![CDATA[<p align="center" style="margin: 30px 0 35px;">时序处理数据库，更快的存储和聚合</p><p><strong>OpenTSDB</strong> 是为存储时序数据而设计的，它基于 <strong>HBase</strong> 存储数据，充分发挥了 <strong>HBase</strong> 的分布式列存储特性，支持数百万每秒的读写，支持千万数目的 <strong>Metric</strong>，它的特点就是容易扩展，具有灵活的 <em>Tag</em> 机制。其主要用途，就是做监控系统，譬如收集大规模集群（ 包括网络设备、操作系统、应用程序 ）的 <strong>监控数据</strong> 并进行存储和聚合查询，在目前的 <strong>IoT</strong> 方面具有很大的应用价值。</p><a id="more"></a><h2 id="Hbase-Schema"><a href="#Hbase-Schema" class="headerlink" title="Hbase Schema"></a>Hbase Schema</h2><p><strong>OpenTSDB</strong> 是基于 <strong>Hbase</strong> 存储系统的，主要利用了 Hbase <strong>数据自动排序</strong> 以及 <strong>可靠的分布式特性</strong>。 <strong>OpenTSDB</strong> 在安装启动时，默认在 <strong>Hbase</strong> 里面创建 <strong>四张</strong> 表。分别为：</p><ol><li><em>tsdb</em>: 存储数据点表，也就是存储实际的时序数据，绝大部分的数据是存在这个表中；</li><li><em>tsdb-uid</em>: 存储 <strong>name</strong> 和 <strong>uid</strong> 的映射关系，也就是给字符串的键、值映射成数值，通常包括 <strong>metric</strong>、<strong>tagk</strong>、<strong>tagv</strong> 等字符串映射。</li><li><em>tsdb-meta</em>: 元数据表，这个只有通过配置文件开启才会存储数据的，默认不开启。如果开启了存储的就是你传过来的<strong>完整的 json 格式数据</strong>，没有经过解析的，这就是元数据。</li><li><em>tsdb-tree</em>: 树形表，这个也是只有开启配置文件选项才能使用，开启后可以由自己创建和管理自己的树形 <strong>metric</strong> 结构，需要自己设计管理的。</li></ol><p>下面主要说明下 <em>tsdb</em> 和 <em>tsdb-uid</em> 的表结构。</p><h2 id="UID-Table-Schema"><a href="#UID-Table-Schema" class="headerlink" title="UID Table Schema"></a>UID Table Schema</h2><p>这里我们主要分析下 OpenTSDB 存储 <strong>UID</strong> 的表 – <strong>tsdb-uid</strong>。</p><p>首先，看下 <em>tsdb-uid</em> 的表结构。其存储的是字符串到 <strong>UID</strong> 的映射关系。</p><p>我们可以通过 <code>hbase shell</code> 通过 <strong>Hbase</strong> 访问数据库入口查看小 <em>tsdb-uid</em> 的表结构：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list <span class="string">'tsdb-uid'</span></span><br><span class="line"><span class="comment"># == 结果如下 ==</span></span><br><span class="line">Table tsdb-uid is ENABLED                                                                                                                                     </span><br><span class="line">tsdb-uid                                                                                                                                                      </span><br><span class="line">COLUMN FAMILIES DESCRIPTION                                                                                                                                   </span><br><span class="line">&#123;NAME =&gt; <span class="string">'id'</span>, BLOOMFILTER =&gt; <span class="string">'ROW'</span>, VERSIONS =&gt; <span class="string">'1'</span>,... &#125;                                               </span><br><span class="line">&#123;NAME =&gt; <span class="string">'name'</span>, BLOOMFILTER =&gt; <span class="string">'ROW'</span>, VERSIONS =&gt; <span class="string">'1'</span>,... &#125;                                             </span><br><span class="line">2 row(s) <span class="keyword">in</span> 0.0360 seconds</span><br></pre></td></tr></table></figure></div><p>上面结果我只列出了少量信息，主要看 <em>NAME</em> 就可以了，表示该表的 <strong>Column Family</strong>, 分别为 <em>name</em> 列族和 <em>id</em> 列族。那具体怎么将字符串映射为 <strong>UID</strong> ? 这里就需要通过实际的例子来说明。</p><p>我们先上传一个数据，格式内容如下，可以通过 <strong>Postman</strong> 进行上传测试，<strong>OpenTSDB</strong> 默认上传地址为 <code>http://ip:4242/api/put?details</code>，后缀 <em>details</em> 是为了查看上传反馈。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"metric"</span>: <span class="string">"sys.test.metric"</span>,</span><br><span class="line">        <span class="attr">"timestamp"</span>: <span class="number">1528784369</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="attr">"tags"</span>: &#123;</span><br><span class="line">           <span class="attr">"hostname"</span>: <span class="string">"jiyiren"</span>,</span><br><span class="line">           <span class="attr">"area"</span>: <span class="string">"shanghai"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><p>上传成功后返回：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"success"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"errors"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们先看下我们上传的数据格式，需要进行映射的字符串是对应 <code>metric</code>, <code>tagkey</code>, <code>tagvalue</code> 的，这里 <code>tag</code> 有两组，所以要映射的有 5 个字符串，分别为： <em>sys.test.metric</em>, <em>hostname</em>, <em>jiyiren</em>, <em>area</em>, <em>shanghai</em>.</p><p>那我们就再用 <strong>Hbase Shell</strong> 查看表内容：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scan <span class="string">'tsdb-uid'</span></span><br><span class="line"><span class="comment"># === 结果如下 ===</span></span><br><span class="line">ROW                                      COLUMN+CELL </span><br><span class="line">\x00\x00\x01  column=name:metrics, timestamp=1528517476774, value=sys.test.metric</span><br><span class="line">\x00\x00\x01  column=name:tagk, timestamp=1528517476790, value=area </span><br><span class="line">\x00\x00\x01  column=name:tagv, timestamp=1528517476803, value=shanghai</span><br><span class="line">\x00\x00\x02  column=name:tagk, timestamp=1528517476816, value=hostname                                              </span><br><span class="line">\x00\x00\x02  column=name:tagv, timestamp=1528517476830, value=jiyiren </span><br><span class="line">area      column=id:tagk, timestamp=1528517476793, value=\x00\x00\x01</span><br><span class="line">hostname  column=id:tagk, timestamp=1528517476819, value=\x00\x00\x02</span><br><span class="line">jiyiren   column=id:tagv, timestamp=1528517476832, value=\x00\x00\x02</span><br><span class="line">shanghai  column=id:tagv, timestamp=1528517476806, value=\x00\x00\x01</span><br><span class="line">sys.test.metric column=id:metrics, timestamp=1528517476778, value=\x00\x00\x01</span><br></pre></td></tr></table></figure></div><p>从中我们可以看到，数据总是成对出现的，包括 <strong>UID 映射字符串</strong> 和 <strong>字符串映射 UID</strong>。上面 5 组是 <strong>UID</strong> 映射成字符串，下面 5 组是字符串映射为 <strong>UID</strong>. 前面已经看过 <strong>tsdb-uid</strong> 表有两个列族，而其中的 <code>name</code> 列族对应的就是 <strong>UID</strong> 映射成字符串，而 <code>id</code> 列族对应字符串映射为 <strong>UID</strong>, 这正是这两个列族的作用，这样对于正反查找速度都是极快的。</p><p>此外，对于 <strong>UID 映射字符串</strong>的，每行数据，也就是 <code>rowkey</code> 相同的，至少包含三个列，分别是 <code>metrics</code>, <code>tagk</code>, <code>tagv</code>. 我们可以通过前三行结果看出。</p><p>到这里我们知道了 <strong>UID</strong> 与字符串间是怎么映射以便于查询的，但是 <strong>UID</strong> 到底是怎么生成的呢？</p><p>实际上大家在前面操作 <code>scan &#39;tsdb-uid&#39;</code> 的时候，结果会列出额外三行以 <code>\x00</code> 开头的数据：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ROW                                      COLUMN+CELL </span><br><span class="line">\x00    column=id:metrics, timestamp=1528517476737, value=\x00\x00\x00\x00\x00\x00\x00\x01                                  </span><br><span class="line">\x00    column=id:tagk, timestamp=1528517476811, value=\x00\x00\x00\x00\x00\x00\x00\x02                                      </span><br><span class="line">\x00    column=id:tagv, timestamp=1528517476825, value=\x00\x00\x00\x00\x00\x00\x00\x02</span><br></pre></td></tr></table></figure></div><p>实际上 <strong>UID</strong> 是用 <strong>3 bytes</strong> 表示的非负整型数，并且是自增的，而自增的就要依赖于上一次插入的最新 <code>ID</code> 值，这三行就是分别保存 <em>metrics</em>, <em>tagk</em>, <em>tagv</em> 插入的最新数据的 <strong>UID</strong>，这样下次插入新的数据只要在对应的值上加 1 就能得到其对应的 <strong>UID</strong> 了。</p><h2 id="Data-Table-Schema"><a href="#Data-Table-Schema" class="headerlink" title="Data Table Schema"></a>Data Table Schema</h2><p>我们再看看 OpenTSDB 的实际存储时序数据的表 – <strong>tsdb</strong>。</p><p>既然 <strong>UID</strong> 与字符串的映射关系搞定了，那么真实的时序数据存储就好理解了。<em>tsdb</em> 保存了所有的时序数据，其 <code>rowkey</code> 就是由各个字段对应的 <strong>UID</strong> 组成的。</p><p>先查看下 <em>tsdb</em> 数据库结果：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scan <span class="string">'tsdb'</span></span><br><span class="line"><span class="comment"># == 结果如下 ==</span></span><br><span class="line">ROW                COLUMN+CELL </span><br><span class="line">\x00\x00\x01[\x1Fa`\x00\x00\x01\x00\x00\x01\x00\x00\x02\x00\x00\x02 column=t:I\x00, timestamp=1528521000278, value=\x0A</span><br></pre></td></tr></table></figure></div><p>结果值太长了，可以分开看，先看列族里的数据【18.7.10 更正为】:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column=t:I\x00, timestamp=1528521000278, value=\x0A</span><br></pre></td></tr></table></figure></div><p>其中 <code>value=\x0A</code> 而 <code>0X0A</code> 化为十进制就是 <strong>10</strong>, 正好是我们前面上传的 <code>metric</code> 的值。</p><p>再看看 <strong>rowkey</strong>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x00\x00\x01[\x1Fa`\x00\x00\x01\x00\x00\x01\x00\x00\x02\x00\x00\x02</span><br></pre></td></tr></table></figure></div><p><code>rowkey</code> 是 <code>OpenTSDB</code> 设计的独特之处，其构成规则为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[salt]&lt;metric_uid&gt;&lt;timestamp&gt;&lt;tagk1&gt;&lt;tagv1&gt;[...&lt;tagkN&gt;&lt;tagvN&gt;]</span><br></pre></td></tr></table></figure></div><p><code>salt</code> 是为了更好的分布式，</p><p>我们的上面添加的 <code>metric</code> 为，其中 <code>tagk</code> 会自动按字母排序，所以 <em>area</em> 排在前面：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 字符串对应</span><br><span class="line">sys.test.metric 1528784369 area shanghai hostname jiyiren</span><br><span class="line"># UID 对应 ( timestamp 先不变 )</span><br><span class="line">000001 1528784369 000001 000001 000002 000002</span><br></pre></td></tr></table></figure></div><p>除了 <em>timestamp</em> 和上面结果完全对应，而 <em>timestamp</em> 则是按小时存储的，也就是取 <strong>3600</strong> 的整数倍的 <em>timestamp</em> 作为当前时间戳。计算方法 <em>timestamp - timestamp % 3600</em>.</p><p>这样，我们应该对 <strong>OpenTSDB</strong> 的 <strong>UID</strong> 以及 <strong>Rowkey</strong> 的生成和存储结构都基本了解了。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="http://opentsdb.net/docs/build/html/index.html" target="_blank" rel="noopener">http://opentsdb.net/docs/build/html/index.html</a></li><li><a href="http://liubin.org/blog/2016/03/05/tsdb-opentsdb/" target="_blank" rel="noopener">http://liubin.org/blog/2016/03/05/tsdb-opentsdb/</a></li><li><a href="https://www.jianshu.com/p/0bafd0168647" target="_blank" rel="noopener">https://www.jianshu.com/p/0bafd0168647</a></li><li><a href="http://www.nosqlnotes.com/technotes/opentsdb-tabledesign/" target="_blank" rel="noopener">http://www.nosqlnotes.com/technotes/opentsdb-tabledesign/</a></li></ul><p>img.godjiyi.cn</p>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot; style=&quot;margin: 30px 0 35px;&quot;&gt;时序处理数据库，更快的存储和聚合&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OpenTSDB&lt;/strong&gt; 是为存储时序数据而设计的，它基于 &lt;strong&gt;HBase&lt;/strong&gt; 存储数据，充分发挥了 &lt;strong&gt;HBase&lt;/strong&gt; 的分布式列存储特性，支持数百万每秒的读写，支持千万数目的 &lt;strong&gt;Metric&lt;/strong&gt;，它的特点就是容易扩展，具有灵活的 &lt;em&gt;Tag&lt;/em&gt; 机制。其主要用途，就是做监控系统，譬如收集大规模集群（ 包括网络设备、操作系统、应用程序 ）的 &lt;strong&gt;监控数据&lt;/strong&gt; 并进行存储和聚合查询，在目前的 &lt;strong&gt;IoT&lt;/strong&gt; 方面具有很大的应用价值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="NoSQL" scheme="https://www.godjiyi.cn/categories/NoSQL/"/>
    
    
      <category term="Metric" scheme="https://www.godjiyi.cn/tags/Metric/"/>
    
      <category term="OpenTSDB" scheme="https://www.godjiyi.cn/tags/OpenTSDB/"/>
    
  </entry>
  
  <entry>
    <title>时序数据介绍</title>
    <link href="https://www.godjiyi.cn/2018/06/22/time-sequence/"/>
    <id>https://www.godjiyi.cn/2018/06/22/time-sequence/</id>
    <published>2018-06-22T06:00:40.000Z</published>
    <updated>2018-06-22T11:28:50.750Z</updated>
    
    <content type="html"><![CDATA[<p align="center" style="margin: 30px 0 35px;">基于时间序列，实现数据聚合</p><p><strong>时序数据</strong> 就是基于时间序列的数据，其常常表现为同一指标按时间序列记录的数据列，在需求实时性的场景中比较常见。而对于此种数据的运用通常使用基本的 <strong>聚合</strong> 方式就能达到需求了。当然，目前 <code>AI</code> 盛行的时代，机器学习领域也不断出现很多基于 <strong>时序预测</strong> 的算法。但本文主要介绍时序数据的基础认识，这部分的认知主要是从自己目前所做的数据监控项目的经验所得，若有不正确，请大家批评指正。</p><h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2><p><strong>时序数据</strong> 和一般的数据没什么区别的，基本上也都用 <strong>json</strong> 格式表示，唯一不同点就是数据中一定包含关于 <strong>时间</strong> 的信息，比如： <strong>时间戳</strong>。</p><p>一般一条时序数据只表示一个键值信息，而在时序数据中，这个键常常称为 <strong>指标</strong> 或 <strong>指标名</strong> (英: <em>metric</em> )，而值则就是指标对应的值了。因而，一个时序数据的基本格式如下：</p><a id="more"></a><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "timestamp": 1346846400,    // 时间戳</span><br><span class="line">  "metric": "sys.mem.bytes",  // 指标名</span><br><span class="line">  "value": 18  // 指标值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要包含了 <strong>时间戳、指标名、指标值</strong>。其中，对于指标的值，也就是上面的 <strong>value</strong> 字段值，这个值一般都是 <strong>数值型</strong> ( <em>Integer、Float、Double</em> ) 的, 为什么大多是 <strong>数值型</strong> 的呢？这个下面会进行说明。</p><p>到这里，我们已经知道了一个时序数据的基本格式。但是，难道时序数据就是一个格式吗？即使加入了时间信息，那也和普通的 <strong>json</strong> 数据也没什么本质区别呀？</p><h2 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h2><p>的确，时序数据的存在可不是因为一个数据格式，而是由于 <strong>数据聚合</strong> 应用的需求而出现的。比如，我们现在有 1 台服务器，我想快速地知道今天上午 10 点到上午 12 点之间这台服务器的 <strong>内存</strong> 使用的 <em>平均值、最高值、最小值</em>，那我们怎么办？其中，这个指标可能也会是 <strong>CPU</strong>、<strong>磁盘 IO</strong> 等其他指标。</p><p>这里我们可以看出像 <em>平均值、最高值、最小值</em> 等等功能对于 <strong>metric</strong> 是通用的，因此，我们只需要将各种需求功能设计成通用的 <strong>聚合函数</strong>，那么我们需要看哪种指标的 <em>平均、最高、最小</em> 等聚合值时，只要选择对应的函数即可了。</p><p>这实际上也就是为什么 <strong>value</strong> 字段大多是 <strong>数值型</strong> 的原因，因为聚合函数绝大部分只是一些常规的 <strong>数学计算</strong>，数值型是最好处理的类型。当然这不是绝对的，只要你的后台明白如何处理对应的值类型即可了。</p><p>然而，上面举例是 1 台服务器，那我们如果有 2 或多台服务器，比如叫 hostA，hostB，host… 。 那么，我们直接对内存指标进行聚合那会计算到两台机器的聚合值，这个不是我们想要的，我们需要能对特定的主机进行聚合的能力，那该如何做？</p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>这时就用到了 <strong>标签</strong> 功能，一个标签就是一个 <strong>键值对</strong>，通常标签是作为后台的过滤条件的，而由于过滤条件的多样化也需要标签的多样化，因此一个时序数据中可以包含多个标签的。从而我们需要在基本的时序数据格式中再添加一种 <strong>键名</strong>，即 <em>标签组</em> – <em>tags</em>，如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "timestamp": 1346846400,    // 时间戳</span><br><span class="line">  "metric": "sys.mem.bytes",  // 指标名</span><br><span class="line">  "value": 18,  // 指标值</span><br><span class="line">  "tags":&#123;                    // 标签组</span><br><span class="line">    "host.name": "hostA",</span><br><span class="line">    "address": "shanghai"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样表示的时序数据更具有通用化、个性化、定制化的能力，从而我们可以先进行指标、标签的过滤后再进行相应的 <strong>聚合操作</strong>，这样就能更满足多样化的业务需求。而上面多台服务器的情况，则需要在上传数据时加入 <code>host.name</code> 值, 这样后台可根据该字段检索 <code>host.name = hostA</code> 也就是 A 主机的指标，然后对特定指标进行聚合即可。</p><h2 id="总结说明"><a href="#总结说明" class="headerlink" title="总结说明"></a>总结说明</h2><p>时序数据的需求通常是出现在 <strong>随着时间的推移某个指标值变化关系到业务运转</strong> 的情况下，因此我们就需要 <strong>间隔性地上传那个指标的数据</strong> 以实时地知道其状态值以应对突发情况，这个实际上就是一种 <strong>数据监控</strong> 场景。这里的 <strong>监控</strong> 可不是我们平常的视频监控，而是 <em>指标的检测与上报</em>，比如我们用 <strong>脚本</strong> 实时检测网站服务器的内存指标状态、CPU 状态、磁盘 IO 状态并上传到统一的后台，这个传输过程的数据格式就是使用时序数据，这样后台只需通过简单的 <strong>聚合功能</strong> 就能够对服务器的运行状态 <em>了如指掌</em> 了。</p><p>目前，时序数据应用最为广泛的也就是上面提到的 <em>实时检测服务器主机指标</em> 状态信息了，比如：阿里云、腾讯云等这些公有云服务提供商，当你购买一台服务器后，你在后台是可以看到一些服务器的性能指标的，这些指标信息就是实时监控主机并以 <strong>时序数据</strong> 格式传输出来的。</p><p>明白了上面的时序格式和应用方式，我们可以反过来想下，实际上时序数据的出现主要是由于 <strong>我们很想知道一段时间内一些指标信息的聚合结果</strong> 而产生的。为实现这种目的，我们不希望重复实现聚合功能，因此只需要实现一次可复用的聚合函数即可，这就产生了通用的 <strong>聚合函数</strong>。这相应地要求一条时序数据只包含一条 <strong>指标信息</strong> 以实现简单统一、包含一组 <strong>标签信息</strong> 以便实现筛选过滤。</p><p>因此，时序数据和其他一切业务名词一样，也<strong>都是由大量的实际需求逐渐演变成的统一化、规格化的结果！</strong>都是历史的选择！</p>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot; style=&quot;margin: 30px 0 35px;&quot;&gt;基于时间序列，实现数据聚合&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;时序数据&lt;/strong&gt; 就是基于时间序列的数据，其常常表现为同一指标按时间序列记录的数据列，在需求实时性的场景中比较常见。而对于此种数据的运用通常使用基本的 &lt;strong&gt;聚合&lt;/strong&gt; 方式就能达到需求了。当然，目前 &lt;code&gt;AI&lt;/code&gt; 盛行的时代，机器学习领域也不断出现很多基于 &lt;strong&gt;时序预测&lt;/strong&gt; 的算法。但本文主要介绍时序数据的基础认识，这部分的认知主要是从自己目前所做的数据监控项目的经验所得，若有不正确，请大家批评指正。&lt;/p&gt;
&lt;h2 id=&quot;基本格式&quot;&gt;&lt;a href=&quot;#基本格式&quot; class=&quot;headerlink&quot; title=&quot;基本格式&quot;&gt;&lt;/a&gt;基本格式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;时序数据&lt;/strong&gt; 和一般的数据没什么区别的，基本上也都用 &lt;strong&gt;json&lt;/strong&gt; 格式表示，唯一不同点就是数据中一定包含关于 &lt;strong&gt;时间&lt;/strong&gt; 的信息，比如： &lt;strong&gt;时间戳&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一般一条时序数据只表示一个键值信息，而在时序数据中，这个键常常称为 &lt;strong&gt;指标&lt;/strong&gt; 或 &lt;strong&gt;指标名&lt;/strong&gt; (英: &lt;em&gt;metric&lt;/em&gt; )，而值则就是指标对应的值了。因而，一个时序数据的基本格式如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Metric" scheme="https://www.godjiyi.cn/categories/Metric/"/>
    
    
      <category term="Metric" scheme="https://www.godjiyi.cn/tags/Metric/"/>
    
      <category term="Timing Data" scheme="https://www.godjiyi.cn/tags/Timing-Data/"/>
    
  </entry>
  
  <entry>
    <title>Java 优雅地退出程序</title>
    <link href="https://www.godjiyi.cn/2018/06/18/jvm-exit/"/>
    <id>https://www.godjiyi.cn/2018/06/18/jvm-exit/</id>
    <published>2018-06-18T06:00:40.000Z</published>
    <updated>2018-09-18T12:34:09.670Z</updated>
    
    <content type="html"><![CDATA[<p align="center" style="margin: 30px 0 35px;">show me code? No, show me elegant code!</p><p>很多情况下，我们的程序需要在操作系统 <strong>后台</strong> 一直运行，这在程序代码里的实现就是用死循环 ( <code>while (true)</code> ) 来实现的。但是，这样会出现一个问题，就是我们想要关闭程序怎么办？如果用暴力结束进程方式，那程序的内存中若还有未输出的数据，这部分数据将会遗失。因此，我们要对程序实现 <em>退出收尾</em> 操作，这就需要我们完善我们的程序，实现 <strong>“优雅”</strong> 地退出。</p><h2 id="后台进程"><a href="#后台进程" class="headerlink" title="后台进程"></a>后台进程</h2><p>首先，我们需要知道什么是后台进程。众所周知，我们与服务器进行交互都需要通过终端进行实现，而在终端上执行的程序都会默认将输出打印在终端界面里，而这中方式就 <strong>交互式进程</strong>，并且当前终端只能运行一个交互进程的，所以如果我们想在一个终端里运行多个任务，我们就需要将某些进程丢到 <strong>后台</strong> ，而这些进程不影响当前终端的交互执行，就被称为 <strong>“后台进程”</strong>。</p><p>所有的 <strong>交互式进程</strong> 都是可以转为 <strong>后台进程</strong> 的，因为进程的操作任务是一定的，只不过是它们的显示方式不同罢了，通常我们在一个终端里在任务后面加上 <em>&amp;</em> 操作符就可以让交互式进程变为后台执行进程了。如：</p><a id="more"></a><p><strong>前台进程</strong>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/jiyiren/linuxfile</span><br></pre></td></tr></table></figure></div><p>如果按 <code>ctrl + c</code> 将会结束 <em>clone</em> 操作。</p><p>转为 <strong>后台进程</strong>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/jiyiren/linuxfile &amp;</span><br><span class="line">[1] 70235</span><br></pre></td></tr></table></figure></div><p>我们可以看到此时该命令输出一个编号 <em>70235</em>，这个就是后台 <em>job</em> 的 ID，此时你按 <em>ctrl + c</em> 并不会结束改任务。如果要 <strong>查看 job 列表</strong>，可以使用 <code>jobs -l</code>, 如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobs</span> -l</span><br><span class="line">[1]+ 70235 运行中               git <span class="built_in">clone</span> https://gitee.com/jiyiren/linuxfile &amp;</span><br></pre></td></tr></table></figure></div><p>可以看到该任务在运行中，此时若想将该任务再 <strong>调到前台</strong>，可以使用 <code>fg % jobid</code> ( 注意百分号前后都有空格 ), 如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fg</span> % 70235</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/jiyiren/linuxfile</span><br><span class="line">remote: Total 15 (delta 3), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (15/15), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure></div><p>此时，显示的就是正在进程的任务，如果此时按 <code>ctrl + c</code> 则将取消 <em>clone</em> 操作。</p><p>上面是基本的 Linux 前后台任务转换命令，我们可以看到我们结束进程都是将任务调到前台，然后用 <code>ctrl + c</code>, 来结束进程的。然而，将任务从后台调到前台的方式只能在同一个终端里操作的，如果用户在将任务掉入后台后关闭了终端窗口，那么该任务是永远无法通过 <code>fg % jobid</code> 调到前台了。这时如果要结束该进程怎么办？</p><h2 id="KILL-命令"><a href="#KILL-命令" class="headerlink" title="KILL 命令"></a>KILL 命令</h2><hr><p>还好我们有终极杀器 – <code>kill</code> 命令，但 <code>kill</code> 命令操作的是 <strong>进程 ID</strong> 而非 <strong>job ID</strong>。也就是说 <strong>job ID</strong> 只能是同一个终端下的操作，相当于终端局域性的，而脱离了该终端后，该局域的 <strong>job ID</strong> 就不再有效。而 <strong>进程 ID</strong> 则是全局性的，任意终端都可以操作的，并且局域的 <strong>job ID</strong> 都会有与之对应的全局 <strong>进程 ID</strong> 的，因此如果关闭了那个 <strong>job ID</strong> 所在的终端，我们可以通过 <code>kill</code> <strong>job ID 对应的进程 ID</strong> 来结束此任务进程。</p><p>在我们平常的开发中，我们不可能一直维持着一个服务器的终端的，因此通过 <code>ctrl + c</code> 的方式结束 <strong>job ID</strong> 的方式对正式部署应用很不适合的，它只能适合个人的简单测试，因此 <code>kill</code> 命令方式才是 <em>统一而确实有效</em> 结束进程的方式。</p><p>假如，我们上面执行下面命令之后，就关闭掉了终端 ( 也不用管 <em>job ID</em> 了 )：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/jiyiren/linuxfile &amp;</span><br></pre></td></tr></table></figure></div><p>我们可以先通过 <code>ps</code> 命令来拿到我们的 <strong>进程 ID</strong>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep linuxfile | grep -v grep</span><br><span class="line">jiyi  70376  0.0  0.0 116676  1536 pts/1    S    01:06   0:00 git <span class="built_in">clone</span> https://gitee.com/jiyiren/linuxfile</span><br><span class="line">jiyi  70377  5.7  0.4 174908  7952 pts/1    S    01:06   0:01 git-remote-https origin https://gitee.com/jiyiren/linuxfile</span><br><span class="line">jiyi  70379  3.3  0.0 124632  1136 pts/1    Sl   01:06   0:00 git fetch-pack --stateless-rpc --stdin --lock-pack --thin https://gitee.com/jiyiren/linuxfile/</span><br></pre></td></tr></table></figure></div><p>上面第一个 <code>grep</code> 后面就是自己要搜索的进程中包含的 <strong>关键词</strong>，这个自己根据自己的命令选择命令中的关键词，这样便于更好地过滤。第二个 <code>grep</code> 则是去除本身这个查找命令的意思。</p><p>我们从上面命令结果可以看到有三个进程与此任务对应，其中第二列是 <strong>进程的 ID</strong>, 我们可以用下面命令杀死该任务的所有进程：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 70376 70377 70379</span><br></pre></td></tr></table></figure></div><p>这样在终端里通过 <code>jobs -l</code> 可以看到已经没有任务在运行了。</p><h2 id="KILL-信号"><a href="#KILL-信号" class="headerlink" title="KILL 信号"></a>KILL 信号</h2><hr><p>通过上面的叙述，我们知道 <code>kill</code> 命令的作用。那么，上面的结束进程的命令 <code>kill -9</code> 的 <em>9</em> 是什么意思呢？实际上 <code>kill -9</code> 是 <code>kill -s 9</code> 的缩写，<code>-s</code> 后面接信号名称或者信号序号。而 <em>9</em> 代表的信号名为 <strong>SIGKILL</strong>, 也就是说 <code>kill -9</code> 也可以写成 <code>kill -s SIGKILL</code>. 此外，如果用信号名，字符的大小写是不敏感的，因此大家也可以写成 <code>kill -s sigkill</code>. 最后，由于所有的信号名都是以 <strong>SIG</strong> 打头的，因此，通常在我们自己写的程序中都是去掉 <strong>SIG</strong> 作为信号名的，因此，此命令还可以写成 <code>kill -s kill</code>. 这里我整理出 信号 <strong>9</strong> 所有相同功能的命令操作：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 [PID]</span><br><span class="line"><span class="built_in">kill</span> -s 9 [PID]</span><br><span class="line"><span class="built_in">kill</span> -s SIGKILL [PID]</span><br><span class="line"><span class="built_in">kill</span> -s sigkill [PID]</span><br><span class="line"><span class="built_in">kill</span> -s KILL [PID]</span><br><span class="line"><span class="built_in">kill</span> -s <span class="built_in">kill</span> [PID]</span><br></pre></td></tr></table></figure></div><p>大家可以把 <strong>SIGKILL</strong> 这个信号换成其他的也适用，但由于信号名称有点长，不太好记，因此，通常我们在操作命令的时候使用序号来执行 <code>kill</code> 命令。</p><p>那我们怎么知道有哪些信号？以及这些信号对应的序号呢？实际上 <code>kill</code> 命令还有一个参数 <code>-l</code>, 可以列出所有支持的 <strong>信号序号</strong> 以及 <strong>信号名</strong>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL10) SIGUSR1</span><br><span class="line">11) SIGSEGV12) SIGUSR213) SIGPIPE14) SIGALRM15) SIGTERM</span><br><span class="line">16) SIGSTKFLT17) SIGCHLD18) SIGCONT19) SIGSTOP20) SIGTSTP</span><br><span class="line">21) SIGTTIN22) SIGTTOU23) SIGURG24) SIGXCPU25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM27) SIGPROF28) SIGWINCH29) SIGIO30) SIGPWR</span><br><span class="line">31) SIGSYS34) SIGRTMIN35) SIGRTMIN+136) SIGRTMIN+237) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+439) SIGRTMIN+540) SIGRTMIN+641) SIGRTMIN+742) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+944) SIGRTMIN+1045) SIGRTMIN+1146) SIGRTMIN+1247) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+1449) SIGRTMIN+1550) SIGRTMAX-1451) SIGRTMAX-1352) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-1154) SIGRTMAX-1055) SIGRTMAX-956) SIGRTMAX-857) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-659) SIGRTMAX-560) SIGRTMAX-461) SIGRTMAX-362) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-164) SIGRTMAX</span><br></pre></td></tr></table></figure></div><p>大家也看到了，信号太多了，这里我挑选出最长用的信号进行说明：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">信号名 信号序号含义</span><br><span class="line">SIGHUP     1    终端断线</span><br><span class="line">SIGINT     2    中断（同 Ctrl + C）</span><br><span class="line">SIGQUIT    3    退出（同 Ctrl + \）</span><br><span class="line">SIGTERM   15    正常终止</span><br><span class="line">SIGKILL    9    强制终止</span><br><span class="line">SIGCONT   18    继续（与STOP相反， fg/bg命令）</span><br><span class="line">SIGSTOP   19    暂停（同 Ctrl + Z）</span><br><span class="line">SIGUSR1   10    用户自定义信号1</span><br><span class="line">SIGUSR2   12    用户自定义信号2</span><br></pre></td></tr></table></figure></div><p>这里我们只取其中的 <strong>结束进程的信号</strong> 来讲:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SIGINT     2    中断（同 Ctrl + C）</span><br><span class="line">SIGTERM   15    正常终止</span><br><span class="line">SIGKILL    9    强制终止</span><br></pre></td></tr></table></figure></div><p>其中大家经常使用的 <code>ctrl + c</code> 快捷键就是发送了 <strong>SIGINT(2)</strong> 信号给进程的。另外，整个信号中，最特殊的命令就是 <strong>SIGKILL(9)</strong>, 它代表 <em>无条件结束进程</em>，也就是通常说的强制结束进程，这种方式结束进程有可能会导致进程内存中 <strong>数据丢失</strong>。而另外两个信号对于进程来说是可以选择性忽略的，但目前的绝大部分的进程都是可以通过这三个信号进行结束的。</p><p>那这三个结束命令到底有啥区别？对比如下表：</p><table><thead><tr><th style="text-align:center">信号</th><th style="text-align:center">快捷键</th><th style="text-align:center">正常结束</th><th style="text-align:center">无条件结束</th><th style="text-align:center">应用场景</th></tr></thead><tbody><tr><td style="text-align:center">SIGINT(2)</td><td style="text-align:center">ctrl + c</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center"><strong>前台进程快捷终止</strong></td></tr><tr><td style="text-align:center">SIGTERM(15)</td><td style="text-align:center">无</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center"><strong>后台进程正常终止</strong></td></tr><tr><td style="text-align:center">SIGKILL(9)</td><td style="text-align:center">无</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center"><strong>后台进程强制终止</strong></td></tr></tbody></table><p>大家主要关注下各个信号的 <strong>应用场景</strong> 即可。</p><p>然而，我们的上线程序绝大部分都是后台进程在跑的，本篇内容也是讨论后台进程，因此我们主要看 <strong>后台进程的正常结束</strong>( <em>SIGINT(2)、SIGTERM(15)</em> ) 与 <strong>后台进程的强制结束</strong> ( <em>SIGKILL(9)</em> ) 的区别。</p><h2 id="正常与强制结束方式"><a href="#正常与强制结束方式" class="headerlink" title="正常与强制结束方式"></a>正常与强制结束方式</h2><hr><p>本篇讨论 <strong>Java</strong> 程序的后台程序 <strong>正常</strong> 与 <strong>强制结束</strong> 方式对比。在 Java 中，强制结束代表 <strong>直接立即结束</strong> 进程中的 <em>Main</em> 线程和其他所有线程，这里强调 <strong>直接和立即</strong>，也就是说通过强制方式，进程不会做任何收尾工作。而 <strong>正常结束</strong> 则非立即结束进程，而是先调用程序的 <strong>收尾线程</strong>，等收尾线程结束后再结束所有线程。</p><p>这里出现了 <strong>收尾线程</strong>，实际上这个就是 Java 程序中通过 <code>Runtime.getRuntime().addShutdownHook()</code> 方式注册的线程就是收尾线程。为了更详细地说明正常结束与强制结束的区别我们先定义一个工作线程 <code>JobThread</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工作线程，每秒钟输出一个递增的数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Work Thread: "</span> + count++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>另外我们再定义一个收尾线程 <code>ShudownHookThread</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收尾线程，没 0.5 秒输出一个递减的数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShudownHookThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Shutdown Thread: "</span>+count--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>现在在 Main 函数中先注册收尾线程，然后再启动工作线程：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> ShudownHookThread());</span><br><span class="line">        JobThread jobThread = <span class="keyword">new</span> JobThread();</span><br><span class="line">        jobThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然后打包成 Jar 包 ( 假设名字为 jvmexit-example.jar )，我们通过下面命令启动程序:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java -jar jvmexit-example.jar</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure></div><p>我们可以看到工作线程每隔 <strong>1</strong> 秒输出一个数字，此时如果我们来通过正常和强制执行看看他们相应的输出。</p><p>正常结束 <code>kill -2 [PID]</code> 或者 <code>kill -15 [PID]</code>：</p><p><img src="http://img.godjiyi.cn/csdnblogjvmexit01.jpg" alt></p><p>强制结束 <code>kill -9 [PID]</code> :</p><p><img src="http://img.godjiyi.cn/csdnblogjvmexit02.jpg" alt></p><p>从中我们可以看出 <strong>正常结束</strong> 方式，会 <em>先调用收尾线程</em>，然后再结束，而 <strong>强制结束</strong> 则直接 <em>杀死所有线程</em>。因此，这里给出优雅结束进程说明：</p><ul><li>先定义自己的 <strong>收尾线程</strong> 要完成的任务，比如：清理内存，将未完成的 IO 操作完成，删除缓存文件等等；</li><li><em>Main</em> 函数里，在主任务启动之前注册 <strong>收尾线程</strong> 即可完成收尾任务的注册；</li><li>使用 <code>kill</code> 的 <strong>SIGIN(2)</strong> 和 <strong>SIGTERM(15)</strong> 两个信号进行进程结束，则 <strong>收尾线程</strong> 会被调用；</li></ul><h2 id="自定义-kill-信号处理"><a href="#自定义-kill-信号处理" class="headerlink" title="自定义 kill 信号处理"></a>自定义 kill 信号处理</h2><hr><p>我们前面也讲过，除了信号 <strong>SIGKILL(9)</strong> 外，其他信号对于进程来说都是可忽略的。而这个忽略就是自己在自己的任务进程里实现这些信号的监听。</p><p>Java 中有提供一个接口 <code>SignalHandler</code>，完整名 <code>sun.misc.SignalHandler</code>，我们只要实现该接口，就可以在接收到信号后进行一些相应处理了。</p><p>我们定义类 <code>SignalHandlerImp</code> 其实现接口 <code>SignalHandler</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignalHandlerImp</span> <span class="keyword">implements</span> <span class="title">SignalHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Signal signal)</span> </span>&#123;</span><br><span class="line">        System.out.println(signal.getName()+<span class="string">":"</span>+signal.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>类内部只有一个要实现的方法 <code>public void handle(Signal signal)</code>, 而我们在方法里仅仅是打印了信号的名称和序号。然后在 <em>Main</em> 函数里注册一下</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册要监听的信号</span></span><br><span class="line">        SignalHandlerImp signalHandlerImp = <span class="keyword">new</span> SignalHandlerImp();</span><br><span class="line">        Signal.handle(<span class="keyword">new</span> Signal(<span class="string">"INT"</span>), signalHandlerImp);     <span class="comment">// 2  : 中断（同 ctrl + c ）</span></span><br><span class="line">        Signal.handle(<span class="keyword">new</span> Signal(<span class="string">"TERM"</span>), signalHandlerImp);    <span class="comment">// 15 : 正常终止</span></span><br><span class="line">        Signal.handle(<span class="keyword">new</span> Signal(<span class="string">"USR2"</span>), signalHandlerImp);    <span class="comment">// 12 : 用户自定义信号</span></span><br><span class="line">        </span><br><span class="line">        JobThread jobThread = <span class="keyword">new</span> JobThread();</span><br><span class="line">        jobThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>主函数里我们监听了三个信号：<strong>SIGINT(2)</strong>, <strong>SIGTERM(15)</strong>, <strong>SIGUSR2(12)</strong>, 同时我们也用到了上一节使用的工作线程 <code>JobThread</code> ( 注意这里没有用到上节的扫尾进程 ), 让我们来重新打包并启动任务 。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java -jar jvmexit-example.jar</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure></div><p>执行结果是一样的，每秒输出一个数字，那我们来分别执行:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// pid 换成自己的进程 ID</span><br><span class="line">kill -2 [PID]</span><br><span class="line">kill -15 [PID]</span><br><span class="line">kill -12 [PID]</span><br><span class="line">kill -9 [PID]</span><br></pre></td></tr></table></figure></div><p>得到的结果如下：</p><p><img src="http://img.godjiyi.cn/csdnblogjvmexit03.jpg" alt></p><p>从中我们可以看出自定义的信号处理方式，<strong>正常结束的信号</strong> ( <strong>SIGINT(2)</strong> 和 <strong>SIGTERM(15)</strong> ) 都不会结束进程，而只是执行自己自定义的方法，然而 <strong>强制结束信号</strong> ( <strong>SIGKILL(9)</strong> ) 则不会被自定义监控，大家自己可以尝试下在 <em>Main</em> 函数中注册 <em>KILL</em> 信号，如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Signal.handle(<span class="keyword">new</span> Signal(<span class="string">"KILL"</span>), signalHandlerImp);    <span class="comment">// 9 : 强制终止</span></span><br></pre></td></tr></table></figure></div><p>这个在运行的时候就会报错，因此 <strong>SIGKILL(9)</strong> 信号是唯一不能够被自定义的信号。</p><p>那既然我们自己可以自定义信号，那我们通过自定义的信号来处理我们的收尾操作也是可行的。因此我们只要在 <code>SignalHandler</code> 接口的实现类中 <code>handle</code> 方法中处理自己的收尾操作就可以了。这里也整理下自定义信号处理进行收尾的说明：</p><ul><li>实现 <code>SignalHandler</code> 接口，在 <code>handle</code> 方法中实现自己的收尾操作；</li><li><em>Main</em> 函数里，在主任务启动之前注册 <strong>自定义信号名</strong> 即可完成收尾任务的注册，只需要注册一个就行了；</li><li>使用 <code>kill</code> 的 对应 <strong>自定义信号名</strong> 进行任务进程的结束，就可以正常收尾了。</li></ul><p>另外，在实际操作中使用自定义信号的方式通常是直接让 <strong>工作线程</strong> 实现 <code>SignalHandler</code> 接口的，我们上面是为了举例，以不至于发送对应信号后进程就停止了，而实际情况下是需要我们发送信号工作线程就应该停止，因此可以将上面的工作线程修改如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工作线程，每秒钟输出一个递增的数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">SignalHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isStop = fals;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!isStop) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Work Thread: "</span> + count++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Signal signal)</span> </span>&#123;</span><br><span class="line">      isStop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// do other something;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如上所示，加一个运行 <em>标识</em>，并在收到信号后进行 <em>标识</em> 的反赋值，这样工作线程就会自动停止，当然还可以进行其他相关操作。</p><h2 id="两种方式对比"><a href="#两种方式对比" class="headerlink" title="两种方式对比"></a>两种方式对比</h2><hr><p>本文接收两种优雅 ( 而非暴力 <code>kill -9</code> ) 结束进程方式：</p><ol><li>采用默认信号处理机制，通过 <code>Runtime.getRuntime().addShutdownHook(new ShudownHookThread());</code> 实现收尾进程的注册，这样在收到默认正常结束信号 ( <strong>SIGINT(2)</strong> 和 <strong>SIGTERM(15)</strong> ) 就可优雅退出；</li><li>采用自定义信号处理机制，通过 <code>Signal.handle(new Signal(&quot;USR2&quot;), new SignalHandlerImp());</code> 注册 <strong>自定义信号</strong> 以及 <strong>信号处理实现类</strong>，这样使用 <strong>kill -自定义信号 ( 如： SIGUSR2(12) ) [PID]</strong> 就可以达到收尾操作在 <strong>信号处理实现类</strong> 里实现，从而也可实现优雅退出。</li></ol><p>那这两种方式哪个更好点？或者说适应性更广泛一点？</p><p>这里我参考了 <a href="https://tech.imdada.cn/2017/06/18/jvm-safe-exit/" target="_blank" rel="noopener">JVM 安全退出</a> 这篇文章，它给出了 JVM 关闭的不止有 <strong>正常关闭</strong>、<strong>强制关闭</strong> 还有一种 <strong>异常关闭</strong> 如下图：</p><p><img src="http://img.godjiyi.cn/csdnblogjvmexit04.bmp" alt></p><p>这种方式还是会调用以 <code>Runtime.getRuntime().addShutdownHook(new ShudownHookThread());</code> 此方法注册的 <strong>收尾线程</strong> 的，而不会触发自定义的信号通信的。因此，还是第一种默认信号处理机制，通过 <strong>Hook</strong> 线程方式适应性更广泛。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://tech.imdada.cn/2017/06/18/jvm-safe-exit/" target="_blank" rel="noopener">JVM 安全退出</a></li><li><a href="https://blog.csdn.net/moonpure/article/details/80404390" target="_blank" rel="noopener">Java 程序优雅关闭的两种方法</a></li><li><a href="http://man.linuxde.net/kill" target="_blank" rel="noopener">kill 命令</a></li><li><a href="https://blog.csdn.net/dd864140130/article/details/49155179" target="_blank" rel="noopener">深入 JVM 关闭与关闭钩子</a></li><li><a href="http://www.baiyuxiong.com/?p=1002" target="_blank" rel="noopener">Java 通过 kill 命令关闭程序 DEMO 示例</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot; style=&quot;margin: 30px 0 35px;&quot;&gt;show me code? No, show me elegant code!&lt;/p&gt;

&lt;p&gt;很多情况下，我们的程序需要在操作系统 &lt;strong&gt;后台&lt;/strong&gt; 一直运行，这在程序代码里的实现就是用死循环 ( &lt;code&gt;while (true)&lt;/code&gt; ) 来实现的。但是，这样会出现一个问题，就是我们想要关闭程序怎么办？如果用暴力结束进程方式，那程序的内存中若还有未输出的数据，这部分数据将会遗失。因此，我们要对程序实现 &lt;em&gt;退出收尾&lt;/em&gt; 操作，这就需要我们完善我们的程序，实现 &lt;strong&gt;“优雅”&lt;/strong&gt; 地退出。&lt;/p&gt;
&lt;h2 id=&quot;后台进程&quot;&gt;&lt;a href=&quot;#后台进程&quot; class=&quot;headerlink&quot; title=&quot;后台进程&quot;&gt;&lt;/a&gt;后台进程&lt;/h2&gt;&lt;p&gt;首先，我们需要知道什么是后台进程。众所周知，我们与服务器进行交互都需要通过终端进行实现，而在终端上执行的程序都会默认将输出打印在终端界面里，而这中方式就 &lt;strong&gt;交互式进程&lt;/strong&gt;，并且当前终端只能运行一个交互进程的，所以如果我们想在一个终端里运行多个任务，我们就需要将某些进程丢到 &lt;strong&gt;后台&lt;/strong&gt; ，而这些进程不影响当前终端的交互执行，就被称为 &lt;strong&gt;“后台进程”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所有的 &lt;strong&gt;交互式进程&lt;/strong&gt; 都是可以转为 &lt;strong&gt;后台进程&lt;/strong&gt; 的，因为进程的操作任务是一定的，只不过是它们的显示方式不同罢了，通常我们在一个终端里在任务后面加上 &lt;em&gt;&amp;amp;&lt;/em&gt; 操作符就可以让交互式进程变为后台执行进程了。如：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.godjiyi.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.godjiyi.cn/tags/Java/"/>
    
      <category term="JVM" scheme="https://www.godjiyi.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 日志工具介绍</title>
    <link href="https://www.godjiyi.cn/2018/06/16/java-log/"/>
    <id>https://www.godjiyi.cn/2018/06/16/java-log/</id>
    <published>2018-06-16T06:00:40.000Z</published>
    <updated>2018-09-18T12:34:18.590Z</updated>
    
    <content type="html"><![CDATA[<p align="center" style="margin: 30px 0 35px;">容易被忽略的数据生产源</p><p>目前，随着大数据方向的推进，越来越多的数据被应用于数据分析和挖掘，而其中一大部分就是项目中的 <strong>日志数据</strong>。而 <strong>Java</strong> 项目中有很多的日志输出包，不同项目使用不同的日志工具会造成数据结构的不一致，这样就为 <strong>数据分析</strong> 增添了一定的麻烦，今天记录下对各中日志工具的说明。</p><h2 id="日志组件历史"><a href="#日志组件历史" class="headerlink" title="日志组件历史"></a>日志组件历史</h2><hr><h3 id="JUL"><a href="#JUL" class="headerlink" title="JUL"></a>JUL</h3><p>这个是 <strong>java.util.logging</strong> 的缩写，也就是 Java 本身 JDK 自带的日志工具，但是通常它的功能有限，因此，项目中的日志输出都是采用特有的日志工具进行记录。而日志工具中得到广泛使用的就是 <strong>log4j</strong>.</p><h3 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h3><p><strong>Java</strong> 界里有许多实现日志功能的工具，最早得到广泛使用的是 <strong>log4j</strong>, 许多应用程序的日志部分都交给了 <strong>log4j</strong>, 不过作为组件开发者，他们希望自己的组件不要紧紧依赖某一个工具，毕竟在同一个时候还有很多其他很多日志工具，假如一个应用程序用到了两个组件，恰好两个组件使用不同的日志工具，那么应用程序就会有两份日志输出了。</p><a id="more"></a><h3 id="JCL"><a href="#JCL" class="headerlink" title="JCL"></a>JCL</h3><p>为了解决这个问题，<strong>Apache Commons Logging</strong> （ 之前叫 <em>Jakarta Commons Logging</em>, 所以缩写为 <em>JCL</em> ）粉墨登场，<em>JCL</em> 只提供 <strong>log</strong> 接口，具体的实现则在运行时 <strong>动态寻找</strong>。这样一来组件开发者只需要针对 <em>JCL</em> 接口开发，而调用组件的应用程序则可以在运行时搭配自己喜好的日志实践工具。</p><p>所以即使到现在你仍会看到很多程序应用 <strong>JCL + log4j</strong> 这种搭配，不过当程序规模越来越庞大时，<em>JCL</em> 的 <strong>动态绑定</strong> 并不是总能成功，具体原因大家可以 Google 一下，这里就不再赘述了。解决方法之一就是在程序部署时 <strong>静态绑定</strong> 指定的日志工具，这就是 SLF4J 产生的原因。</p><h3 id="SLF4j"><a href="#SLF4j" class="headerlink" title="SLF4j"></a>SLF4j</h3><p>跟 <em>JCL</em> 一样，<strong>SLF4J</strong> 也是只提供 log 接口，具体的实现是在打包应用程序时所放入的绑定器（ 名字为 <code>slf4j-XXX-version.jar</code> ）来决定，<code>XXX</code> 可以是 <em>log4j12</em>,  <em>jdk14</em>, <em>jcl</em>, <em>nop</em> 等，他们实现了跟具体日志工具（ 比如 <em>log4j</em> ）的绑定及代理工作。举个例子：如果一个程序希望用 <em>log4j</em> 日志工具，那么程序只需针对 <strong>slf4j-api</strong> 接口编程，然后在打包时再放入 <strong>slf4j-log4j12-version.jar</strong> 和 <strong>log4j.jar</strong> 就可以了。</p><p>现在还有一个问题，假如你正在开发应用程序所调用的组件当中已经使用了 <em>JCL</em> 的，还有一些组建可能直接调用了 <em>java.util.logging</em>，这时你需要一个桥接器（ 名字为 <strong>XXX-over-slf4j.jar</strong> ）把他们的日志输出重定向到 <strong>SLF4J</strong>, 所谓的桥接器就是一个假的日志实现工具，比如当你把 <strong>jcl-over-slf4j.jar</strong> 放到 <strong>CLASS_PATH</strong> 时，即使某个组件原本是通过 <em>JCL</em> 输出日志的，现在却会被 <strong>jcl-over-slf4j</strong> <em>“骗到”</em> <strong>SLF4J</strong> 里，然后 <strong>SLF4J</strong> 又会根据绑定器把日志交给具体的日志实现工具。过程如下。</p><p>这时，你可能会发现一个有趣的问题，假如在 <strong>CLASS_PATH</strong> 里同时放置 <strong>log4j-over-slf4j.jar</strong> 和 <strong>slf4j-log4j12-version.jar</strong> 会发生什么情况呢？没错，日志会被踢来踢去，最终进入死循环。</p><h2 id="日志搭配组合"><a href="#日志搭配组合" class="headerlink" title="日志搭配组合"></a>日志搭配组合</h2><hr><p>日志工具那么多，有门面也有具体实现，那到底如何进行搭配呢？这里主要给出目前最流行的两种搭配：</p><h3 id="JCL-Log4j-搭配"><a href="#JCL-Log4j-搭配" class="headerlink" title="JCL + Log4j 搭配"></a>JCL + Log4j 搭配</h3><p>这种方式是采用 <strong>JCL</strong> 作为日志门面抽象接口，具体日志输出使用 <strong>Log4j</strong>. 具体用到的 Jar 包和资源文件如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. commons-logging-1.1.jar// JCL 日志门面</span><br><span class="line">2. log4j-1.2.15.jar// Log4j 具体日志输出</span><br><span class="line">3. log4j.properties// Log4j 的日志配置文件</span><br></pre></td></tr></table></figure></div><p>对于 <em>Log4j.properties</em> 如何配置，下面会讲到，这里给出常用日志定义代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意导入的包</span></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Log logger = LogFactory.getLog(A.class);</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">logger.debug(<span class="string">"This is debug"</span>);</span><br><span class="line"> logger.info(<span class="string">"This is info"</span>);</span><br><span class="line">logger.warn(<span class="string">"This is warn"</span>);</span><br><span class="line">logger.eror(<span class="string">"This is error"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="SLF4j-Log4j-搭配"><a href="#SLF4j-Log4j-搭配" class="headerlink" title="SLF4j + Log4j 搭配"></a>SLF4j + Log4j 搭配</h3><p>这种方式采用 SLF4j 作为日志门面抽象接口，具体日志输出仍然使用 <strong>Log4j</strong>. 具体用到的 Jar 包和资源文件如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. slf4j-api-1.5.11.jar</span><br><span class="line">2. slf4j-log4j12-1.5.11.jar// slf4j 桥接给 log4j</span><br><span class="line">3. log4j-1.2.15.jar</span><br><span class="line">4. log4j.properties</span><br></pre></td></tr></table></figure></div><p>我们可以看到除了各自的 API jar 包 还有一个 <strong>slf4j-log4j12-1.5.11.jar</strong>, 这个就是输出流重定向的意思，将 <strong>slf4j</strong> 接口输出转到具体的 <strong>log4j</strong> 实现。而假如你目前项目中已经用 <strong>JUL</strong> 实现日志输出了，你想用此种配置方式怎么办？那就再加一个 jar 包：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jul-to-slf4j-1.7.25.jar</span><br></pre></td></tr></table></figure></div><p>或者你已经使用了 <strong>JCL</strong> 日志门面接口，那如何转，只要加下面的 jar 包：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcl-over-slf4j-1.7.25.jar</span><br></pre></td></tr></table></figure></div><p>从中我们可以看出，<strong>slf4j</strong> 接口使用还是很广泛的，不管是入口还是出口都有各种对应的 jar 包可供使用的，那它可定制化以及适应性是非常广泛的，因此我推荐大家以后尽量使用 <strong>SLF4j</strong> 这个日志门面作为通用日志输出接口。</p><p>使用 <strong>SLF4j</strong> 的日志代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意导入的包和上面的 JCL 不一样的，不要混淆了</span></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;  </span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Logger logger= LoggerFactory.getLogger(A.class);</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">logger.debug(<span class="string">"This is debug"</span>);</span><br><span class="line"> logger.info(<span class="string">"This is info"</span>);</span><br><span class="line">logger.warn(<span class="string">"This is warn"</span>);</span><br><span class="line">logger.eror(<span class="string">"This is error: &#123;&#125;"</span>,<span class="string">"error stack string"</span>);</span><br><span class="line"><span class="comment">// error 的输出中 &#123;&#125; 是占位符，可以有多个，对应的后面字符串参数也应该多个</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里我们发现一个不同点，就是 <strong>SLF4j</strong> 可以用 <code>{}</code> 作为占位符，进行日志字符串的拼接操作，那这个有什么好处呢？这里也说明下：</p><p>首先看不用占位符是怎么使用多字符串拼接的：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">"This is debug: "</span> + <span class="string">"debug stack string"</span>);</span><br></pre></td></tr></table></figure></div><p>如上所示，完成了一个 <strong>debug</strong> 日志输出，很多人都是这样实现的，但是大家知道，我们上线的应用不能将 <strong>debug</strong> 日志输出的，因为 <strong>debug</strong> 只能在开发调试阶段使用。因此，我们需要配置我们的日志工具，使其只能输出 <em>info, warn, error</em> 的日志信息。那么，<code>logger.debug</code> 这句话内部就会自动判断是否要进行输出，当在内部判断后确实不需要输出！</p><p>但是，我们发现一个问题，就是参数字符串拼接都是要先执行的，也就是不管你内部要不要输出，字符串都是要先拼接好才能进入 <strong>logger</strong> 内部判断的。如果日志记录很少有加的字符串还没多少性能问题，但如果有很多字符串拼接操作，并且拼接很多个字符串，<strong>那么会白白地浪费这些字符串拼接过程的性能</strong>。因此，正确的做法是：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled())&#123;</span><br><span class="line">logger.debug(<span class="string">"This is debug: "</span> + <span class="string">"debug stack string"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>但是没次输出都要先进行判断是不是太过于重复了，因此，带占位符的字符串拼接操作就诞生了：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">"This is debug: &#123;&#125;"</span> , <span class="string">"debug stack string"</span>);</span><br></pre></td></tr></table></figure></div><p>这种方式多个字符串当做参数传入，不会先进行拼接再传入，而是在内部判断后再进行拼接操作，因此这也是 <strong>SLF4j</strong> 日志工具的一大优势。那下面就主要讲下 <strong>SLF4j</strong> 的配置参数。</p><h2 id="SLF4j-配置"><a href="#SLF4j-配置" class="headerlink" title="SLF4j 配置"></a>SLF4j 配置</h2><hr><p><strong>SLF4j</strong> 由于其适配广泛，通用性强，因此很多开源项目中都是使用它作为自己的日志记录接口，就如 <em>Hadoop</em> 系列生态。我们在开发 <em>Hadoop</em> 生态应用的时候，常常会在调试的时候打印出：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log4j:WARN No appenders could be found for logger (org.apache.hadoop.util.Shell).  </span><br><span class="line">log4j:WARN Please initialize the log4j system properly.  </span><br><span class="line">log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span><br></pre></td></tr></table></figure></div><p>这个就是因为没有配置 <strong>log4j.properties</strong> 所导致的。那通常的解决方法就是在项目路径里新建一个 <strong>log4j.properties</strong>, 然后填下面信息就可以了：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger=INFO, stdout, logfile</span><br><span class="line"></span><br><span class="line"># 标准输出流：输出到终端</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.Encoding=UTF-8</span><br><span class="line">log4j.appender.stdout.Threshold=DEBUG</span><br><span class="line">log4j.appender.stdout.ImmediateFlush=true</span><br><span class="line">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=[%p] %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c] %m%n</span><br><span class="line"></span><br><span class="line"># 文件输出流：输出到日志文件</span><br><span class="line">log4j.appender.logfile=org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.logfile.Threshold=INFO</span><br><span class="line">log4j.appender.logfile.Encoding=UTF-8</span><br><span class="line">log4j.appender.logfile.File=$&#123;user.dir&#125;/logs/mylog.log</span><br><span class="line">log4j.appender.logfile.Append=true</span><br><span class="line">log4j.appender.logfile.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.logfile.layout.ConversionPattern=[%p] %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c] %m%n</span><br></pre></td></tr></table></figure></div><p>那这些配置信息到底是什么意思？下面详细讲下。</p><h3 id="配置-RootLogger"><a href="#配置-RootLogger" class="headerlink" title="配置 RootLogger"></a>配置 RootLogger</h3><p>首先看第 <strong>1</strong> 行，也就是 <code>log4j.rootLogger</code> 的配置，其语法为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger = [ level ] , appenderName1, appenderName2, ...</span><br></pre></td></tr></table></figure></div><p>(1). <em>level</em> : 是日志记录的优先级，分为 <strong>OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL</strong> 或者您定义的级别。<em>Log4j</em> 建议只使用四个级别，优先级从高到低分别是 <strong>ERROR、WARN、INFO、DEBUG</strong>. 如果设置为 <strong>INFO</strong> 则，<strong>ERROR</strong>, <strong>WARN</strong>, <strong>INFO</strong> 都会输出，而 <strong>DEBUG</strong> 不会输出。</p><p>(2). <em>appenderName</em> : 是日志输出的目的地，名字是 <strong>自定义</strong>，也可以写多个；上面的配置 <em>stdout</em> 就是一个 <em>appenderName</em> 名字，当然你也可以叫其他名字的。当然你这里定义了这个名字，那么下面就要配置这个名字对应的输出地的相关信息，那下面配置的信息就得和这里设置的一致。下面会讲到。</p><h3 id="配置信息输出目的地"><a href="#配置信息输出目的地" class="headerlink" title="配置信息输出目的地"></a>配置信息输出目的地</h3><p>上面代码的第 <strong>4-7</strong> 和 <strong>12-16</strong> 行都是配置日志输出目的地的，目的地有多种类型：</p><p><em>(1)</em>. <strong>org.apache.log4j.ConsoleAppender（控制台）</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Threshold=WARN// 指定日志消息的输出最低层次。</span><br><span class="line">ImmediateFlush=true// 默认值是true,意谓着所有的消息都会被立即输出。</span><br><span class="line">Target=System.err// 默认情况下是：System.out,指定输出控制台</span><br></pre></td></tr></table></figure></div><p><em>(2)</em>. <strong>org.apache.log4j.FileAppender（文件）</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Threshold=WARN// 指定日志消息的输出最低层次。</span><br><span class="line">ImmediateFlush=true// 默认值是true,意谓着所有的消息都会被立即输出。</span><br><span class="line">File=mylog.txt// 指定消息输出到mylog.txt文件。</span><br><span class="line">Append=false// 默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。</span><br></pre></td></tr></table></figure></div><p><em>(3)</em>. <strong>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Threshold=WARN // 指定日志消息的输出最低层次。</span><br><span class="line">ImmediateFlush=true// 默认值是true,意谓着所有的消息都会被立即输出。</span><br><span class="line">File=mylog.txt// 指定消息输出到mylog.txt文件。</span><br><span class="line">Append=false// 默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。</span><br><span class="line">DatePattern=&apos;&apos;.&apos;&apos;yyyy-ww//每周滚动一次文件，即每周产生一个新的文件。当然也可以指定按月、周、天、时和分。即对应的格式如下：</span><br><span class="line">1)&apos;&apos;.&apos;&apos;yyyy-MM: 每月</span><br><span class="line">2)&apos;&apos;.&apos;&apos;yyyy-ww: 每周  </span><br><span class="line">3)&apos;&apos;.&apos;&apos;yyyy-MM-dd: 每天</span><br><span class="line">4)&apos;&apos;.&apos;&apos;yyyy-MM-dd-a: 每天两次</span><br><span class="line">5)&apos;&apos;.&apos;&apos;yyyy-MM-dd-HH: 每小时</span><br><span class="line">6)&apos;&apos;.&apos;&apos;yyyy-MM-dd-HH-mm: 每分钟</span><br></pre></td></tr></table></figure></div><p><em>(4)</em>. <strong>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Threshold=WARN// 指定日志消息的输出最低层次。</span><br><span class="line">ImmediateFlush=true// 默认值是true,意谓着所有的消息都会被立即输出。</span><br><span class="line">File=mylog.txt// 指定消息输出到mylog.txt文件。</span><br><span class="line">Append=false// 默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。</span><br><span class="line">MaxFileSize=100KB// 后缀可以是KB, MB 或者是 GB. 在日志文件到达该大小时，将会自动滚动，即将原来的内容移到mylog.log.1文件。</span><br><span class="line">MaxBackupIndex=2// 指定可以产生的滚动文件的最大数。</span><br></pre></td></tr></table></figure></div><p><em>(5)</em>. <strong>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</strong></p><p>这个用得相对较少，这里就不介绍了。</p><h3 id="日志信息的输出格式"><a href="#日志信息的输出格式" class="headerlink" title="日志信息的输出格式"></a>日志信息的输出格式</h3><p>上面代码的第 <strong>8-9</strong> 和 <strong>17-18</strong> 行都是配置日志输出格式的，也有多种类型：</p><p><em>(1)</em>. <strong>org.apache.log4j.HTMLLayout（以HTML表格形式布局）</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocationInfo=true// 默认值是 false, 输出 java 文件名称和行号</span><br><span class="line">Title=my app file// 默认值是 Log4J Log Messages.</span><br></pre></td></tr></table></figure></div><p><em>(2)</em>. <strong>org.apache.log4j.PatternLayout（可以灵活地指定布局模式）</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConversionPattern=%m%n// 指定怎样格式化指定的消息。</span><br><span class="line">ConversionPattern=%-4r %-5p %d&#123;yyyy-MM-dd HH:mm:ssS&#125; %c %m%n// 这个模式下面会详细介绍</span><br></pre></td></tr></table></figure></div><p><em>(3)</em>. <strong>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocationInfo=true:默认值是false,输出java文件和行号</span><br></pre></td></tr></table></figure></div><p><em>(4)</em>. <strong>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</strong></p><p>对于 <strong>PatternLayout</strong> 模式下：</p><p><strong>ConversionPattern=%-4r %-5p %d{yyyy-MM-dd HH:mm:ssS} %c %m%n</strong></p><p>这里需要说明的就是日志信息格式中几个符号所代表的含义：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">－x号: x信息输出时左对齐；</span><br><span class="line">%p: 输出日志信息优先级，即 DEBUG，INFO，WARN，ERROR，FATAL, </span><br><span class="line">%d: 输出日志时间点的日期或时间，默认格式为 ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss,SSS&#125;，输出类似：2002年10月18日 22：10：28，921 </span><br><span class="line">%r: 输出自应用启动到输出该log信息耗费的毫秒数</span><br><span class="line">%c: 输出日志信息所属的类目，通常就是所在类的全名</span><br><span class="line">%t: 输出产生该日志事件的线程名</span><br><span class="line">%l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) </span><br><span class="line">%x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。</span><br><span class="line">%%: 输出一个&quot;%&quot;字符</span><br><span class="line">%F: 输出日志消息产生时所在的文件名称</span><br><span class="line">%L: 输出代码中的行号</span><br><span class="line">%m: 输出代码中指定的消息,产生的日志具体信息</span><br><span class="line">%n: 输出一个回车换行符，Windows平台为&quot;\r\n&quot;，Unix平台为&quot;\n&quot;输出日志信息换行</span><br><span class="line">  可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。如：</span><br><span class="line"> 1)%20c：指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，默认的情况下右对齐。</span><br><span class="line"> 2)%-20c:指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，&quot;-&quot;号指定左对齐。</span><br><span class="line">  3)%.30c:指定输出category的名称，最大的宽度是30，如果category的名称大于30的话，就会将左边多出的字符截掉，但小于30的话也不会有空格。</span><br><span class="line">  4)%20.30c:如果category的名称小于20就补空格，并且右对齐，如果其名称长于30字符，就从左边交远销出的字符截掉</span><br></pre></td></tr></table></figure></div><p>下面给出一个完整的配置说明：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 这里里配置了DEBUG等级，则可显示DEBUG以上的所有信息；</span><br><span class="line"># 配置的输出地有两个apconsole,apfile, 与下面的 后面的log4j.appender.apconsole 最后一个单词相同</span><br><span class="line">log4j.rootLogger = DEBUG, apconsole, apfile</span><br><span class="line"></span><br><span class="line"># ========================= apconsole ===========================</span><br><span class="line"></span><br><span class="line"># apconsole 目的地配置为：ConsoleAppender（控制台）</span><br><span class="line">log4j.appender.apconsole = org.apache.log4j.ConsoleAppender</span><br><span class="line"># apconsole 输出日志编码 UTF-8</span><br><span class="line">log4j.appender.apconsole.Encoding=UTF-8</span><br><span class="line"># apconsole 的 Threshold: 指定日志消息的输出最低层次为 DEBUG</span><br><span class="line">log4j.appender.apconsole.Threshold=DEBUG</span><br><span class="line"># apconsole 的 ImmediateFlush=true，默认值是true,意谓着所有的消息都会被立即输出</span><br><span class="line">log4j.appender.apconsole.ImmediateFlush=true</span><br><span class="line"># apconsole 的 Target=System.out：默认情况就是是：System.out, 指定输出控制台</span><br><span class="line"># log4j.appender.apconsole.Target=System.out</span><br><span class="line"># apconsole 的信息输出格式为：PatternLayout（可以灵活地指定布局模式）</span><br><span class="line">log4j.appender.apconsole.layout = org.apache.log4j.PatternLayout</span><br><span class="line"># apconsole 的输出格式 ConversionPattern 此处输出为：日志优先级 日志时间 日志所属类全名 日志具体信息 回车</span><br><span class="line">log4j.appender.apconsole.layout.ConversionPattern=[%p] %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c] %m%n</span><br><span class="line"></span><br><span class="line"># ========================== apfile =============================</span><br><span class="line"></span><br><span class="line"># apfile 目的地配置为：DailyRollingFileAppender（每天生成一个文件）</span><br><span class="line">log4j.appender.apfile = org.apache.log4j.DailyRollingFileAppender</span><br><span class="line"># apfile 输出日志文件格式为 UTF-8</span><br><span class="line">log4j.appender.apfile.Encoding=UTF-8</span><br><span class="line"># apfile 输出日志文件地址为 tomcat 主目录的 logs 下的 log.txt</span><br><span class="line">log4j.appender.apfile.File=$&#123;catalina.home&#125;/logs/log.txt</span><br><span class="line"># apfile 将消息增加到指定文件中, false 则是覆盖原文件内容</span><br><span class="line">log4j.appender.apfile.Append=true</span><br><span class="line"># apfile 每天产生一个日志文件, 名称为 年月日</span><br><span class="line">log4j.appender.apfile.DatePattern=&apos;.&apos;yyyyMMdd</span><br><span class="line"># apfile 采用灵活指定输出布局模式</span><br><span class="line">log4j.appender.apfile.layout = org.apache.log4j.PatternLayout</span><br><span class="line"># apfile 使用 ConversionPattern 此处输出为：日志优先级 日志时间 日志所属类全名 日志具体信息 回车</span><br><span class="line">log4j.appender.apfile.layout.ConversionPattern=[%p] %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c] %m%n</span><br></pre></td></tr></table></figure></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://blog.csdn.net/yycdaizi/article/details/8276265#" target="_blank" rel="noopener"><strong>[CSDN]</strong> Java 日志组件介绍 ( common-logging, log4j, slf4j, logback)</a></li><li><a href="http://www.cnblogs.com/zhuawang/p/3999132.html" target="_blank" rel="noopener"><strong>[CNBlog]</strong> log4j 与 commons-logging, slf4j 的关系</a></li><li><a href="http://www.cnblogs.com/zhuawang/p/3999035.html" target="_blank" rel="noopener"><strong>[CNBlog]</strong> log4j 的配置信息</a></li><li><a href="http://blog.csdn.net/geekun/article/details/51398621" target="_blank" rel="noopener"><strong>[CSDN]</strong> Java 使用 Log 日志系统（ common-logging 和 log4j ）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot; style=&quot;margin: 30px 0 35px;&quot;&gt;容易被忽略的数据生产源&lt;/p&gt;

&lt;p&gt;目前，随着大数据方向的推进，越来越多的数据被应用于数据分析和挖掘，而其中一大部分就是项目中的 &lt;strong&gt;日志数据&lt;/strong&gt;。而 &lt;strong&gt;Java&lt;/strong&gt; 项目中有很多的日志输出包，不同项目使用不同的日志工具会造成数据结构的不一致，这样就为 &lt;strong&gt;数据分析&lt;/strong&gt; 增添了一定的麻烦，今天记录下对各中日志工具的说明。&lt;/p&gt;
&lt;h2 id=&quot;日志组件历史&quot;&gt;&lt;a href=&quot;#日志组件历史&quot; class=&quot;headerlink&quot; title=&quot;日志组件历史&quot;&gt;&lt;/a&gt;日志组件历史&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;JUL&quot;&gt;&lt;a href=&quot;#JUL&quot; class=&quot;headerlink&quot; title=&quot;JUL&quot;&gt;&lt;/a&gt;JUL&lt;/h3&gt;&lt;p&gt;这个是 &lt;strong&gt;java.util.logging&lt;/strong&gt; 的缩写，也就是 Java 本身 JDK 自带的日志工具，但是通常它的功能有限，因此，项目中的日志输出都是采用特有的日志工具进行记录。而日志工具中得到广泛使用的就是 &lt;strong&gt;log4j&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&quot;Log4j&quot;&gt;&lt;a href=&quot;#Log4j&quot; class=&quot;headerlink&quot; title=&quot;Log4j&quot;&gt;&lt;/a&gt;Log4j&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Java&lt;/strong&gt; 界里有许多实现日志功能的工具，最早得到广泛使用的是 &lt;strong&gt;log4j&lt;/strong&gt;, 许多应用程序的日志部分都交给了 &lt;strong&gt;log4j&lt;/strong&gt;, 不过作为组件开发者，他们希望自己的组件不要紧紧依赖某一个工具，毕竟在同一个时候还有很多其他很多日志工具，假如一个应用程序用到了两个组件，恰好两个组件使用不同的日志工具，那么应用程序就会有两份日志输出了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Logger" scheme="https://www.godjiyi.cn/categories/Logger/"/>
    
    
      <category term="Java" scheme="https://www.godjiyi.cn/tags/Java/"/>
    
      <category term="Logger" scheme="https://www.godjiyi.cn/tags/Logger/"/>
    
  </entry>
  
  <entry>
    <title>Docker 常用命令</title>
    <link href="https://www.godjiyi.cn/2018/03/18/docker/"/>
    <id>https://www.godjiyi.cn/2018/03/18/docker/</id>
    <published>2018-03-18T06:00:40.000Z</published>
    <updated>2018-09-18T12:34:27.090Z</updated>
    
    <content type="html"><![CDATA[<p align="center" style="margin: 30px 0 35px;">为虚拟化应用而生，生产环境一键打包</p><p><code>Docker</code> 是一个开源的 <strong>应用容器引擎</strong>，基于 <code>Go</code> 语言 并遵 <code>从Apache2.0</code> 协议开源。<code>Docker</code> 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 <code>Linux</code> 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（ 类似 <code>iPhone</code> 的 <code>App</code> ），更重要的是容器性能开销极低。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><hr><ul><li><code>Web</code> 应用的自动化打包和发布；</li><li>自动化测试和持续集成、发布；</li><li>在服务型环境中部署和调整数据库或其他的后台应用；</li><li>从头编译或者扩展现有的 <code>OpenShift</code> 等平台来搭建自己的PaaS环境；</li></ul><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><hr><p>官网：<a href="www.docker.com">www.docker.com</a></p><p>仓库：</p><ol><li><code>docker</code> 官网仓库: <a href="http://hub.docker.com" target="_blank" rel="noopener">http://hub.docker.com</a></li><li><code>docker</code> 中国区官网仓库: <a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a></li><li>阿里镜像仓库: <a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">https://dev.aliyun.com</a></li><li>163 仓库(需注册): <a href="http://c.163yun.com/hub" target="_blank" rel="noopener">http://c.163yun.com/hub</a></li></ol><a id="more"></a><p>安装：</p><ol><li><code>MacOS</code> 安装: <a href="https://docs.docker.com/docker-for-mac/install/" target="_blank" rel="noopener">官网教程地址</a></li><li><code>Ubuntu</code> 安装: <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">官网教程地址</a></li><li><p><code>Ubuntu</code> 简单旧版安装:</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uname -r <span class="comment"># 内核版本需要 &gt; 3.10</span></span><br><span class="line">sudo apt-get install -y docker.io <span class="comment"># 安装系统自带的 docker ( 可能不是最新版本 )</span></span><br><span class="line">docker version <span class="comment"># 出现客户端和服务端版本</span></span><br></pre></td></tr></table></figure></div></li></ol><h2 id="Docker初体验"><a href="#Docker初体验" class="headerlink" title="Docker初体验"></a>Docker初体验</h2><hr><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>docker pull <strong>[OPTIONS]</strong> NAME<strong>[:TAG]</strong></p><p><em>NAME</em> 必须指定，<em>TAG</em> 表示版本，默认不写为 <code>latest</code> 最新版本</p><p>默认 <code>pull</code> 的地址为 <code>docker</code> 官方镜像地址: <a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">https://hub.docker.com/explore/</a></p><p>如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull hello-world<span class="comment"># 拉取 hello-world 镜像</span></span><br><span class="line">docker pull tomcat<span class="comment"># 拉取 tomcat 镜像</span></span><br><span class="line">docker pull nginx<span class="comment"># 拉取 nginx 镜像</span></span><br><span class="line">docker pull mysql<span class="comment"># 拉取 mysql 镜像</span></span><br></pre></td></tr></table></figure></div><p>但是国内该地址常常被墙，所以国内大公司出了自己的镜像仓库，在上一节已经说明。</p><p>这里以用 163 蜂巢的镜像为例，地址: <a href="https://c.163.com/hub#/m/home/" target="_blank" rel="noopener">https://c.163.com/hub#/m/home/</a></p><p>地址里含有 <strong>libary</strong> 为 163 从 <code>docker</code> 官网复制过来的镜像。</p><p>如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull hub.c.163.com/library/tomcat:latest<span class="comment"># 拉取 tomcat 镜像</span></span><br><span class="line">docker pull hub.c.163.com/library/nginx:latest<span class="comment"># 拉取 nginx 镜像</span></span><br><span class="line">docker pull hub.c.163.com/library/mysql:latest<span class="comment"># 拉取 mysql 镜像</span></span><br></pre></td></tr></table></figure></div><h3 id="查看本机镜像"><a href="#查看本机镜像" class="headerlink" title="查看本机镜像"></a>查看本机镜像</h3><p>docker images <strong>[OPTIONS]</strong> <strong>[REPOSITORY[:TAG]]</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></div><h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><p>docker run <strong>[OPTIONS]</strong> IMAGE<strong>[:TAG]</strong> <strong>[COMMAND] [ARG]</strong></p><p>一个镜像运行起来就变为容器了，容器是动态的运行时的称呼。同一个镜像可以运行出多个容器，因为只要运行镜像，其内部内存占用等等一定不相同，所以镜像与容器是 <strong>1对多</strong> 的关系。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接运行</span></span><br><span class="line">docker run hello-world<span class="comment"># 如果没有此镜像则会自动从官方下载镜像</span></span><br><span class="line">docker run tomcat<span class="comment"># 通过命令行运行 tomcat，按 ctrl+c 就可以结束</span></span><br><span class="line"><span class="comment"># 也可以带参数 [OPTIONS] 运行</span></span><br><span class="line">docker run -d hello-world<span class="comment"># -d 表示后台运行tomcat镜像</span></span><br><span class="line"><span class="comment"># 也可以带命令运行</span></span><br><span class="line">docker run learn/tutorial <span class="built_in">echo</span> <span class="string">"hello word"</span><span class="comment"># 输出 hello world</span></span><br><span class="line">docker run learn/tutorial apt-get install -y ping <span class="comment"># 安装 ping 工具</span></span><br><span class="line">docker run lean/ping ping www.google.com <span class="comment"># 执行 ping 命令</span></span><br></pre></td></tr></table></figure></div><h3 id="查看本机容器"><a href="#查看本机容器" class="headerlink" title="查看本机容器"></a>查看本机容器</h3><p>相信用过 Linux 的同学应该知道 <code>ps</code> 这个工具，代表 <code>process</code> 即进程。程序与进程的区别 和 镜像与容器的关系是一致的，进程和容器都是运行时状态，因此，查看本机容器的关键名也是 <code>ps</code>.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前 docker 所运行的容器</span></span><br><span class="line">docker ps<span class="comment"># 列出所有运行着的容器</span></span><br><span class="line"><span class="comment"># 要查看所有容器，包括未运行的容器</span></span><br><span class="line">docker ps -a<span class="comment"># 显示所有容器</span></span><br></pre></td></tr></table></figure></div><h3 id="运行容器命令"><a href="#运行容器命令" class="headerlink" title="运行容器命令"></a>运行容器命令</h3><p>docker exec <strong>[OPTIONS]</strong> CONTAINER <strong>[COMMAND] [ARG]</strong></p><p>前面 <strong>运行镜像</strong> 时已经说明直接运行镜像时可以带上命令以一起运行，那如果容器已经被启动了，怎么再在里面运行命令呢？那就是这个命令。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在容器中运行命令，查看帮助文档</span></span><br><span class="line">docker <span class="built_in">exec</span> --<span class="built_in">help</span><span class="comment"># 查看帮助文档</span></span><br><span class="line"><span class="comment"># 其中 -i 和 -t 参数最常用，其这两者常搭配使用</span></span><br><span class="line"><span class="comment"># -i 表示以交互模式运行容器；</span></span><br><span class="line"><span class="comment"># -t 表示为容器重新分配一个伪输入终端；</span></span><br><span class="line">docker <span class="built_in">exec</span> -it f4e5 bash<span class="comment"># 在某个容器里运行 bash</span></span><br><span class="line"><span class="comment"># 其中 f4e5 表示运行着的容器的 ID ，大家用前面的 docker ps 看到的 ID 就是；</span></span><br><span class="line"><span class="comment"># ID 可以选择前几个字符就可以的，因为前几个字符基本就能确定到这个容器了。</span></span><br></pre></td></tr></table></figure></div><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p>docker stop <strong>CONTAINER_ID</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止某个容器 ( 可以为容器的 Id，也可以是容器的名称 )</span></span><br><span class="line">docker stop 56f433965490<span class="comment"># 以容器 Id 停止容器</span></span><br></pre></td></tr></table></figure></div><h3 id="打包成镜像"><a href="#打包成镜像" class="headerlink" title="打包成镜像"></a>打包成镜像</h3><p>docker commit <strong>CONTAINER_ID</strong> <strong>IMAGE_NAME</strong></p><p>容器既然是镜像运行时状态，那我们如果在容器里装很多软件，而自己又不想每次用这个镜像都想重新装一遍软件，那么就可以将自己 DIY 的容器存为镜像，以后我们再 DIY 时就从我们已经装完软件的那个时刻开始了。将容器打包为镜像命令如上。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器打包成一个新的镜像</span></span><br><span class="line">docker commit 56f tomcat/property</span><br><span class="line"><span class="comment"># 将 Id 为 56f 的容器打包成一个镜像，镜像名称自己起就可以了</span></span><br></pre></td></tr></table></figure></div><h3 id="删除镜像和容器"><a href="#删除镜像和容器" class="headerlink" title="删除镜像和容器"></a>删除镜像和容器</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 删除容器</span></span><br><span class="line">docker rm CONTAINER_ID</span><br><span class="line"><span class="comment"># 2. 删除所有容器，-q 表示显示容器 Id</span></span><br><span class="line">docker rm $(docker ps -a -q)</span><br><span class="line"><span class="comment"># 3. 删除镜像，rmi 中的 i 表示 image</span></span><br><span class="line">docker rmi IMAGES_NAME</span><br><span class="line"><span class="comment"># 4：举例：删除 tomcat 镜像</span></span><br><span class="line">docker rmi tomcat</span><br></pre></td></tr></table></figure></div><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><hr><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>下面给出做 web 方向常用到的一些命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 163镜像中心 下载 nginx 镜像</span></span><br><span class="line">docker pull hub.c.163.com/library/nginx:latest</span><br><span class="line"><span class="comment"># 或者从官网镜像中心下载 nginx 镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 Nginx 镜像， 没有端口映射，只能本机访问</span></span><br><span class="line">docker run hub.c.163.com/library/nginx<span class="comment"># 前台运行</span></span><br><span class="line">docker run -d hub.c.163.com/library/nginx<span class="comment"># 后台运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 Nginx 镜像，端口映射本机 80 端口,</span></span><br><span class="line"><span class="comment"># 这样其他机器访问本机的 80 自动映射到容器 80 服务</span></span><br><span class="line"><span class="comment"># docker run -d -p 80:80 --name webserver nginx </span></span><br><span class="line"><span class="comment"># --name 表示给容器起名，这里为 webserver</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止运行 Nginx 镜像的 webserver 容器</span></span><br><span class="line">docker stop webserver</span><br><span class="line"><span class="comment"># 或者用容器 Id 停止</span></span><br><span class="line">docker stop CONTAINER_ID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器里运行 bash</span></span><br><span class="line">docker <span class="built_in">exec</span> -it f4e5 bash<span class="comment"># 打开 f4e5 容器里的 bash 命令行界面</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器 ip</span></span><br><span class="line">docker inspect f4e5 | grep IPAddress</span><br></pre></td></tr></table></figure></div><h3 id="容器端口映射"><a href="#容器端口映射" class="headerlink" title="容器端口映射"></a>容器端口映射</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将本机 8080 端口映射到容器的 80 端口，-p 代表开放端口</span></span><br><span class="line">docker run -d -p 8080:80 hub.c.163.com/library/nginx</span><br><span class="line">netstat -na | grep 8080  // 可以检查本机端口状态</span><br><span class="line"><span class="comment"># 将本机随机的端口映射到容器的 80 和 443 端口</span></span><br><span class="line">docker run -d -P hub.c.163.com/library/nginx</span><br></pre></td></tr></table></figure></div><h3 id="容器运行-WAR-包"><a href="#容器运行-WAR-包" class="headerlink" title="容器运行 WAR 包"></a>容器运行 WAR 包</h3><p>这是我在一个项目里面用这种方式尝试过了，使用 <code>tomcat</code> 镜像运行出的容器，把本地的 <code>war</code> 包映射到容器 <code>tomcat</code> 里的 <code>ROOT</code> 目录，同时端口也要映射出来，最后可以通过外网访问。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it -p 8089:8080 -v $(<span class="built_in">pwd</span>)/ROOT.war:/usr/<span class="built_in">local</span>/tomcat/webapps/ROOT.war -v $(<span class="built_in">pwd</span>)/ROOT:/usr/<span class="built_in">local</span>/tomcat/webapps/ROOT -v $(<span class="built_in">pwd</span>)/uploads:/usr/<span class="built_in">local</span>/webapps/uploads tomcat</span><br><span class="line"><span class="comment"># 1. 将本地 8089 映射到容器的 8080 端口,</span></span><br><span class="line"><span class="comment"># 2. 将本地磁盘的 ROOT.war 映射到容器里 tomcat 的 webapps 目录，</span></span><br><span class="line"><span class="comment"># 3. 将本地磁盘的 ROOT 目录，映射到容器里 tomcat 的 ROOT 目录，</span></span><br><span class="line"><span class="comment"># 4. 将本地磁盘的 uploads 目录，映射到容器里 tomcat 的 webapps/uploads 目录 (这是我们项目上传文件的地址)</span></span><br><span class="line"><span class="comment"># 5. 最后为镜像名称，如果为 163蜂巢的镜像名 则应改为蜂巢的镜像名</span></span><br><span class="line"><span class="comment"># -v : 为加载本地硬盘</span></span><br><span class="line"><span class="comment"># -it : 为执行容器里命令开启</span></span><br><span class="line"><span class="comment"># -i : --interactive 打开STDIN，用于控制台交互   </span></span><br><span class="line"><span class="comment"># -t : --tty 分配tty设备，该可以支持终端登录</span></span><br></pre></td></tr></table></figure></div><h3 id="制作自己的镜像"><a href="#制作自己的镜像" class="headerlink" title="制作自己的镜像"></a>制作自己的镜像</h3><p>这个是从构建文件制作自己的镜像的，主要是写 <code>Dockerfile</code>, 这个目前还涉及的较少，只写下基本的构建过程。主要分为 <code>Dockerfile</code> 编写 和 <code>build</code> 命令：</p><p><strong>Dockerfile</strong> </p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from hub.c.163.com/library/tomcat<span class="comment"># 镜像从 tomcat 继承</span></span><br><span class="line">MAINTAINER jiyi xxx@163.com<span class="comment"># 著作者名和邮箱</span></span><br><span class="line">COPY jpress.war  /usr/<span class="built_in">local</span>/tomcat/webapps<span class="comment"># 镜像操作，这里将 jpress.war 放到 tomcat/webapps 目录下</span></span><br></pre></td></tr></table></figure></div><p>docker build <strong>[OPTIONS]</strong> <strong>[PATH]</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接在包含 Dockerfile 的当前目录 build</span></span><br><span class="line">docker build .</span><br><span class="line"><span class="comment"># 或者 -t 为生成的镜像配一个 tag 说明，这里 jpress 为名字，lastest 为 tag</span></span><br><span class="line"><span class="comment"># 注意还有一个 . 表示 [PATH]，这里还是指当前路径</span></span><br><span class="line">docker build -t jpress:latest .</span><br></pre></td></tr></table></figure></div><h2 id="私有仓库部署"><a href="#私有仓库部署" class="headerlink" title="私有仓库部署"></a>私有仓库部署</h2><p>很多公司里需要构建自己的私有仓库，因此这里也简单介绍下。</p><p>假设有两台机器: </p><p><strong>A: 192.168.31.115 (作为仓库)</strong></p><p><strong>B: 192.168.31.215 (提交镜像者)</strong></p><p><strong>(1). A: 下载仓库镜像</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure></div><p><strong>(2). A: 运行镜像</strong></p><p>应该将本地某个目录映射到 <code>/tmp/registry</code> 中以保存镜像，官方文档: <a href="https://docs.docker.com/registry/deploying/#customize-the-storage-location" target="_blank" rel="noopener">点我</a>，这里还是说下不同版本的 <code>registry</code> 镜像中仓库地址是不一样的：</p><ul><li>版本 1.0 的数据保存在 <strong><del>/tmp/registry</del></strong></li><li>版本 2.0 的数据存储在 <strong>/var/lib/registry</strong></li></ul><p>示例命令如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry registry</span><br></pre></td></tr></table></figure></div><p><strong>(3). B: 先下载一个小镜像</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull busybox</span><br></pre></td></tr></table></figure></div><p><strong>(4). B: 修改该镜像的 tag</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag busybox 192.168.31.115:5000/busybox</span><br></pre></td></tr></table></figure></div><p><strong>(5). B: 上传镜像</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.31.115:5000/busybox</span><br></pre></td></tr></table></figure></div><p>出现问题不能 https，官方说明配置:<a href="https://docs.docker.com/registry/insecure/" target="_blank" rel="noopener">https://docs.docker.com/registry/insecure/</a>，这里说下我自己尝试的方法：</p><p>如果是在 Mac 上操作的，直接在<code>docker</code> 图标的设置里添加 <code>Insecure-registry:192.168.31.115:5000</code>, 保存重启软件就可以了。</p><p>如果是 Linux 系统，则修改 Docker 的配置文件 <code>/etc/docker/daemon.json</code>, 如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"insecure-registries"</span> : [<span class="string">"myregistrydomain.com:5000"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>(6). B: 检查是否上传成功</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET http://registry:5000/v2/_catalog</span><br><span class="line">curl -XGET http://192.168.31.115:5000/v2/_catalog</span><br><span class="line">curl -XGET http://registry:5000/v2/image_name/tags/list</span><br><span class="line">curl -XGET http://192.168.31.115:5000/v2/192.168.31.115:5000/busybox/tags/list</span><br></pre></td></tr></table></figure></div><p>返回结果示例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"repositories"</span>: [</span><br><span class="line"><span class="string">"busybox"</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="http://www.runoob.com/docker/" target="_blank" rel="noopener">http://www.runoob.com/docker/</a></li><li><a href="http://hub.docker.com" target="_blank" rel="noopener">http://hub.docker.com</a></li><li><a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a></li><li><a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">https://dev.aliyun.com</a></li><li><a href="http://c.163yun.com/hub" target="_blank" rel="noopener">http://c.163yun.com/hub</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot; style=&quot;margin: 30px 0 35px;&quot;&gt;为虚拟化应用而生，生产环境一键打包&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt; 是一个开源的 &lt;strong&gt;应用容器引擎&lt;/strong&gt;，基于 &lt;code&gt;Go&lt;/code&gt; 语言 并遵 &lt;code&gt;从Apache2.0&lt;/code&gt; 协议开源。&lt;code&gt;Docker&lt;/code&gt; 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 &lt;code&gt;Linux&lt;/code&gt; 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（ 类似 &lt;code&gt;iPhone&lt;/code&gt; 的 &lt;code&gt;App&lt;/code&gt; ），更重要的是容器性能开销极低。&lt;/p&gt;
&lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Web&lt;/code&gt; 应用的自动化打包和发布；&lt;/li&gt;
&lt;li&gt;自动化测试和持续集成、发布；&lt;/li&gt;
&lt;li&gt;在服务型环境中部署和调整数据库或其他的后台应用；&lt;/li&gt;
&lt;li&gt;从头编译或者扩展现有的 &lt;code&gt;OpenShift&lt;/code&gt; 等平台来搭建自己的PaaS环境；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;官网：&lt;a href=&quot;www.docker.com&quot;&gt;www.docker.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仓库：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;docker&lt;/code&gt; 官网仓库: &lt;a href=&quot;http://hub.docker.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://hub.docker.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker&lt;/code&gt; 中国区官网仓库: &lt;a href=&quot;https://registry.docker-cn.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://registry.docker-cn.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;阿里镜像仓库: &lt;a href=&quot;https://dev.aliyun.com/search.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.aliyun.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;163 仓库(需注册): &lt;a href=&quot;http://c.163yun.com/hub&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://c.163yun.com/hub&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://www.godjiyi.cn/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://www.godjiyi.cn/tags/Docker/"/>
    
      <category term="容器" scheme="https://www.godjiyi.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="虚拟化" scheme="https://www.godjiyi.cn/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>论文收录平台 ( SCI、EI 等 ) 详细说明</title>
    <link href="https://www.godjiyi.cn/2017/11/18/papersci/"/>
    <id>https://www.godjiyi.cn/2017/11/18/papersci/</id>
    <published>2017-11-18T06:00:40.000Z</published>
    <updated>2018-09-18T12:35:48.580Z</updated>
    
    <content type="html"><![CDATA[<p align="center" style="margin: 30px 0 35px;">学术论文平台一点通，毕业论文不再是难事</p><p>最近发论文的需求逐渐被提高上来，身边的同学也在忙碌自己的研究，准备发篇论文以应对论文开题。但我们学校对发的论文有一定要求，需要被至少 <strong>SCI、EI、北大核刊</strong> 录入才可以，但是全球期刊和会议多之又多，<em>怎么确定哪个会议被哪个平台是否录入，哪个学术会议或期刊价值更高点，以及怎么对各个平台进行索引搜索</em>，这就需要自己详细地了解各种平台以及各个名词，下面记录下自己的了解。</p><ul><li>主要关键词：<strong>ISI、SCI、SCIE、SSCI、JCR、ESI、EI、ISTP、IEEE、CCF</strong>等说明；</li><li>各个服务的<strong>检索网址说明</strong>；</li><li><strong>中国索引服务</strong>介绍</li></ul><h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><hr><h3 id="SCI"><a href="#SCI" class="headerlink" title="SCI"></a>SCI</h3><p><strong>SCI</strong> 的英文全称为 <em>Science Citation Index</em> ，即 <strong>《科学引文索引》</strong>，简称 <strong>《SCI》</strong>，是美国科技情报研究所（ <em>Institute for Scientific Information</em> 简称“ <strong>ISI</strong> ” ）于 1961 年创办的国际权威检索系统，其创始人为 <strong>尤金·加菲尔德</strong>（ Eugene Garfield, September 16, 1925～2017 ）。</p><a id="more"></a><h3 id="SCIE"><a href="#SCIE" class="headerlink" title="SCIE"></a>SCIE</h3><p><strong>SCIE</strong> 即 <em>SCI Expanded</em> 为 《科学引文索引扩展版》（即网络版），上面的 <strong>SCI</strong> 则主要 <em>指来源刊为3700多种的SCI印刷版和SCI光盘版</em>；而 <strong>SCIE</strong> <em>则收录了5600多种来源期刊，提供WEB检索服务</em>，随着网络的普及，现在我们 <strong>高校所讲的SCI</strong> 通常是包 <strong>原SCI+SCIE</strong> 的,而网络上能检索的通常是 <strong>SCIE</strong>，所以一般网上讲的 SCI 通常都是指 <strong>SCIE</strong>。</p><h3 id="SSCI"><a href="#SSCI" class="headerlink" title="SSCI"></a>SSCI</h3><p><strong>SSCI</strong> 即 <em>Social Sciences Citation Index</em> 为 <strong>《社会科学引文索引》</strong>，也由 <strong>ISI</strong> 创建，是 <strong>SCI(原SCI+SCIE)</strong> 的姊妹篇。主要收录 1809 种世界最重要的 <strong>社会科学</strong> 期刊，内容覆盖包括人类学、法律、经济、历史、地理、心理学等 55 个领域。收录文献类型包括：研究论文，书评，专题讨论，社论，人物自传，书信等。选择收录 ( Selectively Covered ) 期刊为 1300 多种。</p><h3 id="JCR"><a href="#JCR" class="headerlink" title="JCR"></a>JCR</h3><p><strong>JCR</strong> 即 <em>Journal Citation Reports</em> 为 <strong>《期刊引用报告》</strong>，也由 <strong>ISI</strong> 出版，每年出版一次，其主要是对 <strong>SCIE</strong> 和 <strong>SSCI</strong> 收录的期刊的引用和被引用数据进行统计、运算，并针对每种期刊定义了 <em>影响因子（Impact Factor，缩写IF）</em> 等指数加以报道。该指数主要作为 <strong>期刊(并非论文)的评价工具</strong>。一种刊物的影响因子越高，也即其刊载的文献被引用率越高，一方面说明这些文献报道的研究成果影响力大，另一方面也反映该刊物的学术水平高。</p><h3 id="ESI"><a href="#ESI" class="headerlink" title="ESI"></a>ESI</h3><p><strong>ESI</strong> 即 <em>Essential Science Indicators</em> 为 <strong>《基本科学指标》</strong>,也由 <strong>ISI</strong> 出版，于 2001 年推出的衡量科学研究绩效、跟踪科学发展趋势的基本分析评价工具，也是基于 SCI 和 SSCI 所收录的 12000 多种学术期刊的1000多万条文献记录而建立的计量分析数据库，这个可用于 <strong>评价论文、作者、高校、学术机构、国家/地区国际学术水平及影响力的重要评价指标</strong>，因此很多学校很看重这个。</p><p><strong>ESI</strong> 指标会每 <em>两个月更新一次</em>，其每次都会将评判的所有期刊和会议列表成文档，放在官网提供下载，因此也会有很多高校会要求学生发表的论文期刊或会议在此列表中。<strong>ESI</strong> 每次更新的文档下载地址：<a href="http://ipscience-help.thomsonreuters.com/incitesLive/ESIGroup/overviewESI/esiJournalsList.html" target="_blank" rel="noopener">ESI评价期刊列表下载</a></p><h3 id="Web-of-Science"><a href="#Web-of-Science" class="headerlink" title="Web of Science"></a>Web of Science</h3><p><strong>Web of Science</strong> 简称 <strong>WOS</strong> 是由 <strong>Thomson Scientific(汤姆森科技信息集团)</strong> 推出的综合性学术信息资源平台，其具有丰富而强大的检索功能–普通检索、被引文献检索、化学结构检索，您可以方便快速地找到有价值的科研信息，即可以越查越旧，也可以越查越新，全面了解有关某一学科、某一课题的研究信息。它的资源库 <em>除了SCIE，还有SSCI，还有A&amp;HCI ( 人文和艺术引文索引 ),也包括其他扩充的数据资源库 ( 如：KCI,韩国期刊数据库 )</em>。</p><h3 id="Web-of-Knowledge"><a href="#Web-of-Knowledge" class="headerlink" title="Web of Knowledge"></a>Web of Knowledge</h3><p><strong>Web of Knowledge</strong> 是由 <strong>Thomson Scientific(汤姆森科技信息集团)</strong> 开发的信息检索平台，该平台包含了 <strong>Web of Science(主要是学术论文、会议录和新增的学术图书数据库)</strong>，还有 <strong>专利数据库</strong>，还有 <strong>JCR(Journal Citation Reports)</strong>，以及 <strong>ESI(Essential Science Indicators)</strong> 等数据检索服务。这个是所有检索服务的入口平台，官网为：<a href="http://www.webofknowledge.com" target="_blank" rel="noopener">http://www.webofknowledge.com</a>。</p><p><em>对于 Web of Science 和 Web of Knowledge区别?</em>，可以打个比方：<em>Web of Knowledge</em> 就相当于Microsoft Windows操作系统，而 <em>Web of Science</em> 则相当于Microsoft Office一套办公软件，正如Microsoft Windows平台除了可以跑Microsoft Office之外，还可以跑各种应用程序一样，Web of Knowledge平台除了 <em>Web of Science</em> 还包括 <em>专利数据库服务</em>、<em>JCR服务</em>、<em>ESI服务</em> 等。详细说明可以查看 <a href="http://blog.sciencenet.cn/blog-408109-548440.html" target="_blank" rel="noopener">这里</a>。</p><blockquote><p><em>注意</em>：这个网址 <em>不是免费的</em>，各大高校访问会根据学校 ip 自动登录就可以检索了，因为高校通常购买了使用权，但如果使用的普通外网则不能够访问。</p></blockquote><p>官网首页–默认为 <strong>Web of Science</strong> 板块,查询 <strong>SCI</strong> 文章:</p><p><img src="http://img.godjiyi.cn/sciarticle2.jpg" alt></p><p>其次– <strong>JCR</strong> 板块，查询期刊影响因子:</p><p><img src="http://img.godjiyi.cn/sciarticle3.jpg" alt></p><p>另外– <strong>ESI</strong> 板块，查询论文、作者、机构等排名:</p><p><img src="http://img.godjiyi.cn/sciarticle4.jpg" alt></p><h3 id="EI"><a href="#EI" class="headerlink" title="EI"></a>EI</h3><p><strong>EI</strong> 即 <em>The Engineering Index</em> 为 <strong>《工程索引》</strong>，由 <em>美国工程师学会联合会</em> 于 1884 年创办的历史上最悠久的一部大型综合性检索工具,<strong>EI</strong> 每月出版1期，文摘 1.3 万至 1.4 万条；每期附有主题索引与作者索引；每年还另外出版年卷本和年度索引，年度索引还增加了作者单位索引。收录文献几乎涉及 <strong>工程技术</strong> 各个领域。例如：动力、电工、电子、自动控制、矿冶、金属工艺、机械制造、土建、水利等。它具有综合性强、资料来源广、地理覆盖面广、报道量大、报道质量高、权威性强等特点。</p><ul><li>这个是 <em>EI数据库官网</em>：<a href="http://www.engineeringvillage.com" target="_blank" rel="noopener">http://www.engineeringvillage.com</a></li><li>这个是 <em>EI公司的官网</em>：<a href="http://www.elsevier.com/" target="_blank" rel="noopener">http://www.elsevier.com</a> （ <em>查 EI 论文，这个网址不需要</em> ）</li><li>检索 <em>说明教程</em>：<a href="http://www.eipaperbx.com/mod_static-view-sc_id-3.html" target="_blank" rel="noopener">图文说明</a></li></ul><h3 id="ISTP"><a href="#ISTP" class="headerlink" title="ISTP"></a>ISTP</h3><p><strong>ISTP</strong> 即 <em>Index to Scientific &amp; Technical Proceedings</em>，为<strong>《科技会议录索引》</strong> 简称 <strong>ISTP</strong>，创刊于 1978 年，由 <em>美国科学情报研究所(ISI)</em> 编辑出版。<strong>SCI、EI、ISTP是世界著名的三大科技文献检索系统</strong>，是国际公认的进行科学统计与科学评价的主要检索工具,其中以SCI最为重要。<strong>ISI</strong> 基于 Web of Science 的检索平台，将 ISTP（ 科学技术会议录索引 ）和 ISSHP（ 社会科学及人文科学会议录索引 ）两大会议录索引集成为 ISI Proceedings。集成之后 ISTP 分为文科和理科两种检索，分别是 CPCI-SSH 和 CPCI-S。所以它们还统称为 <strong>ISTP</strong>，也有人叫它们 <strong>CPCI</strong>。</p><h3 id="IEEE"><a href="#IEEE" class="headerlink" title="IEEE"></a>IEEE</h3><p><strong>IEEE</strong> 即 <em>Instituteof Electrical and Electronics Engineers</em> 为 <strong>美国电气和电子工程师协会</strong> 是一个国际性的电子技术与信息科学工程师的协会，是世界上最大的专业技术组织之一（ 成员人数 ），拥有来自 175 个国家的 36 万会员( 到2005年 )。该组织在太空、计算机、电信、生物医学、电力及消费性电子产品等领域中都是主要的权威。</p><ol><li><em>IEEE</em> 就和IEE（现在是IET）是英国的，IEICE是日本，CIE（中国电子协会）是中国的一样，它属于一个 <em>学术组织</em> ，不是数据库</li><li>既然是学术组织，一般都有自己的学术刊物，对于IEEE主要有 <em>Transactions（汇刊，会刊或学报），Journal（学报），Magazine（杂志）和Letters（快报，通讯）等</em></li><li>而SCI和EI只是检索工具，严格来讲其不是论文内容数据库，因为检索内容和论文内容不是一个意思，例如：<em>你可以用SCI工具检索到大部分IEEE刊物论文信息，但是SCI（ISI<br>Thompson）是无法提供论文内容的，因为他们的检索信息是各个刊物提供的</em>，你要获取全文需要访问付费数据库，例如IEEExplore,Elsevier数据库等。</li><li>与IEEE相似概念的有：<strong>ACM</strong> (<em>Association for Computing Machinery</em> ) 中文：<em>国际计算机学会</em>。ACM是一个世界性的计算机从业员专业组织，创立于1947年。 <strong>CCF</strong> (<em>China Computer Federation</em>),<em>中国计算机学会</em>,成立于1962年，是中国计算机科学与技术领域群众性学术团体。</li></ol><h3 id="CCF"><a href="#CCF" class="headerlink" title="CCF"></a>CCF</h3><p><strong>CCF</strong> : 即 <em>China Computer Federation</em> 为 <strong>中国计算机学会</strong>，成立于 1962 年，是中国 <strong>计算机科学与技术领域</strong> 群众性学术团体。注意此处是专注 <strong>计算机科学与技术</strong>，因此很多计算机专业的学院都会要求发表的论文为 <em><a href="http://www.ccf.org.cn/xspj/gyml/" target="_blank" rel="noopener">CCF推荐会议或期刊</a></em> 论文,CCF自动将各个期刊和会议分为 <em>A、B、C类</em>，A 类为顶会期刊或会议。</p><p><img src="http://img.godjiyi.cn/sciarticle5.jpg" alt></p><h3 id="中科院JCR期刊分区"><a href="#中科院JCR期刊分区" class="headerlink" title="中科院JCR期刊分区"></a>中科院JCR期刊分区</h3><p><strong>中科院JCR期刊分区</strong> : 分区是为了区别期刊的影响力等级，这与 <strong>CCF</strong> 中的 A类、B类、C类是同一个意思，只不过这里通常划分为四个分区。而分区主要还是基于 <em>汤森路透公司</em>(ISI隶属于此公司)的 <em>JCR(《期刊引用报告》)</em>, JCR 中定义了的 <em>影响因子</em> ( Impact Factor 简称 IF )就是决定分区方法的主要因素。分区也主要分为两种分区方式，一个就是汤森路透公司自己的分区方法 – <strong>汤森路透分区法</strong>，另外就是我们中国中科院的分区方法– <strong>中国科学院分区法</strong>，两者分区区别请看 <a href="http://blog.163.com/ly7148@126/blog/static/16646527620153154302991/" target="_blank" rel="noopener">SCI汤森路透分区法和中国科学院分区法的区别</a></p><p>(1). <strong>汤森路透分区法</strong> : 检索是通过上文提到的 <em><a href="http://www.webofknowledge.com" target="_blank" rel="noopener">Web of Knowledge</a></em> 中的 JCR模块查询。</p><p>(2). <strong>中科院JCR期刊分区</strong> : 检索地址为：<a href="http://www.fenqubiao.com/" target="_blank" rel="noopener">http://www.fenqubiao.com/</a>,这也需要账号的，高校通常会提供。</p><p><em>首页登录</em></p><p><img src="http://img.godjiyi.cn/sciarticle6.jpg" alt></p><p><em>浏览期刊排名</em></p><p><img src="http://img.godjiyi.cn/sciarticle7.jpg" alt></p><p><em>检索服务</em></p><p><img src="http://img.godjiyi.cn/sciarticle8.jpg" alt><br><img src="http://img.godjiyi.cn/sciarticle9.jpg" alt></p><h3 id="国内索引服务"><a href="#国内索引服务" class="headerlink" title="国内索引服务"></a>国内索引服务</h3><p>上面讲的核心都是国外提供的索引服务，对于国内的，也是有的,下面这些来源于知乎，地址：<a href="https://www.zhihu.com/question/31558495" target="_blank" rel="noopener">https://www.zhihu.com/question/31558495</a></p><ol><li><strong>中文核心期刊要目总览</strong> ( <em>PKU</em> ): 因是北京大学 图书馆主持发布的，俗称中文核心，北大核心。内容包含全面，既有自然科学类又有人文社会科学类。(<em>北大图书馆带领一堆专家玩小聚会，玩出了境界，门类齐全但每个门类都很少，两千种左右。武林至尊谁敢不从，一般没有特别要求的核心都是说它</em>)</li><li><strong>中文社会科学引文索引</strong> ( <em>CSSCI</em> )，因为是南京大学 中国社会科学研究评价中心主持发布的，俗称南大核心。只包含人文社会科学类。(十几所高校联合起来搞高级酒会，搞出了高度，社科类就玩五百多种期刊啦，文科仔们都气冒烟了)</li><li><strong>中国科技论文统计源期刊</strong> ( <em>ISTIC</em> )，是中国科技部 中国科学技术信息研究所主持发布的 中国科技期刊引证报告 中的核心部分，俗称统计源核心，中国科技核心。包含自然科学类，极少部分人文社科类的。一千六百左右吧。( 还是我科技部的敞亮，理工仔们扬眉吐气了，自然期刊比北大多了不少种嘛。尤其吸收的医学生物学，医学类比例都占三分之一了，外号叫医学核心也不是没有道理。但后来竟然吸收了社科的我也不懂为什么。)</li><li><strong>中国科学引文数据库来源期刊</strong> ( <em>CSCD</em> )，是由中国科学院 文献情报中心发布的统计源的核心部分，俗称中科院核心。好像是申请国家基金项目的硬指标啊。只是包含自然科学类的。核心部分八百种左右。( 科学院也不想让理工仔们活的潇洒啊，勒紧你们的紧箍咒 )</li><li><strong>中国人文社会科学核心期刊</strong> ( <em>CHSSCD</em> )，中国社科院 文献计量与科学评价研究中心发布的 中国人文科学核心期刊要览 中的核心部分，俗称应该就是人文社科核心，社科院核心吧，包含人文社会科学类。五百种左右。(社科院的姿态，怒刷存在感)</li><li><strong>中国人文社会科学报核心期刊</strong>,评选出的都是大学学报的社科版啦，好像不受关注的样子。(大学学报们这也能搞出来个学会，城会玩。也来开个party，我发现社科仔们真会玩啊)</li><li><strong>中国核心期刊(遴选)数据库</strong>，<em><a href="http://www.wanfangdata.com.cn/" target="_blank" rel="noopener">万方数据</a>股份有限公司</em> 的(开个私人会所，没背景也没NB评审团的，倒是起了个招摇的名字，我服了你了，印在封面上唬人一来一来的。)</li><li><strong>中国期刊全文数据库</strong> ( <em>CJFD</em> )，<em><a href="http://www.cnki.net/" target="_blank" rel="noopener">中国知网CNKI</a></em>，原名中国期刊网，同方知网技术有限公司，全国八千多种期刊，(什么叫闷声发大财，垄断就在你的屏幕上摆着呢，我就问你买不买？)</li><li><strong>中国科技期刊数据库</strong>，<em><a href="http://qikan.cqvip.com/" target="_blank" rel="noopener">维普</a>，重庆维普资讯有限公司</em>，尽收一万两千多种期刊。(收破烂专家的样子)。</li><li><strong>中国权威学术期刊</strong> ( <em>RCCSE</em> )，在武汉大学中国科学评价研究中心与武汉大学图书馆和信息管理学院联合研发完成的 RCCSE 中国学术期刊评价研究报告——权威、核心学术期刊排行榜，俗称武大核心。三百多种。(威呜呜呜呜，权威两个字就问你们怕不怕，哈哈)</li><li><strong>中国学术期刊综合评价数据库</strong>，以中国学术期刊（光盘版）和中国期刊网专题全文数据库的评价数据为基础而建立起来的大型数据库。<em>中国知识资源总库（ CNKI ）</em>、清华大学主办、中国学术期刊（ 光盘版 ）电子杂志社出版、清华同方知网（ 北京 ）技术有限公司发行、数百位科学家、院士、学者参与建设，精心打造的大型知识服务平台和数字化学习系统。(圈地，<em>知网</em> 这步棋走的好啊，一统江湖)</li><li><strong>人大报刊复印资料</strong>，中国人民大学《复印报刊资料》由中国人民大学书报资料中心出版，该数据库从国内公开出版的近六千种核心期刊与专业特色期刊中精选全文并汇编而成，囊括了人文社会科学领域中的各个学科。( 普遍是白皮封装，文章被其收录是刊物和论文的一种荣誉吧 )</li><li><strong>新华文摘</strong>，新华文摘是人民出版社主办的是一个大型的综合性、学术性、资料性的文摘半月刊，其选登文章代表了诸领域的前沿思想。同上，收录的也是其他期刊已经发表的优秀文章。在有的职称评选条件中，人大复印资料和新华文摘被承认国家级核心刊物。</li></ol><h3 id="本校要求的索引平台"><a href="#本校要求的索引平台" class="headerlink" title="本校要求的索引平台"></a>本校要求的索引平台</h3><p>下面是我自己学校研究生论文要求平台而提供的说明：</p><p><img src="http://img.godjiyi.cn/sciarticle10.jpg" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.zhihu.com/question/21111557" target="_blank" rel="noopener">SCI、EI、IEEE 是什么关系？国际会议、期刊、快报又有什么区别？</a></li><li><a href="http://blog.sciencenet.cn/blog-408109-548440.html" target="_blank" rel="noopener">Web of Knowledge 与 Web of Science 以及 SCIE 之间的关系</a></li><li><a href="http://blog.sciencenet.cn/blog-408109-902187.html" target="_blank" rel="noopener">影响因子本来是干什么的？看看SCI之父怎么说</a></li><li><a href="http://www.webofknowledge.com/" target="_blank" rel="noopener">Web of Knowledge 官网</a></li><li><a href="http://www.dxy.cn/bbs/thread/29300006#29300006" target="_blank" rel="noopener">SCI 与 SCIE 区别扫盲!</a></li><li><a href="http://www.lib.whu.edu.cn/dc/viewdc.asp?id=17" target="_blank" rel="noopener">工程索引网络版</a></li><li><a href="http://www.eipaperbx.com/mod_static-view-sc_id-3.html" target="_blank" rel="noopener">EI 检索查询</a></li><li><a href="https://www.douban.com/group/topic/11186089/" target="_blank" rel="noopener">IEEE 和 SCI 等的通俗简介</a></li><li><a href="http://blog.163.com/ly7148@126/blog/static/16646527620153154302991/" target="_blank" rel="noopener">SCI 汤森路透分区法和中国科学院分区法的区别</a></li><li><a href="https://www.zhihu.com/question/31558495" target="_blank" rel="noopener">SCI、EI、核心期刊 这些东西等级是怎么区分的？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot; style=&quot;margin: 30px 0 35px;&quot;&gt;学术论文平台一点通，毕业论文不再是难事&lt;/p&gt;

&lt;p&gt;最近发论文的需求逐渐被提高上来，身边的同学也在忙碌自己的研究，准备发篇论文以应对论文开题。但我们学校对发的论文有一定要求，需要被至少 &lt;strong&gt;SCI、EI、北大核刊&lt;/strong&gt; 录入才可以，但是全球期刊和会议多之又多，&lt;em&gt;怎么确定哪个会议被哪个平台是否录入，哪个学术会议或期刊价值更高点，以及怎么对各个平台进行索引搜索&lt;/em&gt;，这就需要自己详细地了解各种平台以及各个名词，下面记录下自己的了解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要关键词：&lt;strong&gt;ISI、SCI、SCIE、SSCI、JCR、ESI、EI、ISTP、IEEE、CCF&lt;/strong&gt;等说明；&lt;/li&gt;
&lt;li&gt;各个服务的&lt;strong&gt;检索网址说明&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中国索引服务&lt;/strong&gt;介绍&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;详细说明&quot;&gt;&lt;a href=&quot;#详细说明&quot; class=&quot;headerlink&quot; title=&quot;详细说明&quot;&gt;&lt;/a&gt;详细说明&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;SCI&quot;&gt;&lt;a href=&quot;#SCI&quot; class=&quot;headerlink&quot; title=&quot;SCI&quot;&gt;&lt;/a&gt;SCI&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;SCI&lt;/strong&gt; 的英文全称为 &lt;em&gt;Science Citation Index&lt;/em&gt; ，即 &lt;strong&gt;《科学引文索引》&lt;/strong&gt;，简称 &lt;strong&gt;《SCI》&lt;/strong&gt;，是美国科技情报研究所（ &lt;em&gt;Institute for Scientific Information&lt;/em&gt; 简称“ &lt;strong&gt;ISI&lt;/strong&gt; ” ）于 1961 年创办的国际权威检索系统，其创始人为 &lt;strong&gt;尤金·加菲尔德&lt;/strong&gt;（ Eugene Garfield, September 16, 1925～2017 ）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="论文" scheme="https://www.godjiyi.cn/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="SCI" scheme="https://www.godjiyi.cn/tags/SCI/"/>
    
      <category term="EI" scheme="https://www.godjiyi.cn/tags/EI/"/>
    
      <category term="索引" scheme="https://www.godjiyi.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>CDH-5.13 基于 Ubuntu 的布式部署</title>
    <link href="https://www.godjiyi.cn/2017/11/09/CDH/"/>
    <id>https://www.godjiyi.cn/2017/11/09/CDH/</id>
    <published>2017-11-09T09:40:40.000Z</published>
    <updated>2018-09-18T12:33:45.840Z</updated>
    
    <content type="html"><![CDATA[<p align="center" style="margin: 30px 0 35px;">企业大数据开源平台，从部署迈出第一步</p><p>最近应项目公司需求，我们需要为其构建一个大数据平台。<strong>开源的Hadoop生态应用</strong> 由于没有技术服务支持，公司不采用此种方案进行构建。因此我们选择采购具有技术支持的 <strong>第三方大数据平台</strong>，当然这些公司的平台也完全基于 <strong>Hadoop</strong>, 只不过他们有着一帮技术团队，可以为自己平台出现的问题提供技术服务。</p><p>第三方平台目前我们所接触了解的有四家：</p><ol><li><strong><a href="https://www.cloudera.com/" target="_blank" rel="noopener">Cloudera</a></strong></li><li><strong><a href="http://www.transwarp.cn/" target="_blank" rel="noopener">星环科技</a></strong></li><li><strong>华为</strong></li><li><strong>阿里</strong></li></ol><p>而由于 <strong>Cloudera</strong> 提供了开源免费版本的产品，因此这篇博客主要对 <strong>Cloudera</strong> 公司产品的部署过程进行记录。</p><h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><hr><ol><li><strong>Cloudera</strong>: Cloudera 公司目前是世界上最大的大数据平台提供商，其总部位于美国，且已经上市，2014进入中国市场，Hadoop 创始人 <strong>Doug Cutting</strong> 目前也就职于Cloudera，担任首席架构师，其内部有很多开源项目的 <strong>Committer</strong>，相比其他公司，其技术水平有着绝对的优势。</li><li><strong>CDH</strong>: Cloudera 公司目前主要的产品是 <strong>CDH</strong> ( <em>Cloudera’s Distribution including Apache Hadoop</em> ),是对 <strong>Hadoop 生态</strong>( hadoop + hive, hbase, flume, impala 等等)的一种封装融合，该产品是 <strong>完全免费下载和安装</strong> 的，其盈利方式是技术支持服务。</li><li><strong>Cloudera Manager</strong>: 由于大数据平台本身就是分布式，CDH 自然也不例外，为了便于用户快捷安装，Cloudera 公司提供了 <strong>Cloudera Manager</strong> 工具，可让用户在可视化的页面上组织自己的集群。</li><li><strong>部署方式</strong>：首先，Cloudera 公司提供了产品的<a href="https://www.cloudera.com/downloads/quickstart_vms/5-12.html" target="_blank" rel="noopener">尝鲜版本</a>，主要提供了<strong>Virtual Box、VMWare、KVM、Docker Image</strong> 等虚拟镜像，为了体验产品的用户可以尝试。此外，<strong>Cloudera</strong> 提供正式版本的<a href="https://www.cloudera.com/documentation/enterprise/latest/topics/installation.html" target="_blank" rel="noopener">安装说明</a>,下面就按照正式版本正式生产环境进行安装部署。</li></ol><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><hr><p>目前，Cloudera 最新版为 <strong><a href="https://www.cloudera.com/downloads/cdh/5-13-0.html" target="_blank" rel="noopener">CDH5.13</a></strong>，因此本教程基于 <strong>CDH5.13</strong> 安装</p><h3 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h3><p>搭建一个包含四个节点的集群，1 个 <strong>master</strong>, 3 个 <strong>slave</strong>, <strong>Host IP</strong> 对应关系如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 192.168.1.100 master</span><br><span class="line">2. 192.168.1.101 slave1</span><br><span class="line">3. 192.168.1.102 slave2</span><br><span class="line">4. 192.168.1.103 slave3</span><br></pre></td></tr></table></figure></div><p>各个主机的物理配置如下，<strong>master</strong> 至少 16G 内存，<strong>slave</strong> [ 1-3 ]至少 4G 内存：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master: CPU 16 核，32GB 内存，500G SSD</span><br><span class="line">slave[1-3]: CPU 8 核，16GB 内存，500G SSD</span><br></pre></td></tr></table></figure></div><h3 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h3><p>系统环境为<strong>Ubuntu16.04-Server</strong>版本，我们需要提前下好如下数据包：</p><ol><li>Cloudera Manager 安装包，约 <em>750MB</em>;</li><li>CDH 离线资源包，约 <em>1.9GB</em>;</li><li>CDH 离线包验证文件，约 <em>41B</em>;</li><li>CDH 离线包内的组件描述文件，约 <em>74KB</em>;</li><li>JDK8 安装包，约 <em>180MB</em>;</li></ol><p>其下载好的对应文件名如下：</p><ol><li><strong>cloudera-manager-xenial-cm5.13.0_amd64.tar.gz</strong></li><li><strong>CDH-5.13.0-1.cdh5.13.0.p0.29-xenial.parcel</strong></li><li><strong>CDH-5.13.0-1.cdh5.13.0.p0.29-xenial.parcel.sha</strong></li><li><strong>manifest.json</strong></li><li><strong>jdk-8u121-linux-x64.tar.gz</strong></li></ol><p>下载时需要确定自己系统的版本名称，<strong>Ubuntu 16.04</strong> 的对应的版本名称为 <strong>xenial</strong>，下面为对应文件的下载地址：</p><ol><li><em>Cloudera Manager</em>: <a href="http://archive.cloudera.com/cm5/cm/5/_index.html" target="_blank" rel="noopener">Cloudera 官网地址</a></li><li><em>CDH 资源包、CDH 校验文件、manifest.json</em>: <a href="http://archive.cloudera.com/cdh5/parcels/5.13.0/" target="_blank" rel="noopener">Cloudera 官网地址</a></li><li><em>JDK</em>: <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">Oracle 官网地址</a> 或者 <a href="https://gitee.com/jiyiren/linuxfile" target="_blank" rel="noopener">个人仓库地址</a></li></ol><h2 id="正式部署环境配置"><a href="#正式部署环境配置" class="headerlink" title="正式部署环境配置"></a>正式部署环境配置</h2><hr><p>正式的环境安装,以下操作均以 <strong>root</strong> 身份执行</p><h3 id="基本信息修改"><a href="#基本信息修改" class="headerlink" title="基本信息修改"></a>基本信息修改</h3><p>主要修改 <strong>Hostname</strong> 以及 <strong>Hosts</strong> 配置。修改 <strong>Hostname</strong> 是为了我们集群好查看和管理各个结点，而修改 <strong>Hosts</strong> 则是为了我们不用每次输入命令时都输入对方主机的 IP，我们直接输入 Hosts 中 IP 对应的名称即可。</p><p><strong>修改hostname</strong>: 所有节点，将各个主机名设置为对应的名称： <em>master, slave1, slave2, slave3</em>，<strong>master</strong> 主机修改为 <em>master</em>, <strong>slave[1-3]</strong> 则修改为 <em>slave1,slave2,slave3</em>, 修改命令如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line">vi /etc/hostname</span><br></pre></td></tr></table></figure></div><p><strong>Hosts配置</strong>：主要修改 <code>/etc/hosts</code> 文件，修改命令如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line">127.0.0.1     localhost</span><br><span class="line">192.168.1.100 master</span><br><span class="line">192.168.1.101 slave1</span><br><span class="line">192.168.1.102 slave2</span><br><span class="line">192.168.1.103 slave3</span><br></pre></td></tr></table></figure></div><h3 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h3><p>安装过程全部自动化，因此需要让 <strong>master</strong> 主机到所有其他 <strong>slave</strong> 主机可以免密登录。</p><p>由于是刚装的系统，<strong>Ubuntu</strong> 默认没有开启 <strong>root</strong> 远程登录的权限，所以需要先配置所有主机可 root 远程 ssh 登录，主要编辑配置文件 <code>/etc/ssh/sshd_config</code>,修改命令如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"><span class="comment"># PermitRootLogin prohibit-password # 原来的注释掉</span></span><br><span class="line">PermitRootLogin yes<span class="comment"># 修改为这个新配置</span></span><br><span class="line">service ssh restart <span class="comment"># 重启 ssh 服务，使之生效</span></span><br></pre></td></tr></table></figure></div><p>其次，要配置 <strong>slave</strong> 信任 <strong>master</strong> 主机。首先在 <strong>master</strong> 节点上生成 <strong>ssh</strong> 公钥私钥，执行 <code>ssh-keygen -t rsa</code> 一直回车，会生成在用户目录下的 <strong>.ssh</strong> 文件夹里，里面存放了公钥和私钥。然后再将生成的公钥添加到 <strong>master 和 slave[1-3]</strong> 主机的信任授权列表里，命令如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master节点上</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub master</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub slave1</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub slave2</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub slave3</span><br></pre></td></tr></table></figure></div><p>最后，测试 <strong>master</strong> 免密登录各个节点是否成功，使用 <code>ssh [hostname]</code>，若回车后自动登录，则成功，操作命令如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master节点</span></span><br><span class="line">ssh master</span><br><span class="line">ssh slave1</span><br><span class="line">ssh slave2</span><br><span class="line">ssh slave3</span><br></pre></td></tr></table></figure></div><h3 id="配置JDK环境"><a href="#配置JDK环境" class="headerlink" title="配置JDK环境"></a>配置JDK环境</h3><p>首先，解压 JDK 压缩包</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line">tar -zxf jdk-8u121-linux-x64.tar.gz -C /opt <span class="comment"># 安装在 /opt 目录下</span></span><br><span class="line">mv /opt/jdk1.8.0_121 /opt/jdk8 <span class="comment"># 将目录重命名</span></span><br></pre></td></tr></table></figure></div><p>然后，配置 <code>JAVA_HOME</code> 和 <code>PATH</code> 环境变量</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line">vi /etc/profile <span class="comment"># 加入下面环境</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/jdk8</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib:<span class="variable">$JRE_HOME</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line">vi /etc/environment <span class="comment"># 添加如下，注意此处无需 export 关键字</span></span><br><span class="line">JAVA_HOME=/opt/jdk8</span><br><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line">vi ~/.bashrc <span class="comment"># 添加如下</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/jdk8</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib:<span class="variable">$JRE_HOME</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile<span class="comment"># 让系统环境变量立即生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/environment<span class="comment"># 让系统环境变量立即生效</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc<span class="comment"># 让个人环境变量立即生效</span></span><br></pre></td></tr></table></figure></div><p>最后，测试 <strong>Java</strong> 是否安装成功，输入 <code>java -version</code> ，显示 <strong>Java</strong> 版本即可。</p><h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>这个在 <strong>master</strong> 节点安装即可</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master节点</span></span><br><span class="line">apt-get install mysql-server mysql-client</span><br></pre></td></tr></table></figure></div><h2 id="正式部署-–-安装-Manager"><a href="#正式部署-–-安装-Manager" class="headerlink" title="正式部署 – 安装 Manager"></a>正式部署 – 安装 Manager</h2><hr><p>安装之前需要将必要的软件上传到 <strong>master</strong> 节点上，文件包含：</p><ol><li><em>cloudera-manager-xenial-cm5.13.0_amd64.tar.gz</em>，</li><li><em>CDH-5.13.0-1.cdh5.13.0.p0.29-xenial.parcel</em>，</li><li><em>CDH-5.13.0-1.cdh5.13.0.p0.29-xenial.parcel.sha</em>，</li><li><em>manifest.json</em></li></ol><h3 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h3><p>解压 <em>cloudera-manager-xxx.tar.gz</em> 文件到 <code>/opt</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master节点</span></span><br><span class="line">tar -zxf cloudera-manager-xenial-cm5.13.0_amd64.tar.gz -C /opt</span><br></pre></td></tr></table></figure></div><h3 id="连接-MySQL"><a href="#连接-MySQL" class="headerlink" title="连接 MySQL"></a>连接 MySQL</h3><p>安装过程中 <strong>Cloudera Manager</strong> 需要用到 <strong>mysql</strong> 服务，所以这里需要先提供好 <strong>mysql</strong> 资源。</p><p>首先，安装 <em>mysql-connector-java</em> 包，并链接到 <strong>CM</strong> 库：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有节点安装库</span></span><br><span class="line">apt-get install libmysql-java</span><br><span class="line"><span class="comment"># 链接 mysql 连接库到 cm 库中给平台使用</span></span><br><span class="line">ln -s /usr/share/java/mysql-connector-java.jar /opt/cm-5.13.0/share/cmf/lib/mysql-connector-java.jar</span><br></pre></td></tr></table></figure></div><p>然后，再创建 <strong>cm5</strong> 的数据库：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master节点</span></span><br><span class="line"><span class="built_in">cd</span> /opt/cm-5.13.0/share/cmf/schema</span><br><span class="line">./scm_prepare_database.sh mysql -uroot -p123456 scm scm scm <span class="comment"># 创建数据库</span></span><br></pre></td></tr></table></figure></div><h3 id="配置Agent"><a href="#配置Agent" class="headerlink" title="配置Agent"></a>配置Agent</h3><p>这个 <strong>Agent</strong> 实际上就是安装代理，分布式的每台机器安装过程中都会产生这个进程，那这些 <strong>Agent</strong> 由谁来操控，通常是由 <strong>master</strong> 节点进行管理操作，所以要先将配置文件的管理这指向 <strong>master</strong>.</p><p>首先，修改配置文件的 <strong>server</strong>, 指向 <strong>master</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master节点</span></span><br><span class="line">vi /opt/cm-5.13.0/etc/cloudera-scm-agent/config.ini </span><br><span class="line"><span class="comment"># 将 server_host 修改为 master</span></span><br><span class="line">server_host=master</span><br></pre></td></tr></table></figure></div><p>然后，同步 <strong>Agent</strong> 到 <strong>slave[1-3]</strong> 节点</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master节点上</span></span><br><span class="line">scp -r /opt/cm-5.13.0/ root@slave1:/opt/</span><br><span class="line">scp -r /opt/cm-5.13.0/ root@slave2:/opt/</span><br><span class="line">scp -r /opt/cm-5.13.0/ root@slave3:/opt/</span><br></pre></td></tr></table></figure></div><p>最后，为所有节点创建 <strong>cloudera-scm</strong> 用户</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line">useradd --system --home=/opt/cm-5.13.0/run/cloudera-scm-server/ --no-create-home --shell=/bin/<span class="literal">false</span> --comment <span class="string">"Cloudera SCM User"</span> cloudera-scm</span><br></pre></td></tr></table></figure></div><h3 id="配置-Parcels"><a href="#配置-Parcels" class="headerlink" title="配置 Parcels"></a>配置 Parcels</h3><p>要安装 <strong>CDH5</strong>, 我们需要配置 <strong>Parcels</strong>，这个是 <strong>Cloudera</strong> 给的安装包的镜像仓库地址，但是国内访问速度很慢，因此我们不使用在线安装，而是通过已经下载的 <strong>parcel</strong> 包，将其放置在下载镜像的目录，表示 <strong>parcel</strong> 包已经下载好了，这样就不会再联网下载了。</p><p>首先，在 <strong>master</strong> 节点，用下面命令创建文件夹</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master 节点</span></span><br><span class="line">mkdir -p /opt/cloudera/parcel-repo</span><br></pre></td></tr></table></figure></div><p>然后，传入三个文件：</p><ol><li><em>CDH-5.13.0-1.cdh5.13.0.p0.29-xenial.parcel</em>，</li><li><em>CDH-5.13.0-1.cdh5.13.0.p0.29-xenial.parcel.sha</em>，</li><li><em>manifest.json</em></li></ol><h3 id="启动-Server-和-Agent"><a href="#启动-Server-和-Agent" class="headerlink" title="启动 Server 和 Agent"></a>启动 Server 和 Agent</h3><p>在 <strong>master</strong> 节点启动 <strong>Server</strong> 进程</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master 节点</span></span><br><span class="line"><span class="built_in">cd</span> /opt/cm-5.13.0/etc/init.d</span><br><span class="line">./cloudera-scm-server start</span><br></pre></td></tr></table></figure></div><p>在所有节点启动 <strong>Agent</strong> 进程</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/cm-5.13.0/etc/init.d</span><br><span class="line">./cloudera-scm-agent start</span><br></pre></td></tr></table></figure></div><p>这里假如大家有错误，可以查看对应进程的日志：</p><blockquote><p>Server 进程 log 日志文件：</p><p><em>/opt/cm-5.13.0/log/cloudera-scm-server/cloudera-scm-server.log</em></p><p>Agent 进程 log 日志文件：</p><p><em>/opt/cm-5.13.0/log/cloudera-scm-agent/cloudera-scm-agent.log</em>,</p><p>如果没有 .log 文件，可以试试 .out 文件</p></blockquote><h2 id="正式部署–可视化集群配置"><a href="#正式部署–可视化集群配置" class="headerlink" title="正式部署–可视化集群配置"></a>正式部署–可视化集群配置</h2><hr><p>等待 Cloudera Manager <strong>Server</strong> 和 <strong>Agent</strong> 启动完毕后，就可以进行 <strong>CDH5</strong> 的可视化界面安装了，在浏览器打开 <a href="http://master:7180" target="_blank" rel="noopener">http://master:7180</a>, 注意，如果这是在 <strong>master, slave[1-3]</strong> 主机上时可以直接在浏览器里输入这个 url, 但如果 <strong>不在 master 和 slave[1-3]</strong> 节点上访问此 url，则需要修改主机的 <strong>hosts</strong> 文件，修改方法见 <em>正式部署环境配置</em> 中的 <strong>hosts</strong> 配置。</p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>默认用户名和密码都是：<em>admin</em></p><p><img src="http://img.godjiyi.cn/cloudera01.jpg" alt></p><h3 id="同意条款"><a href="#同意条款" class="headerlink" title="同意条款"></a>同意条款</h3><p><img src="http://img.godjiyi.cn/cloudera02.jpg" alt></p><h3 id="选择版本"><a href="#选择版本" class="headerlink" title="选择版本"></a>选择版本</h3><p>选择中间的试用版本，肯定要体验最全的功能</p><p><img src="http://img.godjiyi.cn/cloudera03.jpg" alt> </p><h3 id="选择集群机器"><a href="#选择集群机器" class="headerlink" title="选择集群机器"></a>选择集群机器</h3><p>这里只显示启动了Agent进程的主机</p><p><img src="http://img.godjiyi.cn/cloudera05.jpg" alt></p><h3 id="选择集群安装方式"><a href="#选择集群安装方式" class="headerlink" title="选择集群安装方式"></a>选择集群安装方式</h3><p>这里选择 <strong>Parcel</strong>, 我们之前已经把离线包下载好并放在了 <strong>master</strong> 的仓库目录下，因此这里直接显示了我们已经下载的 <strong>CDH5</strong></p><p><img src="http://img.godjiyi.cn/cloudera06.jpg" alt></p><h3 id="分发-Parcel-包到各个结点"><a href="#分发-Parcel-包到各个结点" class="headerlink" title="分发 Parcel 包到各个结点"></a>分发 Parcel 包到各个结点</h3><p>这里自动由 <strong>master</strong> 将 <strong>CDH</strong> 包分发到 <strong>slave[1-3]</strong></p><p><img src="http://img.godjiyi.cn/cloudera07.jpg" alt></p><h3 id="检测安装环境"><a href="#检测安装环境" class="headerlink" title="检测安装环境"></a>检测安装环境</h3><p>这里出现下面警告，通过在所有主机上执行 <code>echo 10 &gt; /proc/sys/vm/swappiness</code>, 然后再重新检测下环境即可</p><p><img src="http://img.godjiyi.cn/cloudera08.jpg" alt></p><p><img src="http://img.godjiyi.cn/cloudera09.jpg" alt></p><h3 id="选择安装服务"><a href="#选择安装服务" class="headerlink" title="选择安装服务"></a>选择安装服务</h3><p>这里我就选择核心服务，因为后面管理界面可以任意 <em>增加、删除</em> 各个服务。</p><p><img src="http://img.godjiyi.cn/cloudera10.jpg" alt></p><h3 id="角色配置"><a href="#角色配置" class="headerlink" title="角色配置"></a>角色配置</h3><p>这里默认即可</p><p><img src="http://img.godjiyi.cn/cloudera11.jpg" alt></p><h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><p>这里是最重要也是最容易出错的地方，配置数据库前，需要先创建数据库,我们只需要在 <strong>master</strong> 主机上创建，这里主要需要创建 <em>四个数据库 ( hive, rman, ozzie, hue )</em> 和 <em>四个用户名 ( hive, rman, ozzie, hue )</em>.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master主机</span></span><br><span class="line">mysql -u root -p <span class="comment"># 连接mysql数据库</span></span><br><span class="line"><span class="comment"># 创建四个数据</span></span><br><span class="line">create database hive DEFAULT CHARSET utf8; </span><br><span class="line">create database rman DEFAULT CHARSET utf8;</span><br><span class="line">create database oozie DEFAULT CHARSET utf8;</span><br><span class="line">create database hue DEFAULT CHARSET utf8;</span><br><span class="line"><span class="comment"># 创建四个用户名</span></span><br><span class="line">grant all on hive.* TO <span class="string">'hive'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'123456'</span>;</span><br><span class="line">grant all on rman.* TO <span class="string">'rman'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'123456'</span>;</span><br><span class="line">grant all on oozie.* TO <span class="string">'oozie'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'123456'</span>;</span><br><span class="line">grant all on hue.* TO <span class="string">'hue'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure></div><p>此外，这里还常常出现 <strong>Hue</strong> 测试连接数据库时失败，这种情况是因为 <em>依赖包</em> 没有安装，这里给出我测试成功需要的依赖包，更详细的依赖包查看 <a href="https://www.cloudera.com/documentation/enterprise/5-9-x/topics/cm_ig_install_path_c.html" target="_blank" rel="noopener">官网的 Install Package Dependencies 说明</a>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅master主机</span></span><br><span class="line">apt-get install python-mysqldb</span><br><span class="line">apt-get install libxslt1.1</span><br><span class="line">apt-get install apache2</span><br><span class="line">apt-get install libssl-dev</span><br></pre></td></tr></table></figure></div><p>然后，点击 <em>测试连接</em>，成功后进行下一步</p><p><img src="http://img.godjiyi.cn/cloudera13.jpg" alt></p><h3 id="进行安装"><a href="#进行安装" class="headerlink" title="进行安装"></a>进行安装</h3><p><img src="http://img.godjiyi.cn/cloudera14.jpg" alt></p><h3 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功"></a>安装成功</h3><p><img src="http://img.godjiyi.cn/cloudera15.jpg" alt></p><h3 id="集群界面"><a href="#集群界面" class="headerlink" title="集群界面"></a>集群界面</h3><p><img src="http://img.godjiyi.cn/cloudera16.jpg" alt></p><h3 id="添加服务"><a href="#添加服务" class="headerlink" title="添加服务"></a>添加服务</h3><p>点击 <em>集群右侧倒三角，选择添加服务</em></p><p><img src="http://img.godjiyi.cn/cloudera17.jpg" alt></p><p>出现服务选择界面，自己根据需求选择 <em>Hadoop 生态中的应用</em>：</p><p><img src="http://img.godjiyi.cn/cloudera18.jpg" alt></p><h3 id="添加主机到集群"><a href="#添加主机到集群" class="headerlink" title="添加主机到集群"></a>添加主机到集群</h3><p>点击菜单栏上的 <em>主机–所有主机</em></p><p><img src="http://img.godjiyi.cn/cloudera19.jpg" alt></p><p>会看到当前集群的所有主机列表，点击右上角的 <em>向集群添加新主机</em></p><p><img src="http://img.godjiyi.cn/cloudera20.jpg" alt></p><p>进入添加主机流程，大家一步一步下一步安装即可</p><p><img src="http://img.godjiyi.cn/cloudera21.jpg" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cloudera.com/documentation/enterprise/5-9-x/topics/cm_ig_install_path_c.html" target="_blank" rel="noopener">Installation Path C - Manual Installation Using Cloudera Manager Tarballs</a></li><li><a href="https://christchen.me/archives/217.html" target="_blank" rel="noopener">CDH-5.12.0 分布式集群的离线部署</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot; style=&quot;margin: 30px 0 35px;&quot;&gt;企业大数据开源平台，从部署迈出第一步&lt;/p&gt;

&lt;p&gt;最近应项目公司需求，我们需要为其构建一个大数据平台。&lt;strong&gt;开源的Hadoop生态应用&lt;/strong&gt; 由于没有技术服务支持，公司不采用此种方案进行构建。因此我们选择采购具有技术支持的 &lt;strong&gt;第三方大数据平台&lt;/strong&gt;，当然这些公司的平台也完全基于 &lt;strong&gt;Hadoop&lt;/strong&gt;, 只不过他们有着一帮技术团队，可以为自己平台出现的问题提供技术服务。&lt;/p&gt;
&lt;p&gt;第三方平台目前我们所接触了解的有四家：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cloudera.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cloudera&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.transwarp.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;星环科技&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;华为&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阿里&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而由于 &lt;strong&gt;Cloudera&lt;/strong&gt; 提供了开源免费版本的产品，因此这篇博客主要对 &lt;strong&gt;Cloudera&lt;/strong&gt; 公司产品的部署过程进行记录。&lt;/p&gt;
&lt;h2 id=&quot;简要介绍&quot;&gt;&lt;a href=&quot;#简要介绍&quot; class=&quot;headerlink&quot; title=&quot;简要介绍&quot;&gt;&lt;/a&gt;简要介绍&lt;/h2&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Cloudera&lt;/strong&gt;: Cloudera 公司目前是世界上最大的大数据平台提供商，其总部位于美国，且已经上市，2014进入中国市场，Hadoop 创始人 &lt;strong&gt;Doug Cutting&lt;/strong&gt; 目前也就职于Cloudera，担任首席架构师，其内部有很多开源项目的 &lt;strong&gt;Committer&lt;/strong&gt;，相比其他公司，其技术水平有着绝对的优势。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CDH&lt;/strong&gt;: Cloudera 公司目前主要的产品是 &lt;strong&gt;CDH&lt;/strong&gt; ( &lt;em&gt;Cloudera’s Distribution including Apache Hadoop&lt;/em&gt; ),是对 &lt;strong&gt;Hadoop 生态&lt;/strong&gt;( hadoop + hive, hbase, flume, impala 等等)的一种封装融合，该产品是 &lt;strong&gt;完全免费下载和安装&lt;/strong&gt; 的，其盈利方式是技术支持服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cloudera Manager&lt;/strong&gt;: 由于大数据平台本身就是分布式，CDH 自然也不例外，为了便于用户快捷安装，Cloudera 公司提供了 &lt;strong&gt;Cloudera Manager&lt;/strong&gt; 工具，可让用户在可视化的页面上组织自己的集群。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;部署方式&lt;/strong&gt;：首先，Cloudera 公司提供了产品的&lt;a href=&quot;https://www.cloudera.com/downloads/quickstart_vms/5-12.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;尝鲜版本&lt;/a&gt;，主要提供了&lt;strong&gt;Virtual Box、VMWare、KVM、Docker Image&lt;/strong&gt; 等虚拟镜像，为了体验产品的用户可以尝试。此外，&lt;strong&gt;Cloudera&lt;/strong&gt; 提供正式版本的&lt;a href=&quot;https://www.cloudera.com/documentation/enterprise/latest/topics/installation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安装说明&lt;/a&gt;,下面就按照正式版本正式生产环境进行安装部署。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Hadoop" scheme="https://www.godjiyi.cn/categories/Hadoop/"/>
    
    
      <category term="Linux" scheme="https://www.godjiyi.cn/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://www.godjiyi.cn/tags/Ubuntu/"/>
    
      <category term="大数据" scheme="https://www.godjiyi.cn/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="https://www.godjiyi.cn/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>MacOS 下多 Python 版本说明</title>
    <link href="https://www.godjiyi.cn/2017/10/31/python_environmet/"/>
    <id>https://www.godjiyi.cn/2017/10/31/python_environmet/</id>
    <published>2017-10-31T14:16:40.000Z</published>
    <updated>2018-09-18T12:36:05.490Z</updated>
    
    <content type="html"><![CDATA[<p align="center" style="margin: 30px 0 35px;">好的配置环境是保证产能的前提</p><p>应大数据和机器学习的要求，对处理数据的计算机语言需求越来大，之前虽然弄过 <strong>Python</strong> 环境，但是没有彻底搞清楚 <strong>Python</strong> 多版本执行程序以及多版本的模块位置，导致自己电脑上环境紊乱，今天花了点功夫解决下。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><hr><p>我的电脑是 <strong>MacOS</strong> 系统，并且 <strong>MacOS</strong> 系统是自带了 <strong>Python</strong>，而之前在捣鼓 <strong>Python</strong> 时，可能后装了很多次不同的版本，导致在我电脑上的的 <strong>Python</strong> 有诸多问题，这里主要说明以下几个问题：</p><ol><li><strong>多版本 Python 的安装路径识别</strong></li><li><strong>多版本 Python 对应的 pip 命令识别</strong></li><li><strong>多版本 Python 对应的 pip 安装模块位置确定</strong></li></ol><a id="more"></a><h3 id="安装路径识别"><a href="#安装路径识别" class="headerlink" title="安装路径识别"></a>安装路径识别</h3><p><strong>Python</strong> 现在分为两个版本 <em>2.X 版本</em> 和 <em>3.X 版本</em>，两代版本并不能够完全兼容，因此两个版本的模块包也会分开安装的，因此完全把握两种版本环境是很有必要的。</p><p><strong>Python 2.X版本</strong></p><p>此版本对应旧版本，其默认执行命令是 <code>python</code>, 因此我们在终端输入 <code>python --version</code> 通常会显示 2.X 的版本字样。</p><p>通过 <code>which python</code> 命令查看 <strong>Python</strong> 路径，然后用 <code>ls -l</code> 可查看该路径的 <strong>Python</strong> 执行文件属性如下：</p><p><img src="http://img.godjiyi.cn/pyset1.jpg" alt></p><p>上图显示 <strong>/usr/bin/python</strong> 文件非软链接文件，由于我们自己安装的 <strong>Python</strong> 通常是用软链接的方式链接到安装目录，因此这里的 <strong>python</strong> 应该属于本机自带的 <strong>Python</strong>, 其安装位置即为 <strong>/usr/bin/python</strong>.</p><p><strong>Python 3.X版本</strong></p><p>此版本对应新版本，其默认执行命令是 <code>python3</code>, 不是完全兼容旧版本的，但是代表了 <strong>Python</strong> 的发展方向，新人的话建议直接学习此版本。</p><p>通过 <code>which python3</code> 命令查看 <strong>Python3</strong> 路径，然后用 <code>ls -l</code> 查看路径的的文件属性：</p><p><img src="http://img.godjiyi.cn/pyset2.jpg" alt></p><p>上图显示 <strong>/usr/local/bin/python3</strong> 文件为软链接文件，链接的源位置为 <strong>/Library/Frameworks/Python.framework/Versions/3.5/bin/python3</strong>, 因此这就是 <strong>Python3</strong> 的安装位置，由此也可以知道当前 <strong>Python3</strong> 的版本是 <strong>3.5</strong>.</p><p>实际上系统自带的命令通常安装在 <strong>/usr/bin/</strong> 目录下，而用户自己安装的命令通常在 <strong>/usr/local/bin/</strong> 目录下，这通常是因为普通安装命令都是在 <strong>/usr/local/bin/</strong> 下有写的权限的。</p><h3 id="pip-命令识别"><a href="#pip-命令识别" class="headerlink" title="pip 命令识别"></a>pip 命令识别</h3><p><strong>Python</strong> 版本的不同导致 <strong>Python</strong> 下的包管理工具 <strong>pip</strong> 命令也不同，因此使得 <strong>pip</strong> 命令也产生很多的 <em>pipX</em> 命令。通常而言，对于 <strong>Python2x</strong> 版本其对应的 <strong>pip</strong> 命令为 <em>pip</em>, 而对于 <strong>Python3.X</strong> 版本其对应的 <strong>pip</strong> 命令为<em>pip3</em>. 此外，还有一种可同时执行不同版本 <strong>Python</strong> 的 <strong>pip</strong> 方式：<em>python -m pip install xxx</em> 或者 <em>python3 -m pip install xxx</em>, 这就不需要用不同的命令了，但是前提还是需要摸清自己本机的环境。</p><p><strong>Python2.X 版本的 pip</strong></p><p>通过 <code>which pip</code> 查看 <strong>pip</strong> 路径，然后用 <code>ll</code> 查看文件属性，该文件为非链接文件，其与上面的 <strong>Python</strong> 相对应</p><p><img src="http://img.godjiyi.cn/pyset3.jpg" alt></p><p>我们也可以通过命令来查看 <strong>pip</strong> 目录中有哪些 <code>pip</code>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /usr/<span class="built_in">local</span>/bin | grep pip</span><br></pre></td></tr></table></figure></div><p>结果：</p><p><img src="http://img.godjiyi.cn/pyset4.jpg" alt></p><p>我们看到上图有好多 <code>pip</code> 命令，到底哪些可用或者一致呢？我们可以看这些命令的 <strong>创建时间</strong> 基本可以判断前三个 <code>pip</code> 是同一时刻安装的，最后一个是另外时间安装的 <code>pip</code> 工具，我们可以通过 <code>pip</code> 命令安装一个已经存在的模块查看其已经安装的模块路径如下图，我们可以知道 <em>pip, pip2, pip2.7</em> 都是 <em>Python2.X 版本的</em> <code>python</code> 命令所对应的 <code>pip</code>.</p><p><img src="http://img.godjiyi.cn/pyset5.jpg" alt></p><p><strong>Python3.X 版本的 pip3</strong></p><p>通过 <code>which pip3</code>查看 <strong>pip</strong> 路径，然后用 <code>ll</code> 查看文件属性如下图，然而，<code>pip3</code> 并没有此命令，但我们从之前的查看命令可知存在 <code>pip3.5</code> 命令</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /usr/<span class="built_in">local</span>/bin | grep pip</span><br></pre></td></tr></table></figure></div><p>再次执行 <code>which pip3.5</code>，情况如下：</p><p><img src="http://img.godjiyi.cn/pyset7.jpg" alt></p><p>我们天真地以为 <code>pip3.5</code> 命令就是我们 <strong>Python3.X 版本的</strong> <code>pip</code>，我们执行安装命令试试 <code>pip3.5 install numpy</code>，结果如下：</p><p><img src="http://img.godjiyi.cn/pyset9.jpg" alt></p><p>执行报错，这错误网上有解决方法 <a href="http://blog.chinaunix.net/uid-20940095-id-4304535.html" target="_blank" rel="noopener">这里</a>, 但是我们这里不确定此 <strong>Python3.5</strong> 是否关联我们本机的 <strong>Python3</strong>，因为这有可能是自己以前安装了 <strong>Python3.5</strong> 又卸载后存留的。这里我们再试试另外一种可能，<em>就是本机 Python3 的 pip 在另外地方，只不过它没有在环境变量中</em>，我们可以如下测试 <code>python3 -m pip --version</code>, 我们也可以尝试安装一个包，如图，可以确定通过 <strong>Python3</strong> 内部的 <strong>pip</strong> 可以将模块安装在内部目录里。</p><p><img src="http://img.godjiyi.cn/pyset10.jpg" alt></p><p>至此可以确定，<strong>Python3</strong> 对应的 <code>pip</code> 在自己安装路径内部，而不通过环境变量直接定位，需要通过 <code>python3 -m pip install xxxx</code> 来安装模块。</p><h3 id="pip模块安装路径确定"><a href="#pip模块安装路径确定" class="headerlink" title="pip模块安装路径确定"></a>pip模块安装路径确定</h3><p>到这里我想大家已经知道如何确定 <strong>pip</strong> 模块的安装位置了，主要要首先确定 <strong>Python</strong> 各个版本对应的 <strong>pip</strong>，然后通过 <strong>pip</strong> 的重复安装即可确定模块安装位置。</p><blockquote><p>注意：下面的安装位置仅仅是我自己系统上的环境位置，并非适用你自己的环境，需要自己确定自己的 <strong>Python</strong> 版本和 <strong>pip</strong> 版本</p></blockquote><p><em>Python2.X版本的模块位置</em>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure></div><p><em>Python3.X版本的模块位置</em>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install numpy</span><br></pre></td></tr></table></figure></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Python2.X</strong>:</p><p>执行路径: <strong>/usr/bin/python</strong></p><p>pip 路径: <strong>/usr/local/bin/pip</strong>, <strong>/usr/local/bin/pip2</strong>, <strong>/usr/local/bin/pip2.7</strong></p><p>模块位置:<strong>/usr/local/lib/python2.7/site-packages</strong></p><p><strong>Python3.X</strong>:</p><p>执行路径: <strong>/Library/Frameworks/Python.framework/Versions/3.5/bin/python3</strong></p><p>pip 路径: <strong>/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/pip-9.0.1-py3.5.egg</strong></p><p>模块位置: <strong>/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages</strong></p><p><strong>Python</strong> 存在不统一路径查找的原因：</p><p><em>(1). 通过 pkg 安装包</em>: Python 官网 <a href="https://www.python.org/downloads/" target="_blank" rel="noopener">https://www.python.org/downloads/</a>, 下载后文件为 <strong>python-3.6.3-macosx10.6.pkg</strong> 形式的文件，这种文件可直接双击安装，其安装的位置通常在 <strong>/Library/Frameworks</strong> 下。</p><p><em>(2). 通过 homebrew 安装</em>: Homebrew 官网 <a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a>, 其安装方式为:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install python <span class="comment"># 安装python2.X</span></span><br><span class="line">brew install python3 <span class="comment"># 安装python3.X</span></span><br></pre></td></tr></table></figure></div><p>这种方式安装是先将包下载在 <strong>/usr/local/Cellar</strong> 目录下，然后自动在 <strong>/usr/local/bin/</strong> 下新建一个执行链接到 <strong>/usr/local/Cellar</strong>.</p><p>如：我们安装一个wget 工具：<code>brew install wget</code>，然后我们可以查看<em>wget</em>的原路径：</p><p><img src="http://img.godjiyi.cn/pyset11.jpg" alt></p><p>对于安装用 <strong>brew</strong> 安装 <strong>Python3</strong>，其也会自动下载对应的 <strong>pip3</strong> 的，并且都会将其放置在 <strong>/usr/local/bin/目录下</strong>，以软链接的形式链接到 <strong>/usr/local/Cellar下的对应文件</strong>.</p><p><em>(3). 通过源码包</em>: 这会自动放置在 <strong>/usr/local/bin</strong> 目录下，且不会用软链接。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.jianshu.com/p/51811fa24752/" target="_blank" rel="noopener">MacO S安装 Python2X 和 Python3</a></li><li><a href="https://www.zhihu.com/question/21653286/answer/95532074" target="_blank" rel="noopener">同时装了 Python3 和 Python2，怎么用 pip</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot; style=&quot;margin: 30px 0 35px;&quot;&gt;好的配置环境是保证产能的前提&lt;/p&gt;

&lt;p&gt;应大数据和机器学习的要求，对处理数据的计算机语言需求越来大，之前虽然弄过 &lt;strong&gt;Python&lt;/strong&gt; 环境，但是没有彻底搞清楚 &lt;strong&gt;Python&lt;/strong&gt; 多版本执行程序以及多版本的模块位置，导致自己电脑上环境紊乱，今天花了点功夫解决下。&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;我的电脑是 &lt;strong&gt;MacOS&lt;/strong&gt; 系统，并且 &lt;strong&gt;MacOS&lt;/strong&gt; 系统是自带了 &lt;strong&gt;Python&lt;/strong&gt;，而之前在捣鼓 &lt;strong&gt;Python&lt;/strong&gt; 时，可能后装了很多次不同的版本，导致在我电脑上的的 &lt;strong&gt;Python&lt;/strong&gt; 有诸多问题，这里主要说明以下几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;多版本 Python 的安装路径识别&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多版本 Python 对应的 pip 命令识别&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多版本 Python 对应的 pip 安装模块位置确定&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://www.godjiyi.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.godjiyi.cn/tags/Python/"/>
    
      <category term="MacOS" scheme="https://www.godjiyi.cn/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>博客界面更新</title>
    <link href="https://www.godjiyi.cn/2017/10/06/picture-group/"/>
    <id>https://www.godjiyi.cn/2017/10/06/picture-group/</id>
    <published>2017-10-06T09:57:23.000Z</published>
    <updated>2018-09-18T12:35:58.610Z</updated>
    
    <content type="html"><![CDATA[<p><strong>博客界面更新，应用个性化 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next</a> 主题</strong></p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="http://img.godjiyi.cn/nextpicdd.jpg" alt></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://img.godjiyi.cn/nextpicee.jpg" alt></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://img.godjiyi.cn/nextpica.jpg" alt></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://img.godjiyi.cn/nextpicf.jpg" alt></div></div></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;博客界面更新，应用个性化 &lt;a href=&quot;https://github.com/theme-next/hexo-theme-next&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Next&lt;/a&gt; 主题&lt;/strong&gt;&lt;/p&gt;
&lt;div
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://www.godjiyi.cn/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="https://www.godjiyi.cn/tags/Hexo/"/>
    
      <category term="Next" scheme="https://www.godjiyi.cn/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 界面美化</title>
    <link href="https://www.godjiyi.cn/2017/08/06/ubuntu-beauty/"/>
    <id>https://www.godjiyi.cn/2017/08/06/ubuntu-beauty/</id>
    <published>2017-08-06T14:00:40.000Z</published>
    <updated>2018-09-18T12:36:49.280Z</updated>
    
    <content type="html"><![CDATA[<p align="center" style="margin: 30px 0 35px;">如果美不是与生俱来的，于是就有了美容医院</p><p>最近重新把老旧的台式机拿来耍，重新安装了 <strong>Ubuntu 16.04</strong>,但感觉自带的桌面效果不是很好，于是就查找网上的优化博客按套路来整合，这里记录下自己的实现过程。</p><p>先看下效果</p><p><img src="http://img.godjiyi.cn/ubuntu-1.png" alt="desktop"></p><a id="more"></a><p><img src="http://img.godjiyi.cn/ubuntu-5.png" alt="workspace"></p><h2 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h2><p>主要对系统默认的设置进行一些配置优化,我推荐系统语言为英语，但是可以安装中文输入法。</p><h3 id="一、选择软件源"><a href="#一、选择软件源" class="headerlink" title="一、选择软件源"></a>一、选择软件源</h3><p><strong>System Setting(系统设置)–&gt;Software &amp; Updates(软件更新)–&gt;Ubuntu Software(ubuntu软件)–&gt;Download from(下载源)</strong></p><p><img src="http://img.godjiyi.cn/ubuntu-06.jpg" alt="源设置"></p><ul><li><em>上图的 3</em>: 系统会根据所有服务器的延迟自动选择最快的服务器</li><li><em>上图的 4</em>: 为中国区的一些服务器，大家可以根据自身喜好选择自己喜欢的服务器镜像</li></ul><p>设置好源后最好进行一次源更新：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update <span class="comment">#更新源</span></span><br></pre></td></tr></table></figure></div><h3 id="二、删除软件"><a href="#二、删除软件" class="headerlink" title="二、删除软件"></a>二、删除软件</h3><p>这个根据自身需要选择进行删除，而不要一味地执行这些命令。</p><p><strong>卸载LibreOffice</strong>:</p><p>我建议还是留着，因为即使是国内的 <strong>wps</strong> 在 <strong>Linux</strong> 上的支持也有很多 <strong>Bug</strong> 的，而这套软件则是专门配到 <strong>Linux</strong> 的，所以我建议留着。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove libreoffice-common</span><br></pre></td></tr></table></figure></div><p>如果大家没注意删除了该软件，也可以通过 <strong>Ubuntu</strong> 的软件中心搜索 <strong>LibreOffice</strong> 进行重新下载。</p><p><strong>删除 Amazon</strong>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove unity-webapps-common</span><br></pre></td></tr></table></figure></div><p><strong>删除不常用软件 ( 源自网络 )</strong>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot </span><br><span class="line">sudo apt-get remove gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku  landscape-client-ui-install  </span><br><span class="line">sudo apt-get remove onboard deja-dup</span><br></pre></td></tr></table></figure></div><p><strong>更新源与软件</strong>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update <span class="comment">#更新源</span></span><br><span class="line">sudo apt-get upgrade <span class="comment">#更新所有软件版本到源版本</span></span><br></pre></td></tr></table></figure></div><h3 id="三、安装中文输入法"><a href="#三、安装中文输入法" class="headerlink" title="三、安装中文输入法"></a>三、安装中文输入法</h3><p><strong>System Setting(系统设置) –&gt; Language Support(语言支持) –&gt; Language(语言版块) –&gt; Install/Remove Languages(安装添加语言包) –&gt; Chinese(simplified)[中文(简体中文)] –&gt; Apply(应用)</strong></p><h4 id="添加中文语言包"><a href="#添加中文语言包" class="headerlink" title="添加中文语言包"></a>添加中文语言包</h4><p><img src="http://img.godjiyi.cn/ubuntu-07.jpg" alt="添加中文语言包"></p><h4 id="Ibus框架输入法"><a href="#Ibus框架输入法" class="headerlink" title="Ibus框架输入法"></a>Ibus框架输入法</h4><p>安装 <strong>ibush</strong> 框架：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ibus ibus-clutter ibus-gtk ibus-gtk3 ibus-qt4</span><br></pre></td></tr></table></figure></div><p>启动 <strong>ibus</strong> 框架：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo im-switch -s ibus <span class="comment">#早期版本</span></span><br><span class="line">sudo im-config -s ibus <span class="comment">#较新版本</span></span><br></pre></td></tr></table></figure></div><p>重启或者注销，以使之生效</p><p>安装拼音引擎( 下面可任选 )：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ibus-sunpinyin <span class="comment">#sun拼音</span></span><br><span class="line">sudo apt-get install ibus-pinyin <span class="comment">#简单拼音</span></span><br><span class="line">sudo apt-get install ibus-googlepinyin <span class="comment">#谷歌拼音</span></span><br><span class="line">sudo apt-get install ibus-table-wubi <span class="comment">#五笔输入引擎</span></span><br></pre></td></tr></table></figure></div><p>设置ibus框架：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibus-setup <span class="comment">#调出ibus设置界面</span></span><br></pre></td></tr></table></figure></div><p><img src="http://img.godjiyi.cn/ibus-set.jpg" alt="ibus设置界面"></p><p>配置系统输入法：</p><p><em>System Setting(系统设置) –&gt; Text Entry(输入法)</em></p><p><img src="http://img.godjiyi.cn/text-entry.jpg" alt="Text Entry设置"></p><h4 id="Fcitx-框架输入法"><a href="#Fcitx-框架输入法" class="headerlink" title="Fcitx 框架输入法"></a>Fcitx 框架输入法</h4><p>安装 <strong>Fcitx</strong> 框架：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install fcitx</span><br></pre></td></tr></table></figure></div><p>安装 <strong>Fcitx</strong> 的配置工具：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install fcitx-config-gtk</span><br></pre></td></tr></table></figure></div><p>安装输入法引擎：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install fcitx-sunpinyin <span class="comment">#sun拼音</span></span><br><span class="line">sudo apt-get install fcitx-pinyin    <span class="comment">#简单拼音</span></span><br><span class="line">sudo apt-get install fcitx-googlepinyin <span class="comment">#谷歌拼音</span></span><br><span class="line">sudo apt-get install fcitx-table-wbpy  <span class="comment">#五笔输入</span></span><br></pre></td></tr></table></figure></div><p>设置系统输入法框架：</p><p><img src="http://img.godjiyi.cn/ubuntu-08.jpg" alt="fcitx框架"></p><p>重启或者注销，以使之生效</p><p>配置系统输入法：</p><p><em>System Setting(系统设置) –&gt; Text Entry(输入法)</em></p><p><img src="http://img.godjiyi.cn/ubuntu-09.jpg" alt="选择源"><br><img src="http://img.godjiyi.cn/ubuntu-10.jpg" alt="添加输入法"></p><p>添加搜狗输入法：</p><p>下载地址:<a href="http://pinyin.sogou.com/linux/" target="_blank" rel="noopener">http://pinyin.sogou.com/linux/</a></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i sogoupinyin_2.1.0.0086_amd64.deb <span class="comment">#后面名称替换为自己</span></span><br></pre></td></tr></table></figure></div><h2 id="系统美化"><a href="#系统美化" class="headerlink" title="系统美化"></a>系统美化</h2><p>主要安装主题、字体、图标、软件来进行风格的设置，整体软件的配置也会增加系统的美观性</p><p><img src="http://img.godjiyi.cn/ubuntu-1.png" alt="desktop"></p><h3 id="一、主题工具"><a href="#一、主题工具" class="headerlink" title="一、主题工具"></a>一、主题工具</h3><h4 id="unity-tweak-tool"><a href="#unity-tweak-tool" class="headerlink" title="unity-tweak-tool"></a>unity-tweak-tool</h4><p>github地址:<a href="https://github.com/freyja-dev/unity-tweak-tool" target="_blank" rel="noopener">https://github.com/freyja-dev/unity-tweak-tool</a></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install unity-tweak-tool</span><br></pre></td></tr></table></figure></div><p>安装后在搜索中搜索unity-tweak-tool,点击打开，界面如下:</p><p><img src="http://img.godjiyi.cn/ubuntu-11.jpg" alt="unity-tweak-tool"></p><h4 id="Flatabulous-主题安装"><a href="#Flatabulous-主题安装" class="headerlink" title="Flatabulous 主题安装"></a>Flatabulous 主题安装</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:noobslab/themes</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install flatabulous-theme</span><br></pre></td></tr></table></figure></div><h4 id="ultra-flat-icons-图标安装"><a href="#ultra-flat-icons-图标安装" class="headerlink" title="ultra-flat-icons 图标安装"></a>ultra-flat-icons 图标安装</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:noobslab/icons</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ultra-flat-icons</span><br></pre></td></tr></table></figure></div><h4 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h4><p>打开 <strong>unity-tweak-tool</strong>, 选择 <strong>Appearance</strong> ( 外观 ) 下的 <strong>Theme</strong> ( 主题 ):</p><p><img src="http://img.godjiyi.cn/ubuntu-14.jpg" alt></p><p>主题选择:</p><p><img src="http://img.godjiyi.cn/ubuntu-12.jpg" alt="Flatabulous主题"></p><p>图标选择:</p><p><img src="http://img.godjiyi.cn/ubuntu-13.jpg" alt="ultra-flat"></p><h4 id="爱壁纸"><a href="#爱壁纸" class="headerlink" title="爱壁纸"></a>爱壁纸</h4><p>官网地址:<a href="http://www.lovebizhi.com/linux.html" target="_blank" rel="noopener">http://www.lovebizhi.com/linux.html</a></p><p>推荐下载 deb 版的软件包，因为我们可以安装一个便捷的 deb 安装管理器 – <strong>GDebi 安装器</strong></p><p>大家可以在ubuntu软件中心下载也可以用以下命令安装:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gdebi</span><br></pre></td></tr></table></figure></div><p>这样在右击deb包的时候，选择 <em>Open With–GDebi Package Installer</em>, 就可以直接帮你安装deb包的软件了。    </p><p>当然你可以不用此工具，直接用命令安装也可以的:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i LoveWallpaper4Linux.deb</span><br></pre></td></tr></table></figure></div><p>安装好后，在搜索中搜索 <strong>Love</strong>，打开爱壁纸界面:</p><p><img src="http://img.godjiyi.cn/ubuntu-15.jpg" alt="爱壁纸"></p><h3 id="二、开发工具"><a href="#二、开发工具" class="headerlink" title="二、开发工具"></a>二、开发工具</h3><p><strong>git</strong> 工具：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></div><p><strong>vim</strong> 工具：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure></div><p><strong>sublime3</strong>:</p><p>安装:<a href="http://www.sublimetext.com/docs/3/linux_repositories.html" target="_blank" rel="noopener">官方说明</a></p><p><strong>zsh+oh-my-zsh</strong>:</p><p>项目地址:<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a></p><p>安装 <strong>zsh</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zsh</span><br></pre></td></tr></table></figure></div><p>修改系统默认为 <strong>zsh</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></div><blockquote><p>若提示 <code>chsh: PAM: Authentication failure</code>, 请看 <a href="http://blog.csdn.net/shengzhu1/article/details/54590158" target="_blank" rel="noopener">这里</a></p></blockquote><p>安装 <strong>oh-my-zsh</strong>:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>"</span></span><br></pre></td></tr></table></figure></div><p>重新登录的默认 <strong>zsh</strong> 就交给 <strong>oh-my-zsh</strong> 管理了，我们用 <strong>oh-my-zsh</strong> 主要是使用其主题，因此我们可以修改配置文件 <code>~/.zshrc</code></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="comment">#将ZSH_THEME="robbyrussell",修改为如下:</span></span><br><span class="line">ZSH_THEME=<span class="string">"ys"</span></span><br></pre></td></tr></table></figure></div><p>最终效果：</p><p><img src="http://img.godjiyi.cn/ubuntu-3.png" alt="program"></p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><h3 id="桌面"><a href="#桌面" class="headerlink" title="桌面"></a>桌面</h3><p><img src="http://img.godjiyi.cn/ubuntu-1.png" alt="desktop"></p><h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p><img src="http://img.godjiyi.cn/ubuntu-2.png" alt="command"></p><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p><img src="http://img.godjiyi.cn/ubuntu-3.png" alt="program"></p><h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p><img src="http://img.godjiyi.cn/ubuntu-4.png" alt="window"></p><h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><p><img src="http://img.godjiyi.cn/ubuntu-5.png" alt="workspace"></p><h2 id="丰富的其他应用"><a href="#丰富的其他应用" class="headerlink" title="丰富的其他应用"></a>丰富的其他应用</h2><p>(1). 网易云音乐</p><p>下载地址:<a href="http://music.163.com/#/download" target="_blank" rel="noopener">http://music.163.com/#/download</a></p><p>(2). WPS文档工具</p><p>下载地址:<a href="http://community.wps.cn/download/" target="_blank" rel="noopener">http://community.wps.cn/download/</a></p><p>(3). Xmind</p><p>下载地址:<a href="http://www.xmindchina.net/xiazai.html" target="_blank" rel="noopener">http://www.xmindchina.net/xiazai.html</a></p><p>(4). 搜狗输入法</p><p>下载地址:<a href="http://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="noopener">http://pinyin.sogou.com/linux/?r=pinyin</a></p><p>(5). 爱壁纸</p><p>下载地址:<a href="http://www.lovebizhi.com/linux.html" target="_blank" rel="noopener">http://www.lovebizhi.com/linux.html</a></p><p>(6). 有道词典</p><p>下载地址:<a href="http://cidian.youdao.com/index-linux.html" target="_blank" rel="noopener">http://cidian.youdao.com/index-linux.html</a></p><p>(7). 为知笔记</p><p>下载地址:<a href="http://www.wiz.cn/wiznote-linux.html" target="_blank" rel="noopener">http://www.wiz.cn/wiznote-linux.html</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://jingyan.baidu.com/article/86f4a73e8f534637d752695e.html" target="_blank" rel="noopener">Ubuntu16.04下安装中文输入法</a></li><li><a href="http://blog.csdn.net/u013894834/article/details/60357071" target="_blank" rel="noopener">Ubuntu16.04安装搜狗输入法</a></li><li><a href="http://blog.csdn.net/wangweiqiang1325/article/details/53447123" target="_blank" rel="noopener">Ubuntu 16.04下的美化配置过程</a></li><li><a href="http://blog.csdn.net/terence1212/article/details/52270210" target="_blank" rel="noopener">ubuntu16.04主题美化和软件推荐</a></li><li><a href="https://www.zhihu.com/question/19811112?sort=created" target="_blank" rel="noopener">在Ubuntu上有什么必装的实用软件</a></li><li><a href="http://blog.csdn.net/shengzhu1/article/details/54590158" target="_blank" rel="noopener"> Ubuntu16.04LTS安装zsh+oh-my-zsh</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot; style=&quot;margin: 30px 0 35px;&quot;&gt;如果美不是与生俱来的，于是就有了美容医院&lt;/p&gt;

&lt;p&gt;最近重新把老旧的台式机拿来耍，重新安装了 &lt;strong&gt;Ubuntu 16.04&lt;/strong&gt;,但感觉自带的桌面效果不是很好，于是就查找网上的优化博客按套路来整合，这里记录下自己的实现过程。&lt;/p&gt;
&lt;p&gt;先看下效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.godjiyi.cn/ubuntu-1.png&quot; alt=&quot;desktop&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Ubuntu" scheme="https://www.godjiyi.cn/categories/Ubuntu/"/>
    
    
      <category term="Linux" scheme="https://www.godjiyi.cn/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://www.godjiyi.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Spring项目整合</title>
    <link href="https://www.godjiyi.cn/2017/07/24/spbootapi/"/>
    <id>https://www.godjiyi.cn/2017/07/24/spbootapi/</id>
    <published>2017-07-24T14:00:40.000Z</published>
    <updated>2018-09-18T12:36:31.480Z</updated>
    
    <content type="html"><![CDATA[<p align="center" style="margin: 30px 0 35px;">No Repeating, Just Coding</p><p>最近用 <code>Spring</code> 写后台较多，每次新建一个项目要从原来项目里拷贝很多配置文件，因此就想整合一个配置好的的基本项目架构。<code>Spring boot</code> 融合了 <code>tomcat</code>, 使用后爱不释手，因此主要基于 <strong>Spring boot + MVC</strong> 以及一些其他必要功能进行配置使用。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><hr><p>项目代码地址: <a href="https://github.com/jiyiren/SpbootApi" target="_blank" rel="noopener">https://github.com/jiyiren/SpbootApi</a></p><p>这个仓库主要是集成 <strong>Spring-boot, Spring-mvc, Mysql, Mybatis, C3p0, <a href="https://swagger.io/" target="_blank" rel="noopener">Swagger2</a></strong> 的项目架构,为便于每次新建项目不用从零开始,直接基于此项目结构可快速地进行项目二次开发，免去了 <strong>pom</strong> 内容的复制和配置文件的编写。</p><h3 id="整体项目结构"><a href="#整体项目结构" class="headerlink" title="整体项目结构"></a>整体项目结构</h3><p><img src="http://img.godjiyi.cn/spbootapi-arc.png" alt="项目结构"></p><a id="more"></a><h3 id="Swagger-API-UI-页面"><a href="#Swagger-API-UI-页面" class="headerlink" title="Swagger API UI 页面"></a>Swagger API UI 页面</h3><p>默认访问地址: <em><a href="http://127.0.0.1:8899/swagger-ui.html" target="_blank" rel="noopener">http://127.0.0.1:8899/swagger-ui.html</a></em></p><p><img src="http://img.godjiyi.cn/spbootapi-swaggerui.png" alt="SwaggerUi"></p><h3 id="Demo接口"><a href="#Demo接口" class="headerlink" title="Demo接口"></a>Demo接口</h3><p>测试接口: <em><a href="http://127.0.0.1:8899/user/1" target="_blank" rel="noopener">http://127.0.0.1:8899/user/1</a></em></p><p><img src="http://img.godjiyi.cn/spbootapi-json.png" alt="json"></p><h2 id="二次开发实践"><a href="#二次开发实践" class="headerlink" title="二次开发实践"></a>二次开发实践</h2><hr><p>下载项目:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/jiyiren/SpbootApi.git</span><br></pre></td></tr></table></figure></div><p>命令运行项目:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> SpbootApi</span><br><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure></div><p>IDE 运行项目 ( 推荐 Intellij IDEA ):</p><p>打开ApiApplication.class，内部包含main函数，右击 <code>Run ApiApplication</code>.</p><p>测试</p><p>访问:<a href="http://127.0.0.1:8899" target="_blank" rel="noopener">http://127.0.0.1:8899</a> 返回 <strong>Hello World!</strong></p><p>访问:<a href="http://127.0.0.1:8899/user/1" target="_blank" rel="noopener">http://127.0.0.1:8899/user/1</a> 返回 <strong>json</strong> 数据</p><p>修改包名(下面为包含包名的文件)</p><ul><li><em>resources/application.propertis</em> : 项目总配置文件</li><li><em>java/包名/Swagger2.class</em> : <strong>swagger-ui</strong> 配置文件</li><li><em>java/包名/c3p0/C3p0AutoConfiguration.class</em> : <strong>c3p0</strong> 连接池配置文件</li></ul><h2 id="POM依赖包"><a href="#POM依赖包" class="headerlink" title="POM依赖包"></a>POM依赖包</h2><hr><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--properties--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jacksonVersion</span>&gt;</span>2.8.8<span class="tag">&lt;/<span class="name">jacksonVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0Version</span>&gt;</span>0.9.5.2<span class="tag">&lt;/<span class="name">c3p0Version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- web --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jdbc--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--aop--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mysql包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jackson包 jackson-core,jackson-databind,jackson-annotations --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jacksonVersion&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- c3p0 和 mchange-commons-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;c3p0Version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- swagger --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.jianshu.com/p/8033ef83a8ed" target="_blank" rel="noopener">Spring Boot中使用Swagger2构建强大的RESTful API文档</a></li><li><a href="http://www.cnblogs.com/xiaosiyuan/p/6255292.html" target="_blank" rel="noopener">springboot 使用c3p0数据库连接池的方法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot; style=&quot;margin: 30px 0 35px;&quot;&gt;No Repeating, Just Coding&lt;/p&gt;


&lt;p&gt;最近用 &lt;code&gt;Spring&lt;/code&gt; 写后台较多，每次新建一个项目要从原来项目里拷贝很多配置文件，因此就想整合一个配置好的的基本项目架构。&lt;code&gt;Spring boot&lt;/code&gt; 融合了 &lt;code&gt;tomcat&lt;/code&gt;, 使用后爱不释手，因此主要基于 &lt;strong&gt;Spring boot + MVC&lt;/strong&gt; 以及一些其他必要功能进行配置使用。&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;项目代码地址: &lt;a href=&quot;https://github.com/jiyiren/SpbootApi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/jiyiren/SpbootApi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个仓库主要是集成 &lt;strong&gt;Spring-boot, Spring-mvc, Mysql, Mybatis, C3p0, &lt;a href=&quot;https://swagger.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swagger2&lt;/a&gt;&lt;/strong&gt; 的项目架构,为便于每次新建项目不用从零开始,直接基于此项目结构可快速地进行项目二次开发，免去了 &lt;strong&gt;pom&lt;/strong&gt; 内容的复制和配置文件的编写。&lt;/p&gt;
&lt;h3 id=&quot;整体项目结构&quot;&gt;&lt;a href=&quot;#整体项目结构&quot; class=&quot;headerlink&quot; title=&quot;整体项目结构&quot;&gt;&lt;/a&gt;整体项目结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://img.godjiyi.cn/spbootapi-arc.png&quot; alt=&quot;项目结构&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://www.godjiyi.cn/categories/Spring/"/>
    
    
      <category term="Java" scheme="https://www.godjiyi.cn/tags/Java/"/>
    
      <category term="spring" scheme="https://www.godjiyi.cn/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://www.godjiyi.cn/2017/05/08/regex/"/>
    <id>https://www.godjiyi.cn/2017/05/08/regex/</id>
    <published>2017-05-08T14:00:40.000Z</published>
    <updated>2018-10-13T09:25:54.650Z</updated>
    
    <content type="html"><![CDATA[<p align="center" style="margin: 30px 0 35px;">你有你的规则，我有我的正则</p><p>开发中经常用到正则表达式，但总是靠搜索，有的结果过时或者不正确，导致浪费很多时间。与其将时间浪费在搜索上倒不如自己好好地掌握它。</p><h2 id="正则规则"><a href="#正则规则" class="headerlink" title="正则规则"></a>正则规则</h2><hr><p>分四大类来说明: <strong>常用符号说明</strong>、<strong>符号数目匹配</strong>、<strong>逻辑语句符号匹配</strong>、<strong>目标匹配符号</strong>。</p><h3 id="一、常用符号说明"><a href="#一、常用符号说明" class="headerlink" title="一、常用符号说明"></a>一、常用符号说明</h3><ol><li><code>^</code>: <strong>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配。</strong></li><li><code>$</code>: <strong>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\n”或”\r”之前的位置匹配。</strong></li><li><code>\</code>: <strong>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符</strong></li></ol><a id="more"></a><h3 id="二、符号数目匹配"><a href="#二、符号数目匹配" class="headerlink" title="二、符号数目匹配"></a>二、符号数目匹配</h3><ol><li><code>*</code>: <em>零次或多次</em> 匹配前面的字符或子表达式。例如，”zo*“ 匹配”z”和”zoo”。* 等效于<code>{0,}</code>。</li><li><code>+</code>: <em>一次或多次</em> 匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 <code>{1,}</code>。</li><li><code>?</code>: <em>零次或一次</em> 匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 <code>{0,1}</code>。</li><li><code>{n}</code>: <strong>n 是非负整数。正好匹配 n 次。例如，”o{2}”表示此匹配两个o</strong></li><li><code>{n,}</code>: <strong>n 是非负整数。至少匹配 n 次。</strong></li><li><code>{n,m}</code>: <strong>n 和 m 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。</strong></li></ol><h3 id="三、逻辑语句符号匹配"><a href="#三、逻辑语句符号匹配" class="headerlink" title="三、逻辑语句符号匹配"></a>三、逻辑语句符号匹配</h3><ol><li><code>x|y</code>: <strong>匹配 x 或 y。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。</strong></li><li><p><code>()</code>: <strong>括号</strong></p><ul><li><code>(pattern)</code>: 匹配 pattern 并捕获该匹配的子表达式</li><li><code>(?:pattern)</code>: 匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。例如，<code>industr(?:y|ies)</code> 是比 <code>industry|industries</code> 更经济的表达式。</li><li><code>(?=pattern)</code>: <a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">?=pattern</a></li><li><code>(?!pattern)</code>: <a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">?!pattern</a></li></ul></li></ol><h3 id="四、目标匹配符号"><a href="#四、目标匹配符号" class="headerlink" title="四、目标匹配符号"></a>四、目标匹配符号</h3><ol><li><code>[xyz]</code>: <strong>字符集。匹配包含的任一字符。例如，”[abc]”代表当前位只能是abc三个字符中的一个</strong></li><li><code>[^xyz]</code>: <strong>反向字符集。匹配未包含的任何字符。例如，”<code>[^abc]</code>“ 则当前位不能是abc中的任意一个。</strong></li><li><p><code>[a-z]</code>: <strong>字符范围。匹配指定范围内的任何字符。如：</strong></p><ul><li><code>[a-z]</code>: 当前位匹配从a到z字符</li><li><code>[A-Z]</code>: 当前位匹配从A到Z字符</li><li><code>[0-9]</code>: 当前位匹配从0到9字符</li><li><code>[a-zA-Z0-9]</code>: 当前位匹配从a到z，从A到Z以及从0-9的字符</li><li><code>[a-zA-Z0-9_]</code>: 当前位匹配从a到z，从A到Z以及从0-9的字符和<em>_</em>字符</li><li><code>[a-zA-Z0-9_-]</code>: 当前位匹配从a到z，从A到Z以及从0-9的字符和<em>_</em>与<em>-</em>字符</li></ul></li><li><p><code>[^a-z]</code>: <strong>反向范围字符。匹配不在指定的范围内的任何字符.</strong></p></li><li><code>\d</code>: <strong>匹配数字，与<code>[0-9]</code>等效.</strong></li><li><code>\D</code>: <strong>匹配非数字字符，与<code>[^0-9]</code>等效.</strong></li><li><code>\w</code>: <strong>匹配任何字类字符，包括下划线。与”<code>[A-Za-z0-9_]</code>“等效.</strong></li><li><code>\W</code>: <strong>与任何非单词字符匹配。与”<code>[^A-Za-z0-9_]</code>“等效。</strong></li><li><code>.</code>: <strong>匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</strong></li><li><code>\b</code>: <strong>匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。多用于java中的正则查找与替换</strong>。</li><li><code>\B</code>: <strong>非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</strong></li><li><code>\s</code>: <strong>匹配任何空白字符，包括空格、制表符、换页符等。与 <code>[\f\n\r\t\v]</code> 等效。</strong></li><li><code>\S</code>: <strong>匹配任何非空白字符。与 <code>[^\f\n\r\t\v]</code>等效。</strong></li><li><p>各种空白符：</p><ul><li><code>\f</code>: 换页符匹配。等效于 \x0c 和 \cL。</li><li><code>\n</code>: 换行符匹配。等效于 \x0a 和 \cJ。</li><li><code>\r</code>: 匹配一个回车符。等效于 \x0d 和 \cM。</li><li><code>\t</code>: 制表符匹配。与 \x09 和 \cI 等效。</li><li><code>\v</code>: 垂直制表符匹配。与 \x0b 和 \cK 等效。</li></ul></li><li><p><code>\xn</code>: <strong>匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是<em>两位</em>数长。例如，”\x41”匹配”A”。允许在正则表达式中使用 ASCII 代码。</strong></p></li><li><code>\un</code>: <strong>匹配 n，其中 n 是以<em>四位</em>十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。附：<a href="http://jiyiren.github.io/2016/03/22/Java_encode/" target="_blank" rel="noopener">Unicode编码说明</a>,<a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">汉字Unicode编码表</a></strong> </li></ol><h2 id="常见正则"><a href="#常见正则" class="headerlink" title="常见正则"></a>常见正则</h2><hr><p>下面分别对常见的邮箱和手机号举例。</p><h3 id="邮箱："><a href="#邮箱：" class="headerlink" title="邮箱："></a>邮箱：</h3><p>常见邮箱形式：</p><ol><li><a href="mailto:`zhangshan@163.com" target="_blank" rel="noopener">`zhangshan@163.com</a>`</li><li><a href="mailto:`abc@sina.com.cn" target="_blank" rel="noopener">`abc@sina.com.cn</a>`</li><li><a href="mailto:`zhangshna.Mr@163.com" target="_blank" rel="noopener">`zhangshna.Mr@163.com</a>`</li><li><a href="mailto:`abc_Wang.dd@sian.com" target="_blank" rel="noopener">`abc_Wang.dd@sian.com</a>`</li><li><a href="mailto:`abc_Wang.dd.cc@sian.com" target="_blank" rel="noopener">`abc_Wang.dd.cc@sian.com</a>`</li></ol><p>网络上正则，仅仅能匹配 1，2 两种格式:</p><p><code>^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$</code></p><p>满足需求正则:</p><ol><li>匹配全部：<code>^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$</code></li><li>等价匹配：<code>^[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$</code></li><li>或者：<code>^(\w)+(\.\w+)*@(\w)+((\.\w{2,3}){1,3})$</code></li><li>注意java代码里需要将所有 \ 转义，要在所有 \ 前多加一个 \</li></ol><p>java 代码:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">String regex = <span class="string">"^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w&#123;2,3&#125;)&#123;1,3&#125;)$"</span>;</span><br><span class="line"><span class="keyword">return</span> email.matches(regex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="手机号码"><a href="#手机号码" class="headerlink" title="手机号码:"></a>手机号码:</h3><p>手机基本格式如下：</p><ol><li>共11位：</li><li><strong>13(0-9)</strong>:13开头手机号第三位0-9全可以</li><li><strong>14(5,7)</strong>:14开头的第三位只有5(联通)，7(移动)</li><li><strong>15(-4)</strong>:15开头的第三位除了4，其他都有，因为(154有谐音“要我死”)</li><li><strong>17(3,5,6,7,8)</strong>:17开头的三位有3,5,6,7,8;其中3,7为电信，5,6为联通,8为移动。</li><li><strong>18(0-9)</strong>:18开头的第三位0-9均可以</li><li><p>而170和171的为虚拟运营商:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1700/1701/1702(电信)</span><br><span class="line">1703/1705/1706(移动)</span><br><span class="line">1704/1707/1708/1709(联通)</span><br><span class="line">171（联通)</span><br></pre></td></tr></table></figure></div></li></ol><p>虚拟商除外，匹配前三个位置数字正则：</p><ol><li>1与5可以一起写: <strong>1[3,8][0-9]</strong></li><li>第二种: <strong>14[5,7]</strong></li><li>第三种: <strong>15[^4]</strong></li><li>第四种: <strong>17[3,5-8]</strong></li><li>合并为: <code>^((1[3,8][0-9])|(14[5,7])|(15[^4])|(17[3,5-8]))\d{8}$</code></li><li>注意：\d代表数字，如果要写入 java 代码，则需要多加一条 \ 来转义。如果不想写转义因为\d等价于[0-9]所以也可以换为：<code>^((1[3,8][0-9])|(14[5,7])|(15[^4])|(17[3,5-8]))[0-9]{8}$</code></li></ol><p>Java 代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isChinaPhoneLegal</span><span class="params">(String str)</span> <span class="keyword">throws</span> PatternSyntaxException </span>&#123;  </span><br><span class="line">String regExp = <span class="string">"^((1[3,8][0-9])|(14[5,7])|(15[^4])|(17[3,5-8]))\\d&#123;8&#125;$"</span>; </span><br><span class="line"><span class="comment">//String regExp = "^((1[3,8][0-9])|(14[5,7])|(15[^4])|(17[3,5-8]))[0-9]&#123;8&#125;$";  </span></span><br><span class="line">Pattern p = Pattern.compile(regExp);  </span><br><span class="line">Matcher m = p.matcher(str);  </span><br><span class="line"><span class="keyword">return</span> m.matches();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="占用端口进程"><a href="#占用端口进程" class="headerlink" title="占用端口进程"></a>占用端口进程</h3><p>我们用 Linux 命令获取占用 22 端口信息如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@vm]<span class="comment"># netstat -tnlp | grep ':22 '</span></span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      21392/sshd          </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      21392/sshd</span><br></pre></td></tr></table></figure></div><p>只需要用 Python 中 commands 包执行对应命令，取得第一行结果即可得到字符串，我们直接使用该字符用正则提出进程名：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcp_str = <span class="string">"tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      21392/sshd"</span></span><br><span class="line">reg_p = re.compile(<span class="string">r'.+ (\d+)/(\w+)'</span>)</span><br><span class="line">m = reg_p.match(tcp_str)</span><br><span class="line">ps_str = m.group(<span class="number">2</span>) <span class="comment"># 0 为原字符串，1为进程ID，2为进程名，这里为 sshd</span></span><br></pre></td></tr></table></figure></div><h3 id="获取磁盘挂载信息"><a href="#获取磁盘挂载信息" class="headerlink" title="获取磁盘挂载信息"></a>获取磁盘挂载信息</h3><h4 id="fdisk-命令"><a href="#fdisk-命令" class="headerlink" title="fdisk 命令"></a>fdisk 命令</h4><p>获取插入主机的所有磁盘 <code>fdisk</code> 命令:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@vm]<span class="comment"># fdisk -l</span></span><br><span class="line"></span><br><span class="line">Disk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x0008b9e9</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vda1   *        2048     1026047      512000   83  Linux</span><br><span class="line">/dev/vda2         1026048    83886079    41430016   8e  Linux LVM</span><br><span class="line"></span><br><span class="line">Disk /dev/vdb: 107.4 GB, 107374182400 bytes, 209715200 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/mapper/centos-root: 40.2 GB, 40227569664 bytes, 78569472 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure></div><p>我们只需要 <code>/dev/vdx</code> 这样的信息，因此需要过滤：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@vm]<span class="comment"># fdisk -l | egrep '^Disk /dev/[a-z]d[a-z]' | awk -F: '&#123;print $1&#125;' | awk '&#123;print $2&#125;'</span></span><br><span class="line">/dev/vda</span><br><span class="line">/dev/vdb</span><br></pre></td></tr></table></figure></div><p>其中 <code>egrep</code> 是选取符合的行如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@vm]<span class="comment"># fdisk -l | egrep '^Disk /dev/[a-z]d[a-z]'</span></span><br><span class="line">Disk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectors</span><br><span class="line">Disk /dev/vdb: 107.4 GB, 107374182400 bytes, 209715200 sectors</span><br></pre></td></tr></table></figure></div><p>后面两个 <code>awk</code> 则不断 <strong>split</strong> 字符串选取出最终的字符。</p><h4 id="df-命令"><a href="#df-命令" class="headerlink" title="df 命令"></a>df 命令</h4><p>上面的 <code>fdisk</code> 是获取所有的磁盘信息，包括已经挂载以及未挂载的磁盘，而 <code>df</code> 则获取仅仅挂载的信息，这样对于企业中的监控获取未挂载的磁盘，则只需用 <code>fdisk</code> 结果减 <code>df</code> 的结果，这里只介绍用 <code>df</code> 获取磁盘信息：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@vm]<span class="comment"># df -h</span></span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root   38G  6.5G   32G  18% /</span><br><span class="line">devtmpfs                 3.9G     0  3.9G   0% /dev</span><br><span class="line">tmpfs                    3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs                    3.9G  401M  3.5G  11% /run</span><br><span class="line">tmpfs                    3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1                497M  150M  348M  31% /boot</span><br><span class="line">/dev/vdb                  99G   61M   94G   1% /data</span><br><span class="line">tmpfs                    783M     0  783M   0% /run/user/0</span><br></pre></td></tr></table></figure></div><p>我们也只需要 <code>/dev/vdx</code> 这样的信息：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@vm]<span class="comment"># df -Th | /usr/bin/egrep '^/dev/[a-z]d[a-z]\d*' | awk '&#123;print $1&#125;'</span></span><br><span class="line">/dev/vda1</span><br><span class="line">/dev/vdb</span><br></pre></td></tr></table></figure></div><h4 id="proc-partitions-文件"><a href="#proc-partitions-文件" class="headerlink" title="/proc/partitions 文件"></a>/proc/partitions 文件</h4><p>这个文件也记录了 Centos 系统的磁盘挂载信息，与 fdisk 命令的结果一致，但是用文件搜索方式比通过 commands 包调用 fdisk 命令效率更高，因此，推荐用此方式来查系统挂载信息：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@vm]<span class="comment"># cat /proc/partitions | egrep ' [a-z]d[a-z]+$' | awk '&#123;print $4&#125;'</span></span><br><span class="line">vda</span><br><span class="line">vdb</span><br></pre></td></tr></table></figure></div><h4 id="proc-mounts-文件"><a href="#proc-mounts-文件" class="headerlink" title="/proc/mounts 文件"></a>/proc/mounts 文件</h4><p>这个文件则是与 <code>df</code> 命令相似，只记录已经挂载的磁盘信息，并且效率高于 <code>df</code> 命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@vm]<span class="comment"># cat /proc/mounts | egrep '^/dev/[a-z]d[a-z]+\d*'</span></span><br><span class="line">/dev/vda1 /boot xfs rw,relatime,attr2,inode64,noquota 0 0</span><br><span class="line">/dev/vdb /data ext4 rw,relatime,data=ordered 0 0</span><br></pre></td></tr></table></figure></div><p>这个先查询出行，再用 <code>awk</code> 对行进行截取，这个我就不写了，自己大家可以 <code>awk</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">java正则</a></li><li><a href="http://www.cnblogs.com/liaojie970/p/5714050.html" target="_blank" rel="noopener">回车与换行</a></li><li><a href="http://blog.sina.com.cn/s/blog_4c925dca01009h1a.html" target="_blank" rel="noopener">js正则</a></li><li><a href="http://www.cnblogs.com/hsqdboke/p/4944823.html" target="_blank" rel="noopener">邮箱正则</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot; style=&quot;margin: 30px 0 35px;&quot;&gt;你有你的规则，我有我的正则&lt;/p&gt;

&lt;p&gt;开发中经常用到正则表达式，但总是靠搜索，有的结果过时或者不正确，导致浪费很多时间。与其将时间浪费在搜索上倒不如自己好好地掌握它。&lt;/p&gt;
&lt;h2 id=&quot;正则规则&quot;&gt;&lt;a href=&quot;#正则规则&quot; class=&quot;headerlink&quot; title=&quot;正则规则&quot;&gt;&lt;/a&gt;正则规则&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;分四大类来说明: &lt;strong&gt;常用符号说明&lt;/strong&gt;、&lt;strong&gt;符号数目匹配&lt;/strong&gt;、&lt;strong&gt;逻辑语句符号匹配&lt;/strong&gt;、&lt;strong&gt;目标匹配符号&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;一、常用符号说明&quot;&gt;&lt;a href=&quot;#一、常用符号说明&quot; class=&quot;headerlink&quot; title=&quot;一、常用符号说明&quot;&gt;&lt;/a&gt;一、常用符号说明&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt;: &lt;strong&gt;匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt;: &lt;strong&gt;匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\n”或”\r”之前的位置匹配。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\&lt;/code&gt;: &lt;strong&gt;将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Regex" scheme="https://www.godjiyi.cn/categories/Regex/"/>
    
    
      <category term="Regex" scheme="https://www.godjiyi.cn/tags/Regex/"/>
    
  </entry>
  
  <entry>
    <title>LAMP 以及 Tomcat 服务器环境搭建</title>
    <link href="https://www.godjiyi.cn/2017/02/24/lamp/"/>
    <id>https://www.godjiyi.cn/2017/02/24/lamp/</id>
    <published>2017-02-24T09:40:40.000Z</published>
    <updated>2018-09-18T12:37:07.720Z</updated>
    
    <content type="html"><![CDATA[<p align="center" style="margin: 30px 0 35px;">开源一族，与众不同</p><p>最近频繁使用服务器环境，以前也搭建过，但那些命令以及配置都不能铭记于心，因此今天借此记录下，以便于以后参考。记录主要有：<strong>LAMP</strong> ( <em>Linux, Apache, Mysql, Php</em> ) 以及 <strong>Git</strong>, <strong>Java</strong>, <strong>Tomcat</strong>, <strong>Ftp</strong> 等安装命令及配置过程。</p><div align="center"><br><img src="http://img.godjiyi.cn/lamp.jpg" align="center"><br></div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>作为程序员，对于服务器的部署还是有必要会的，因为这决定了自己独立的高度。目前而言，服务器操作系统性能最好的还是 Linux，不要说自己不会，没有不会的程序员，只有懒惰的程序员。</p><p>对于 <strong>Linux</strong> 系统的学习最容易上手的还是 <strong>Ubuntu</strong> 桌面版了，因为它有 Windows 版的界面，可以给新手一个过渡阶段，之后再上手到只有命令端的 <strong>Linux Server</strong> 版就容易多了。</p><p>这里给 <a href="http://www.kancloud.cn/explore" target="_blank" rel="noopener">看云</a> 上的两个学习文档：<a href="http://www.kancloud.cn/you23hai45/linux-space/108213" target="_blank" rel="noopener">Linux学习</a>; <a href="http://www.kancloud.cn/thinkphp/linux-command-line/39431" target="_blank" rel="noopener">The Linux Command Line 中文版</a></p><a id="more"></a><h2 id="LAMP-搭建"><a href="#LAMP-搭建" class="headerlink" title="LAMP 搭建"></a>LAMP 搭建</h2><hr><p><strong>Linux</strong> 系统环境选择的是 <em>Ubuntu 14.04</em>；</p><p>对于 <em>Ubuntu 16.04</em> 其内置的下载源和 14.04 的不一致，网上很多教程都不适用，建议大家选择 <em>Ubuntu 14.04</em> 测试。</p><h3 id="一、安装-MySQL"><a href="#一、安装-MySQL" class="headerlink" title="一、安装 MySQL"></a>一、安装 MySQL</h3><p>安装 <strong>mysql</strong> 服务器端:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server mysql-client</span><br></pre></td></tr></table></figure></div><p>检查 <strong>mysql</strong> 服务是否开启，看到 <code>LISTEN</code> 就代表开启了:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure></div><p>如果没开启，可用以下的命令 <strong>开启/停止/重启/查看状态</strong> :</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql start/stop/restart/status</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">sudo /etc/init.d/mysql start/stop/restart/status</span><br><span class="line"><span class="comment"># service 命令就是在 /etc/init.d 下搜寻命令执行的，两者效果一样的</span></span><br></pre></td></tr></table></figure></div><h3 id="二、安装-Apache"><a href="#二、安装-Apache" class="headerlink" title="二、安装 Apache"></a>二、安装 Apache</h3><p>安装 Apache，现在最新版本为第二版，因此通常用 Apache2</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br></pre></td></tr></table></figure></div><p><strong>启动/停止/重启/状态</strong> 命令:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service apache2 start/stop/restart/status</span><br></pre></td></tr></table></figure></div><p>配置文件在 <code>/etc/apache2</code> :</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apache2.conf<span class="comment"># 主配置文件</span></span><br><span class="line">ports.conf;<span class="comment"># 端口配置文件</span></span><br><span class="line">sites-available/<span class="comment"># 存储多个站点的目录</span></span><br><span class="line">sites-enabled/ <span class="comment"># 存储已开启的站点的目录( 从 available 中选择的 )</span></span><br><span class="line">mods-available/ <span class="comment"># 存储多个模块的目录</span></span><br><span class="line">mods-enabled/ <span class="comment"># 存储已开启的模块的目录</span></span><br><span class="line">conf-available/ <span class="comment"># 存储多种配置的目录</span></span><br><span class="line">conf-enabled/ <span class="comment"># 存储已经开启的配置的目录</span></span><br><span class="line">magic;</span><br><span class="line">envvars;</span><br></pre></td></tr></table></figure></div><p>配置站点常常需要修改之处(不一定都需要修改，可按照自己的环境来配置操作)：</p><p>修改 <strong>apache2.conf</strong>, 以防出现权限不够：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/apache2</span><br><span class="line">sudo vi apache2.conf</span><br><span class="line"><span class="comment"># 主要修改下面这些</span></span><br><span class="line">&lt;Directory /var/www/&gt;</span><br><span class="line">Options Indexes FollowSymLinks</span><br><span class="line">AllowOverride None <span class="comment"># 修改为 AllowOverride All</span></span><br><span class="line">Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure></div><p>修改主项目地址：<code>/etc/apache2/sites-enable/000-default.conf</code> 如下:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/apache2/sites-enable</span><br><span class="line">sudo vi 000-default.conf</span><br><span class="line"><span class="comment"># 将DocumentRoot /var/www 修改为 DocumentRoot /var/www/laravel</span></span><br></pre></td></tr></table></figure></div><p>对于项目根目录权限问题:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># linux 的 apache 用户组是 www-data</span></span><br><span class="line"><span class="comment"># -R 代表递进目录</span></span><br><span class="line">sudo chown -R :www-data /var/www/laravel </span><br><span class="line"><span class="comment"># mac 下的 Apache 用户组是 _www</span></span><br><span class="line">sudo chown -R :_www /var/www/laravel</span><br><span class="line">sudo chmod -R 776 /var/www/laravel/storage</span><br><span class="line">sudo chmod -R 776 /var/www/laravel/vendor</span><br><span class="line">sudo chmod -R 776 /var/www/laravel/bootstrap</span><br></pre></td></tr></table></figure></div><p>配置 <strong>多个站点</strong>，通过不同端口访问:</p><p>假设 <code>/var/www</code>下放置了 <code>laravel</code> 和 <code>html</code>两个项目,</p><p>在 <code>sites-available</code> 目录下复制 <strong>000-default.conf</strong> :</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/apache2/sites-available</span><br><span class="line">sudo cp 000-default.conf htmltest.conf</span><br><span class="line">sudo vi htmltest.conf</span><br><span class="line"><span class="comment"># 主要编辑端口号和项目地址</span></span><br><span class="line"><span class="comment"># 端口：&lt;VirtualHost *:80&gt; 可改为 &lt;VirtualHost *:8090&gt;</span></span><br><span class="line"><span class="comment"># 项目地址：DocumentRoot /var/www/laravel 可改为 DocumentRoot /var/www/html</span></span><br></pre></td></tr></table></figure></div><p>在 <code>sites-enable</code> 目录下软连接到 <strong>sites-available/htmltest.conf</strong> :</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用刚刚配置的项目</span></span><br><span class="line"><span class="built_in">cd</span> /etc/apache2/sites-enable</span><br><span class="line">sudo ln -s ../sites-available/htmltest.conf ./htmltest.conf</span><br></pre></td></tr></table></figure></div><p>增加监听端口如下:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/apache2</span><br><span class="line">sudo vi ports.conf</span><br><span class="line"><span class="comment"># 添加如下</span></span><br><span class="line">Listen 8090</span><br></pre></td></tr></table></figure></div><p>重启服务器，访问，如果有权限问题按照上面权限方法设置:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo service apache2 restart</span><br><span class="line"><span class="comment"># 两个项目</span></span><br><span class="line"><span class="comment"># 第一个是默认配置的: http://ip</span></span><br><span class="line"><span class="comment"># 第二个是刚刚配置的: http://ip:8090</span></span><br></pre></td></tr></table></figure></div><h3 id="三、安装-php-以及相关模块"><a href="#三、安装-php-以及相关模块" class="headerlink" title="三、安装 php 以及相关模块"></a>三、安装 php 以及相关模块</h3><p>安装 <strong>php5</strong> ( Ubuntu 14.04 )</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php5 libapache2-mod-php5</span><br></pre></td></tr></table></figure></div><p>安装 <strong>php7</strong> ( Ubuntu 16.04 )</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php7.0 libapache2-mod-php7.0</span><br></pre></td></tr></table></figure></div><p>安装相关模块 ( 包括 php 与 mysql 等数据相关包)( Ubuntu 14.04 ):</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php5-mysql php5-curl php5-gd php5-intl php-pear php5-imagick php5-imap php5-mcrypt php5-memcache php5-ming php5-ps php5-pspell php5-recode php5-snmp php5-sqlite php5-tidy php5-xmlrpc php5-xsl</span><br></pre></td></tr></table></figure></div><h3 id="四、Apache权限"><a href="#四、Apache权限" class="headerlink" title="四、Apache权限"></a>四、Apache权限</h3><p>对项目目录执行:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /var/projectname</span><br></pre></td></tr></table></figure></div><h2 id="Tomcat以及其他软件配置安装"><a href="#Tomcat以及其他软件配置安装" class="headerlink" title="Tomcat以及其他软件配置安装"></a>Tomcat以及其他软件配置安装</h2><hr><h3 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h3><p>这方面也是很基础的安装配置，包括 jdk, tomcat 配置, git 设置</p><p>其他管理软件如 samba, ftp 远程连接软件</p><p><strong>[2017.5.3日更新]</strong> 我将用到的软件放在了 <code>gitosc</code> 上，因为 <code>gitosc</code> 支持二进制文件，因此可以当网盘用了.大家可以用 <code>git</code> 直接 clone 该项目，就无需再去寻找软件包了。项目地址：<a href="https://git.oschina.net/jiyiren/linuxfile" target="_blank" rel="noopener">https://git.oschina.net/jiyiren/linuxfile</a> </p><h3 id="二、JDK8-安装"><a href="#二、JDK8-安装" class="headerlink" title="二、JDK8 安装"></a>二、JDK8 安装</h3><p>官网：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">下载jdk8</a> 或者 git 项目地址：<a href="https://git.oschina.net/jiyiren/linuxfile" target="_blank" rel="noopener">https://git.oschina.net/jiyiren/linuxfile</a> </p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载Linux版本到本地</span></span><br><span class="line">jdk-8u121-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></div><p>将 jdk 上传到服务器，这可以有多种方法，可以用 <strong>FileZilla</strong>，也可以用 FTP，或者找到一个链接地址，用 <code>wget</code> 在服务器上直接下载。我是使用 <strong>FileZilla</strong>上传的!</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设我们放在用户当前目录下</span></span><br><span class="line">~/jdk-8u121-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></div><p>解压到 <code>/opt</code> 目录下或者 <code>/usr/local</code>, 这里我解压到 <code>/opt</code> 下:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设 jdk-8u121-linux-x64.tar.gz 在用户~目录下</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">sudo tar -xzvf jdk-8u121-linux-x64.tar.gz -C /opt/</span><br><span class="line"></span><br><span class="line"><span class="comment"># zip 格式的则用如下命令</span></span><br><span class="line">sudo unzip jdk.zip -d /opt/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改解压后的目录名称</span></span><br><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">mv jdk1.8.0_121 jdk8</span><br></pre></td></tr></table></figure></div><p>添加环境变量:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">vi .bashrc</span><br><span class="line"><span class="comment"># 添加下面</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/jdk8</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib:<span class="variable">$JRE_HOME</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">source</span> .bashrc<span class="comment"># 环境变量生效</span></span><br><span class="line">java -version<span class="comment"># 看到版本信息即可</span></span><br></pre></td></tr></table></figure></div><h3 id="三、Tomcat安装"><a href="#三、Tomcat安装" class="headerlink" title="三、Tomcat安装"></a>三、Tomcat安装</h3><p>下载 <strong>Tomcat</strong>, 这里可以像上面安装 jdk 一样，先去 <a href="http://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">官网</a>下载到本地再上传到服务器;当然也可以直接用前面提到的用 <strong>wget</strong> 方式下载。</p><p>大家在点击官网下载时会获得一个下载链接，这是只要在服务器上用 <strong>wget</strong> 下载就行了(注下载链接可能会失效的，因此建议通过 <code>git</code> 项目下载这些文件 <a href="https://git.oschina.net/jiyiren/linuxfile" target="_blank" rel="noopener">https://git.oschina.net/jiyiren/linuxfile</a> )：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.11/bin/apache-tomcat-8.5.11.tar.gz</span><br><span class="line"><span class="comment"># 如果提示没有wget,则按照提示安装wget即可</span></span><br></pre></td></tr></table></figure></div><p>添加环境变量:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压文件到/opt/</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">sudo tar -xzvf apache-tomcat-8.5.11.tar.gz -C /opt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改名称，这个随便自己的，我感觉文件名太长了</span></span><br><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">mv apache-tomcat-8.5.11 tomcat8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加环境变量</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">vi .bashrc</span><br><span class="line"><span class="comment"># 添加如下行</span></span><br><span class="line"><span class="built_in">export</span> PATH=/opt/tomcat8/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使环境变量立即生效</span></span><br><span class="line"><span class="built_in">source</span> .bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测是否设置成功</span></span><br><span class="line"><span class="built_in">which</span> startup.sh</span><br><span class="line"><span class="comment"># 如果输出如下就可以了</span></span><br><span class="line">/opt/tomcat8/bin/startup.sh</span><br></pre></td></tr></table></figure></div><p><strong>开启/关闭</strong> tomcat 服务器</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启或关闭</span></span><br><span class="line">startup.sh/shutdown.sh</span><br><span class="line"><span class="comment"># 检查是否开启，用浏览器访问 ip:8080 出现 Tomcat 页面就可以了</span></span><br><span class="line"><span class="comment"># 如果发现 shutdown.sh 出错，说明 tomcat 没启动成功，需要查看 tomcat 进程，并结束</span></span><br><span class="line">ps -ef|grep tomcat</span><br><span class="line"><span class="built_in">kill</span> -9 [pid]</span><br></pre></td></tr></table></figure></div><p>配置项目根目录，<strong>Tomcat</strong> 项目目录默认在 <code>webapps</code> 目录下，多个项目只要放在里面即可，访问的时候：<em>ip:端口/projecName/</em> 即可访问项目根目录。( 默认端口是 <strong>8080</strong> )</p><p>但是如果想将我们的项目放在根目录呢？一种就是将 <em>webapps/ROOT</em> 目录覆盖，另外一种就是修改配置文件，这里介绍修改配置文件 <strong>server.xml</strong> 方法。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 到配置目录修改配置文件server.xml</span></span><br><span class="line"><span class="built_in">cd</span> /opt/tomcat8/conf</span><br><span class="line">vi server.xml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在含有 appBase="webapps" 的 &lt;host&gt;&lt;/host&gt; 之间添加如下</span></span><br><span class="line">&lt;Context path=<span class="string">""</span> docBase=<span class="string">"/opt/tomcat8/webapps/htmltest/"</span> debug=<span class="string">"0"</span>/&gt;</span><br><span class="line"><span class="comment"># 如上，根目录设置在 /opt/tomcat8/webapps/htmltest/</span></span><br></pre></td></tr></table></figure></div><h3 id="四、git-安装"><a href="#四、git-安装" class="headerlink" title="四、git 安装"></a>四、git 安装</h3><p>安装</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure></div><p>通常经过上面安装的 <code>git</code> 版本是 <em>1.9.1</em> 版本，现在已经到 <em>2.11</em> 了，旧版本有不支持的命令，因此要装比较新的版本</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先更新下源，不然会有不识别提示</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-add-repository ppa:git-core/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git</span><br><span class="line">git --version</span><br><span class="line"><span class="comment"># 此时将显示更高级的或者最新的版本</span></span><br></pre></td></tr></table></figure></div><h3 id="五、ftp安装"><a href="#五、ftp安装" class="headerlink" title="五、ftp安装"></a>五、ftp安装</h3><p>这里安装 vsftpd :</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装，并检测</span></span><br><span class="line">sudo apt-get install vsftpd</span><br><span class="line">vsftpd -version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个文件夹用于FTP的工作目录</span></span><br><span class="line">mkdir /home/ftp</span><br></pre></td></tr></table></figure></div><p>新建 FTP 用户并设置密码以及工作目录:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -d /home/ftp -s /bin/bash jiyiren</span><br><span class="line"><span class="comment"># -d 代表 ftp 的主目录</span></span><br><span class="line"><span class="comment"># jiyiren为 你为该 ftp 创建的用户名</span></span><br></pre></td></tr></table></figure></div><p>为新用户设置密码:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">passwd jiyiren</span><br><span class="line"><span class="comment"># 可用cat etc/passwd 可以查看当前系统用户</span></span><br></pre></td></tr></table></figure></div><p>修改 vsftpd 配置文件:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/vsftpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改如下两处</span></span><br><span class="line">seccomp_sandbox=NO</span><br><span class="line">local_enable=YES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并添加如下行到结尾</span></span><br><span class="line">userlist_deny=NO</span><br><span class="line">userlist_enable=YES </span><br><span class="line">userlist_file=/etc/allowed_users</span><br></pre></td></tr></table></figure></div><p>添加允许用户列表:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/allowed_users</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加以下用户名</span></span><br><span class="line">jiyiren</span><br><span class="line">root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外可查看 /etc/ftpusers 是否有用户名，无则直接退出，这是禁止用户列表</span></span><br></pre></td></tr></table></figure></div><p><strong>开启/关闭/重启</strong> ftp 服务</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service vsftpd start/stop/restart</span><br></pre></td></tr></table></figure></div><p>登录，Windows 可以用 <strong>WinSCP</strong> 软件或者前面提到的 <strong>FileZilla</strong> 软件，而 Linux 或者 Unix ( mac ) 可以使用如下命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftp jiyiren@ip</span><br><span class="line"><span class="comment"># 输入密码即可</span></span><br></pre></td></tr></table></figure></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.kancloud.cn/you23hai45/linux-space/108213" target="_blank" rel="noopener">Linux 学习</a></li><li><a href="http://www.kancloud.cn/thinkphp/linux-command-line/39431" target="_blank" rel="noopener">The Linux Command Line 中文版</a></li><li><a href="http://www.linuxidc.com/Linux/2016-01/127180.htm" target="_blank" rel="noopener">Ubuntu 下 LAMP 环境搭建</a></li><li><a href="http://www.linuxidc.com/Linux/2016-12/138563.htm" target="_blank" rel="noopener">Ubuntu 下搭建 FTP 服务器图解</a></li><li><a href="http://jingyan.baidu.com/article/67508eb4d6c4fd9ccb1ce470.html" target="_blank" rel="noopener">vsftpd 的安装和配置</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot; style=&quot;margin: 30px 0 35px;&quot;&gt;开源一族，与众不同&lt;/p&gt;

&lt;p&gt;最近频繁使用服务器环境，以前也搭建过，但那些命令以及配置都不能铭记于心，因此今天借此记录下，以便于以后参考。记录主要有：&lt;strong&gt;LAMP&lt;/strong&gt; ( &lt;em&gt;Linux, Apache, Mysql, Php&lt;/em&gt; ) 以及 &lt;strong&gt;Git&lt;/strong&gt;, &lt;strong&gt;Java&lt;/strong&gt;, &lt;strong&gt;Tomcat&lt;/strong&gt;, &lt;strong&gt;Ftp&lt;/strong&gt; 等安装命令及配置过程。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://img.godjiyi.cn/lamp.jpg&quot; align=&quot;center&quot;&gt;&lt;br&gt;&lt;/div&gt;

&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;作为程序员，对于服务器的部署还是有必要会的，因为这决定了自己独立的高度。目前而言，服务器操作系统性能最好的还是 Linux，不要说自己不会，没有不会的程序员，只有懒惰的程序员。&lt;/p&gt;
&lt;p&gt;对于 &lt;strong&gt;Linux&lt;/strong&gt; 系统的学习最容易上手的还是 &lt;strong&gt;Ubuntu&lt;/strong&gt; 桌面版了，因为它有 Windows 版的界面，可以给新手一个过渡阶段，之后再上手到只有命令端的 &lt;strong&gt;Linux Server&lt;/strong&gt; 版就容易多了。&lt;/p&gt;
&lt;p&gt;这里给 &lt;a href=&quot;http://www.kancloud.cn/explore&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;看云&lt;/a&gt; 上的两个学习文档：&lt;a href=&quot;http://www.kancloud.cn/you23hai45/linux-space/108213&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux学习&lt;/a&gt;; &lt;a href=&quot;http://www.kancloud.cn/thinkphp/linux-command-line/39431&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Linux Command Line 中文版&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.godjiyi.cn/categories/Linux/"/>
    
    
      <category term="MySQL" scheme="https://www.godjiyi.cn/tags/MySQL/"/>
    
      <category term="Linux" scheme="https://www.godjiyi.cn/tags/Linux/"/>
    
      <category term="Apache" scheme="https://www.godjiyi.cn/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>Android 图形化排序算法</title>
    <link href="https://www.godjiyi.cn/2016/11/24/android_sort/"/>
    <id>https://www.godjiyi.cn/2016/11/24/android_sort/</id>
    <published>2016-11-24T12:40:40.000Z</published>
    <updated>2018-09-18T12:38:47.870Z</updated>
    
    <content type="html"><![CDATA[<p align="center" style="margin: 30px 0 35px;">排序算法不好理解？那就来个 GUI 的!</p><p>上篇C语言实现各排序算法的完成，使得自己对排序有了一定的了解，最近看到一个 <em>iOS</em> 图形化排序过程，因此今天就完成 <em>Android</em> 端的图形化排序过程。</p><p>排序算法实现很简单，其重点是要实现安卓 <strong>View</strong> 跟随排序的动态变化。</p><p>由于计算机执行排序算法的高效性，对一定数量的数组排序都是 <strong>毫秒级</strong> 的，因此我们要考虑 <strong>放大排序时间</strong>，给可视化界面完整的动态过程。</p><h2 id="一、总体功能界面"><a href="#一、总体功能界面" class="headerlink" title="一、总体功能界面"></a>一、总体功能界面</h2><hr><h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p><img src="http://img.godjiyi.cn/jysortwelcome.gif" alt="maingif"></p><a id="more"></a><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>六种排序算法完成</li><li>可视动态化界面实现</li><li>时间计时器 </li><li>算法时间复杂度说明</li></ul><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><ol><li>Android 图形化排序地址：<a href="https://github.com/jiyiren/JYSort" target="_blank" rel="noopener">https://github.com/jiyiren/JYSort</a></li><li>C 实现排序项目地址：<a href="https://github.com/jiyiren/CSort" target="_blank" rel="noopener">https://github.com/jiyiren/CSort</a></li></ol><h2 id="二、实现重点"><a href="#二、实现重点" class="headerlink" title="二、实现重点"></a>二、实现重点</h2><h3 id="数据与界面的初始化"><a href="#数据与界面的初始化" class="headerlink" title="数据与界面的初始化"></a>数据与界面的初始化</h3><ol><li>数据是随机生成 <em>100个数组</em> 成一个数组，当然这个长度我们定义成全局变量，可以自行修改。</li><li>界面的初始化由上到下分别为 <strong>Toolbar菜单栏</strong>、<strong>主体排序可视窗口</strong>、<strong>时间复杂度</strong> 等。</li><li>重点在于中间主体排序 <strong>可视窗口的绘制</strong>：因为可视的 <em>View</em> 就是要表示数组中各个数据的大小，因而我们就将每个柱状 <em>View</em> 的高度用于表示数组中各个数据的大小，但是由于手机界面有限，如果有的数据过大那么绘制将超出屏幕。因此我们采取将 <em>3/5</em> 个屏幕像素与数组中最大值的<strong>比值</strong>作为每个数转为高度的一个因素，也就是说数组中数据不管多大，其高度最高最大为 <em>3/5</em> 个屏幕大小。而其宽度则是根据数组长度由屏幕宽度计算得出，具体如下：</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化界面的柱状图</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll_root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        ll_root= (LinearLayout) findViewById(R.id.ll_root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ll_sortpart==<span class="keyword">null</span>) &#123;</span><br><span class="line">        ll_sortpart = (LinearLayout) ll_root.findViewById(R.id.ll_sortpart);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mViews.size()&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mArray.length; i++) &#123;</span><br><span class="line">            View view = <span class="keyword">new</span> View(<span class="keyword">this</span>);</span><br><span class="line">            ll_sortpart.addView(view);</span><br><span class="line">            LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) view.getLayoutParams();</span><br><span class="line">            columnWidth = (screenWidth - DensityUtil.dp2px(<span class="keyword">this</span>, paddingLR * <span class="number">2</span>)) / mArray.length</span><br><span class="line">                        -DensityUtil.dp2px(<span class="keyword">this</span>, intervalColumn);</span><br><span class="line">            layoutParams.setMargins(DensityUtil.dp2px(<span class="keyword">this</span>, intervalColumn), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            layoutParams.height = (<span class="keyword">int</span>) (mArray[i] * pixPerNum());</span><br><span class="line">            layoutParams.width = columnWidth;</span><br><span class="line">            view.setLayoutParams(layoutParams);</span><br><span class="line">            view.setBackgroundColor(ContextCompat.getColor(<span class="keyword">this</span>, R.color.colorPrimaryDark));</span><br><span class="line">            mViews.add(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//获得在高度上，单位数字所代表的像素，由于屏幕高度是像素，而我们的排序为int数字，要想形象化绘制成柱状图</span></span><br><span class="line"><span class="comment">//就要计算出单位数字的像素，然后通过数组中的数字相乘即可得到柱状view的高度了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">pixPerNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    columnPixPerNum=(<span class="keyword">double</span>) screenHeight*<span class="number">0.6</span>/(Max(mArray));</span><br><span class="line">    <span class="keyword">return</span> columnPixPerNum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得数组中最大数字，仅仅用于@pixPerNum方法中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max&lt;array[i])&#123;</span><br><span class="line">            max=array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="排序同时界面更新"><a href="#排序同时界面更新" class="headerlink" title="排序同时界面更新"></a>排序同时界面更新</h3><ol><li>界面的中每个柱状View与数组一一对应，这样我们只需要记住排序数组的下标就可以同步View数组了。</li><li>排序是耗时操作，我们需要开启线程进行排序，因此需要用到消息传递来通知界面的变化，这里主要使用<strong>Handler</strong>来进行处理线程消息。</li><li>整个流程为：在开启排序时，算法中的数组在进行数据交换时，我们会记录此时交换数据的两个下标，同时将这些数据包装成消息发送给<strong>Handler</strong>,<strong>Handler</strong>将界面柱状View数组中两个相同下标的View高度互换，达到界面显示与排序一致的效果。</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (currentSortKind)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//快速</span></span><br><span class="line">                quicksort(mArray,<span class="number">0</span>,mArray.length-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//堆</span></span><br><span class="line">                HeadSort(mArray,mArray.length);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//归并</span></span><br><span class="line">                <span class="keyword">int</span>[] mtemp=<span class="keyword">new</span> <span class="keyword">int</span>[SIEZ_ARRAY];</span><br><span class="line">                MergeSort(mArray,mtemp,<span class="number">0</span>,mArray.length-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//插入</span></span><br><span class="line">                insertsort(mArray,<span class="number">0</span>,mArray.length-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//冒泡</span></span><br><span class="line">                bubblesort(mArray,<span class="number">0</span>,mArray.length-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:<span class="comment">//选择</span></span><br><span class="line">                selectsort(mArray,<span class="number">0</span>,mArray.length-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        handler.sendEmptyMessage(WHAT_SORT_FINISH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startIndex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> endIndex</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectsort</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,minIndex;</span><br><span class="line">    <span class="keyword">for</span>(i=startIndex;i&lt;endIndex;i++)&#123;</span><br><span class="line">        minIndex=i;</span><br><span class="line">        <span class="comment">//选出最小下标，放在最前面</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=endIndex;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[minIndex]&gt;array[j])&#123;</span><br><span class="line">                minIndex=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minIndex!=i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=array[i];</span><br><span class="line">            array[i]=array[minIndex];</span><br><span class="line">            array[minIndex]=temp;</span><br><span class="line">            <span class="comment">//此处发送消息通知Handler更新View层变化</span></span><br><span class="line">            sleepAndSendMessage(i,minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换两个View的高度，这是Handler处理界面变化的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapColumHeight</span><span class="params">(View viewone,View viewtwo)</span></span>&#123;</span><br><span class="line">    LinearLayout.LayoutParams paramsone= (LinearLayout.LayoutParams) viewone.getLayoutParams();</span><br><span class="line">    LinearLayout.LayoutParams paramstwo= (LinearLayout.LayoutParams) viewtwo.getLayoutParams();</span><br><span class="line">    <span class="keyword">int</span> temp=paramsone.height;</span><br><span class="line">    paramsone.height=paramstwo.height;</span><br><span class="line">    paramstwo.height=temp;</span><br><span class="line">    viewone.setLayoutParams(paramsone);</span><br><span class="line">    viewtwo.setLayoutParams(paramstwo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="排序延迟操作"><a href="#排序延迟操作" class="headerlink" title="排序延迟操作"></a>排序延迟操作</h3><p>由于排序算法只有在对数以万计的数据时才会有可见的时间长度，因而我们如果像正常一样设置排序和界面更新时，每个排序算法都几乎在毫秒级别完成，并且界面变化几乎不可见。</p><p>因此，我们需要让排序算法尽可能地延长一定时间，达到界面的变化可视化级别。</p><p>我们在数组交换数据时发送消息给 <strong>Handler</strong> 处进行了一定的时间延迟，当然不会过长，此处设置了 <strong>10ms</strong>。( 也同时因为这样的设置，界面显示的耗时操作实际上并非算法真正的排序时间，而应该减去延迟时间乘以延迟操作的次数。)</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换的信号</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleepAndSendMessage</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//此处延迟10ms</span></span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        Message message=<span class="keyword">new</span> Message();</span><br><span class="line">        message.what=WHAT_SORT_SWAP_VIEW;</span><br><span class="line">        message.arg1=i;</span><br><span class="line">        message.arg2=j;</span><br><span class="line">        handler.sendMessage(message);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="三、动画演示"><a href="#三、动画演示" class="headerlink" title="三、动画演示"></a>三、动画演示</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><img src="http://img.godjiyi.cn/jysortfast.gif" alt="fast"></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="http://img.godjiyi.cn/jysortheap.gif" alt="heap"></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img src="http://img.godjiyi.cn/jysortmerge.gif" alt="merge"></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><img src="http://img.godjiyi.cn/jysortinsert.gif" alt="insert"></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><img src="http://img.godjiyi.cn/jysortbubble.gif" alt="bubble"></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p><img src="http://img.godjiyi.cn/jysortselect.gif" alt="select"></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="项目-1"><a href="#项目-1" class="headerlink" title="项目"></a>项目</h3><ol><li>Android图形化排序地址：<a href="https://github.com/jiyiren/JYSort" target="_blank" rel="noopener">https://github.com/jiyiren/JYSort</a></li><li>C实现排序项目地址：<a href="https://github.com/jiyiren/CSort" target="_blank" rel="noopener">https://github.com/jiyiren/CSort</a></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.cnblogs.com/jingmoxukong/p/4308823.html" target="_blank" rel="noopener">http://www.cnblogs.com/jingmoxukong/p/4308823.html</a></li><li><a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="noopener">http://blog.csdn.net/morewindows/article/details/6684558</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot; style=&quot;margin: 30px 0 35px;&quot;&gt;排序算法不好理解？那就来个 GUI 的!&lt;/p&gt;

&lt;p&gt;上篇C语言实现各排序算法的完成，使得自己对排序有了一定的了解，最近看到一个 &lt;em&gt;iOS&lt;/em&gt; 图形化排序过程，因此今天就完成 &lt;em&gt;Android&lt;/em&gt; 端的图形化排序过程。&lt;/p&gt;
&lt;p&gt;排序算法实现很简单，其重点是要实现安卓 &lt;strong&gt;View&lt;/strong&gt; 跟随排序的动态变化。&lt;/p&gt;
&lt;p&gt;由于计算机执行排序算法的高效性，对一定数量的数组排序都是 &lt;strong&gt;毫秒级&lt;/strong&gt; 的，因此我们要考虑 &lt;strong&gt;放大排序时间&lt;/strong&gt;，给可视化界面完整的动态过程。&lt;/p&gt;
&lt;h2 id=&quot;一、总体功能界面&quot;&gt;&lt;a href=&quot;#一、总体功能界面&quot; class=&quot;headerlink&quot; title=&quot;一、总体功能界面&quot;&gt;&lt;/a&gt;一、总体功能界面&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;界面&quot;&gt;&lt;a href=&quot;#界面&quot; class=&quot;headerlink&quot; title=&quot;界面&quot;&gt;&lt;/a&gt;界面&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://img.godjiyi.cn/jysortwelcome.gif&quot; alt=&quot;maingif&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://www.godjiyi.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.godjiyi.cn/tags/Android/"/>
    
  </entry>
  
</feed>
