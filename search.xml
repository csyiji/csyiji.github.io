<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 中的编码问题</title>
    <url>/2016/03/22/Java_encode/</url>
    <content><![CDATA[<p>今天写 <strong>Java</strong> 读文件时遇到编码问题，搜索了一晚上终于搞懂了这块问题。下面记录一下自己的笔记。</p>
<h2 id="一、问题："><a href="#一、问题：" class="headerlink" title="一、问题："></a>一、问题：</h2><p>今天用 <strong>Java</strong> 写了一个读文件的，我用 <em>eclipse</em> 新建一个 utf-8 无 bom 编码的 txt 文件，叫做 <strong>ch.txt</strong>, 只写一个汉字: <strong>吉</strong>, 完成后内容：</p>
<p><img src="http://img.godjiyi.cn/javafile1.png" alt="ch.txt内容"></p>
<p>然后右击查看文件的属性：</p>
<p><img src="http://img.godjiyi.cn/javafile222.png" alt="enter image description here"></p>
<a id="more"></a>
<p>读文件的代码为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiyiren.fileio;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mfread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		FileReader fr=<span class="keyword">null</span>;</span><br><span class="line">		File f1=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			f1=<span class="keyword">new</span> File(<span class="string">"ch.txt"</span>);</span><br><span class="line">			fr=<span class="keyword">new</span> FileReader(f1);</span><br><span class="line">			<span class="keyword">char</span>[] c=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>((len=fr.read(c))!=-<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">					System.out.println(c[i]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(fr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					fr.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>输出结果为：</p>
<p><img src="http://img.godjiyi.cn/javafile3.png" alt="enter image description here"></p>
<p>上面的代码与结果完全正确，那问题是什么呢？我们都知道 <strong>Java</strong> 中的 <em>char</em> 是 2 个字节，但是我们文件里保存的那个中文为 3 字节，读文件时我们也只用</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>]</span><br></pre></td></tr></table></figure></div>
<p><em>一个 char 类型读，但是结果为什么正确呢？java 中的 char 类型是Unicode 型的 2 个字节又是什么意思？文件保存的 utf-8格式与 Unicode 有什么关系呢？</em> 下面我就讲下我的理解。</p>
<h2 id="二、Unicode-编码"><a href="#二、Unicode-编码" class="headerlink" title="二、Unicode 编码"></a>二、Unicode 编码</h2><p><strong>Unicode</strong> 编码的出现是为了解决世界上各种不同字符编码不一致的问题的，因为互联网的兴起，迫切需要这种统一世界上所有字符的编码。<strong>Unicode</strong> 当然是一个很大的集合，现在的规模可以容纳 100 多万个符号，每个符号的编码都不一样，比如：<strong>U+0639</strong> 表示阿拉伯字母 Ain，<strong>U+0041</strong> 表示英语的大写字母 A，<strong>U+4E25</strong> 表示汉字 “严”。</p>
<p><strong>Unicode</strong> 编码以二进制代码格式规定了符号的唯一标识，<strong>它是一个符号集</strong>，它仅仅是给世界上各个字符规定了编码，但是它没有规定标识这些字母的二进制该如何存储。比如有的字符用 1 个字节就可以标识，但是有的字符要4个字节标识，如果都用4个字节标识每一个字符，那将会造成巨大的存储浪费，但是不这样存储又能有什么更好的存储方法呢？UTF-8 存储方式应运而生。</p>
<h2 id="三、UTF-8-存储-编码"><a href="#三、UTF-8-存储-编码" class="headerlink" title="三、UTF-8 ( 存储 ) 编码"></a>三、UTF-8 ( 存储 ) 编码</h2><p>我们所知道的 <strong>UTF-8</strong> 编码，实际上它并非规定了字符的编码方式 ( 字符编码是由 <strong>Unicode</strong> 规定的 )，它只是规定怎么存储 <strong>Unicode</strong> 编码好的字符二进制数据，因而 UTF-8 编码默认包含了 <strong>Unicode</strong> 编码，我们通常所说的 UTF-8，实际上就是 <strong>Unicode UTF-8</strong> 编码。</p>
<p><strong>UTF-8</strong> 是 Unicode 实现存储编码的一种方式，它最大的特点就是它是一种变长的编码方式。它可以使用 1~4 个字节表示一个符号，根据不同的符号而变化字节长度，这也就解决了 <strong>Unicode</strong> 编码用 4 个字节存储而浪费存储资源的问题了。</p>
<p><strong>UTF-8编码的规则：</strong></p>
<ol>
<li>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 <strong>Unicode</strong> 码。因此对于英文字母，UTF-8 编码和 ASCII 码是相同的。</li>
<li>对于n字节的符号(n&gt;1),第一个字节的前n位都设为1，第 n+1 位设为0，后面字节的前两位一律设为 10。剩下的所有没有提及的二进制位，全部为这个符号的 <strong>Unicode</strong> 码。</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">    Unicode符号范围  |  UTF-8编码存储方式</span><br><span class="line">	(十六进制范围)| (二进制)</span><br><span class="line">0000 0000~0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080~0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800~0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000~0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure>
<p>根据上表，以UTF-8 编码，如果一个字节的二进制的第一位是0，则这个字节单独就是一个字符，如果第一位是1，则连续有多少个1就表示该字符占有多少个字节。</p>
<p>汉字的 <strong>Unicode</strong> 编码表可以查看：<a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">http://www.chi2ko.com/tool/CJK.htm</a> 或者 <a href="http://www.unicode.org/" target="_blank" rel="noopener">Unicode官网</a> 然后我以汉字 “<strong>吉</strong>” 为例，演示将 “吉” 以 UTF-8 方式存储 “吉” 的 <strong>Unicode</strong> 编码的过程。</p>
<p>“吉”的Unicode编码十六进制数为 <strong>5409</strong>, 对应的二进制为 <strong>0101 0100 0000 1001</strong>; 因为 <strong>5409</strong> 把前面的全为 0 的 2 字节省略了，我们把它补上就是 <strong>0000 5409</strong>, 现在根据上表的左边一栏，可以知道该数在第三行范围里，所以 “<strong>吉</strong>” 的 UTF-8 编码占 3 字节，我们直接将第三行的右边栏中的 x 号换成 “<strong>吉</strong>” 二进制就可以了，最后结果：<strong>11100101 10010000 10001001</strong>，这个就是 “吉” 字的 Unicode 的 UTF-8 编码的存储字节形式。</p>
<h2 id="四、解决问题"><a href="#四、解决问题" class="headerlink" title="四、解决问题"></a>四、解决问题</h2><p>讲了这么多问题一点没有提到啊，我们根据上面的UTF-8的存储过程可以知道，中文 “吉” 的 <strong>Unicode</strong> 编码为 <strong>5409</strong>, 不用 <strong>UTF-8</strong> 存储表示时，“吉” 应该只占用两个字节，也就是说 <em>java</em> 中的 <em>char</em> 是 2 个字节完全可以存储的，但是这个存储只能在内存中，而如果写入文件，必须用到编码，而我们用的是 UTF-8 编码，由上面的转换过程可以知道，中文 “<strong>吉</strong>” 字的 <strong>Unicode</strong> 码的 <strong>UTF-8</strong> 形式需要 3 个字节的，所以保存在文件里时文件所占用的存储空间为 <em>3 byte</em>, 到这里我想大家应该都明白了为什么存在文件中的字是3个字节，而读出来的竟然用 char 就可以存储了的原因了。</p>
<p><em>Java</em> 中在文件数据与内存数据转换时肯定会涉及到编码的，其实不论java语言了其他语言都有的，只不过这些语言的通常做法都是使用默认的编码方式，但是我们必须要明白这其中的原理，不然以后出现一点乱码都将会是头痛的问题！！！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a></li>
<li><a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">http://www.chi2ko.com/tool/CJK.htm</a></li>
<li><a href="http://blog.csdn.net/ocean20/article/details/6743385" target="_blank" rel="noopener">http://blog.csdn.net/ocean20/article/details/6743385</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Encode</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 中的定时任务</title>
    <url>/2016/03/27/Mysql_schedule/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">MySQL 5 开启定时任务</p>

<p>最近项目里面的后台需要用到定时任务，而 <strong>MySQL</strong> 从 <em>5.0</em> 开始自带了定时事件操作，所以学习下并做下记录。</p>
<p>后台周期定时任务可以有多种解决方案，我所知道的大概有以下几种：</p>
<p>(1). 后台框架自带定时任务。比如 <strong>Php</strong> 中的 <strong>Laravel</strong> 框架里有提供定时任务操作接口，其他的框架大家可以单独针对了解。</p>
<p>(2). 服务器操作系统层面的定时。通常我们的服务器主要基于两大平台，一个 <strong>Windows Server</strong>, 它的定时任务系统有提供的。<strong>Linux</strong> 下也有，通常流行的是 <code>crontab</code> 工具实现的 ( 想了解这里有个 <a href="http://www.imooc.com/learn/216" target="_blank" rel="noopener">视频教程</a> ), 但是 <code>crontab</code> 的定时任务通常定时操作脚本这样的文件，而直接定时操作数据库的就比较麻烦了。但是也有解决办法，就是在服务器端写一个 <code>get</code> 请求 <code>url</code>，在后台里完成要定时完成的数据库操作，这样我们只要实现定时访问该接口就行了，<strong>Linux</strong> 下的 <code>curl</code> 命令可以很方便发出 <code>get</code> 请求，我们只要写个包含访问该接口的脚本，再结合 <code>crontab</code> 就可以完成后台数据的定时更新操作了。</p>
<p>(3). 但是毕竟写个接口安全性不是太高，而大家用的如果是 <strong>MySQL</strong> 数据库，那就正好可以利用其自带的定时操作了，下面简单介绍 <strong>MySQL</strong> 定时操作的使用。</p>
<a id="more"></a>
<h2 id="MySQL-配置"><a href="#MySQL-配置" class="headerlink" title="MySQL 配置"></a>MySQL 配置</h2><p>查看定时策略是否开启，查看命令:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%event_sche%'</span>;</span><br></pre></td></tr></table></figure></div>
<p>显示的 <strong>event_scheduler</strong> 为 <em>OFF</em> 时用以下命令开启:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> event_scheduler=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>
<p>以上的改法在数据库重启后将会恢复为原来状态，要想数据库重启后也可以让 <strong>event_scheduler</strong> 开启，则需要在配置文件 <code>my.ini</code> 的设置。修改如下，然后重启 <strong>MySQL</strong> 服务即可:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">event_scheduler=ON // 这一行加入 mysqld 标签下</span><br></pre></td></tr></table></figure></div>
<h2 id="创建-procedure-存储过程"><a href="#创建-procedure-存储过程" class="headerlink" title="创建 procedure ( 存储过程 )"></a>创建 procedure ( 存储过程 )</h2><hr>
<h3 id="什么是-procedure-存储过程-？"><a href="#什么是-procedure-存储过程-？" class="headerlink" title="什么是 procedure ( 存储过程 ) ？"></a>什么是 procedure ( 存储过程 ) ？</h3><p>存储过程？当我听到这个词的时候，以为它是 <strong>MySQL</strong> 存储数据的一个流程而不是一个名词，但是当我网上了解时，才知道这个词是翻译过来的，原生词为 <strong>Procedure</strong>, 实际上它的含义就是相当于我们面向对象里的方法或者说是 <strong>函数</strong>，在它里面可以完成多个 <code>sql</code> 语句的操作，并且可以定义参数传值等，与一般的单条 <code>sql</code> 语句的区别主要在这里，详细了解 <a href="http://xdj651897373-126-com.iteye.com/blog/1819924" target="_blank" rel="noopener">点我</a>。</p>
<h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p>先上一段创建存储过程代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line">delimiter //</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test_proce()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> weuse(<span class="keyword">name</span>,created_at,updated_at) <span class="keyword">values</span>(<span class="string">'hello'</span>,<span class="keyword">now</span>(),<span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">end</span>//</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure></div>
<p><img src="http://img.godjiyi.cn/mysql4.png" alt="enter image description here"></p>
<p>上面的代码说明：</p>
<p>(1). <code>use test;</code> : 这个谁都知道，使用某个数据库，这里要强调的是存储过程一定是对于某个数据库而言的，所以必须要选中一个数据库才能创建成功。</p>
<p>(2). <code>delimiter //</code> : 这个是将 <strong>MySQL</strong> 中以 <strong>;(分号)</strong> 结尾的规定修改为以 <strong>//(双斜杠)</strong> 为语句结束符，因为存储过程里可以有多条 <code>sql</code> 语句，里面的 <code>sql</code> 语句都以 <strong>;</strong> 号结尾，如果回车了那么系统会当做 <code>sql</code> 语句直接执行了，我们希望的是先定义这一系列 <code>sql</code> 语句而先不执行，所以要改下操作结束符。当然你在改后一定要改回来，大家可以看到最后一行有对应的修改回来的语句。</p>
<p>(3). 下面所示的语句则是一起输入的，可以知道分别是创建存储过程 <em>test_proce()</em>, 名称可以随便起的，然后是在 <code>begin --end</code> 之间是定义一系列 <code>sql</code> 语句的就可以了，记住最后 <code>end</code> 结尾要以之前修改后的结尾符 <code>//</code> 结束。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test_proce()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> weuse(<span class="keyword">name</span>,created_at,updated_at) <span class="keyword">values</span>(<span class="string">'hello'</span>,<span class="keyword">now</span>(),<span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">end</span>//</span><br></pre></td></tr></table></figure></div>
<h2 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h2><hr>
<p>上面创建存储过程实际上是为 <strong>定时任务</strong> 做铺垫的，因为上面只说明了怎么创建存储过程，但是未说明怎么调用，那这里就用到了调用存储过程了。</p>
<h3 id="创建定时任务-event-事件"><a href="#创建定时任务-event-事件" class="headerlink" title="创建定时任务 event ( 事件 )"></a>创建定时任务 event ( 事件 )</h3><p>依旧先上创建定时任务事件代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">event</span> second_event</span><br><span class="line"><span class="keyword">on</span> schedule every <span class="number">1</span> <span class="keyword">second</span></span><br><span class="line"><span class="keyword">on</span> completion <span class="keyword">preserve</span> <span class="keyword">disable</span></span><br><span class="line"><span class="keyword">do</span> <span class="keyword">call</span> test_proce();</span><br></pre></td></tr></table></figure></div>
<p><img src="http://img.godjiyi.cn/mysql5.png" alt="enter image description here"></p>
<p>代码说明：</p>
<ol>
<li>上面为整体代码，敲完再写分号；</li>
<li>第一行 <strong>create event day_event</strong> 是创建名为 <em>second_event</em> 的事件,注意此处没有括号；</li>
<li>第二行是创建周期定时的规则，本处的意思是每秒钟执行一次；</li>
<li>第三行 <strong>on completion preserve disable</strong> 是表示创建后并不开始生效；</li>
<li>第四行 <strong>do call test_proce()</strong> 是该 <em>event(事件)</em> 的操作内容，表示调用我们刚刚创建的 <em>test_proce()</em> 存储过程。</li>
</ol>
<h3 id="查看定时任务-event-事件"><a href="#查看定时任务-event-事件" class="headerlink" title="查看定时任务 event ( 事件 )"></a>查看定时任务 event ( 事件 )</h3><p>查看本机所有的事件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> event_name,event_definition,interval_value,interval_field,<span class="keyword">status</span> <span class="keyword">FROM</span> information_schema.EVENTS;</span><br></pre></td></tr></table></figure></div>
<p><img src="http://img.godjiyi.cn/mysql6.png" alt="enter image description here"></p>
<h3 id="开启已经创建好的-event-事件"><a href="#开启已经创建好的-event-事件" class="headerlink" title="开启已经创建好的 event ( 事件 )"></a>开启已经创建好的 event ( 事件 )</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">event</span> second_event <span class="keyword">on</span> completion <span class="keyword">preserve</span> <span class="keyword">enable</span>;//开启定时任务</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">event</span> second_event <span class="keyword">on</span> completion <span class="keyword">preserve</span> <span class="keyword">disable</span>;//关闭定时任务</span><br></pre></td></tr></table></figure></div>
<p>当我们用第一句命令开启定时任务时，可以就可以查看数据库情况，已经实现了 <strong>每秒钟执行一次</strong> 了，如图：</p>
<p><img src="http://img.godjiyi.cn/mysql7.png" alt="enter image description here"></p>
<p>要想关闭定时任务只要执行上面的第二句命令，关闭需要关闭的定时任务就可以了。</p>
<h3 id="常见周期定时规则"><a href="#常见周期定时规则" class="headerlink" title="常见周期定时规则"></a>常见周期定时规则</h3><p><strong>① 周期执行 – 关键字 EVERY</strong></p>
<p>单位有：<strong>second, minute, hour, day, week(周), quarter(季度), month, year</strong>，如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">on schedule every 1 second		//每秒执行1次</span><br><span class="line">on schedule every 2 minute		//每两分钟执行1次</span><br><span class="line">on schedule every 3 day			//每3天执行1次</span><br></pre></td></tr></table></figure></div>
<p><strong>② 在具体某个时间执行 – 关键字 AT</strong>, 如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">on schedule at current_timestamp()+interval 5 day	// 5天后执行</span><br><span class="line">on schedule at current_timestamp()+interval 10 minute	// 10分钟后执行</span><br><span class="line">on schedule at '2016-10-01 21:50:00'		// 在2016年10月1日，晚上9点50执行</span><br></pre></td></tr></table></figure></div>
<p><strong>③ 在某个时间段执行 – 关键字 STARTS ENDS</strong>, 如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">on schedule every 1 day starts current_timestamp()+interval 5 day ends current_timestamp()+interval 1 month // 5天后开始每天都执行执行到下个月底</span><br><span class="line">on schedule every 1 day ends current_timestamp()+interval 5 day //从现在起每天执行，执行5天</span><br></pre></td></tr></table></figure></div>
<h2 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h2><hr>
<h3 id="MysqlWorkBench"><a href="#MysqlWorkBench" class="headerlink" title="MysqlWorkBench"></a>MysqlWorkBench</h3><p>是官方推荐的免费可视化 <strong>MySQL</strong> 操作工具，方便建模，<em>ER</em> 图操作，经我发现好像只能可视化操作存储过程，没看到有定时任务的 ( 也可能是自己没找到 )。</p>
<p>存储过程示例如下：</p>
<p><img src="http://img.godjiyi.cn/mysql8.png" alt="enter image description here"></p>
<p>对于 <strong>Event</strong> 事件，可以查看，用 <code>sql</code> 命令</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.EVENTS;	// 查看所有事件属性</span><br><span class="line"><span class="keyword">SELECT</span> event_name,event_definition,interval_value,interval_field,<span class="keyword">status</span> <span class="keyword">FROM</span> information_schema.EVENTS;	// 查看主要几个属性</span><br></pre></td></tr></table></figure></div>
<p><img src="http://img.godjiyi.cn/mysql9.png" alt="enter image description here"></p>
<h4 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a>Navicat</h4><p>这个是收费的软件，但是可视化操作比较轻量级，功能也很多，它可以可视化操作存储过程和<strong>Event</strong> 事件，详细操作大家可以自己摸索啊！！</p>
<p><img src="http://img.godjiyi.cn/mysql10.png" alt="enter image description here"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Schedule</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 开发中 dp、dpi、px 的区别</title>
    <url>/2015/07/26/android-dp-dip/</url>
    <content><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><ul>
<li><strong>dp</strong>：安卓中的相对大小</li>
<li><strong>dpi</strong>：( <em>dot per inch</em> )每英寸像素多少</li>
<li><strong>px</strong>：像素点</li>
</ul>
<h2 id="二、详细说明"><a href="#二、详细说明" class="headerlink" title="二、详细说明"></a>二、详细说明</h2><h3 id="px和dpi"><a href="#px和dpi" class="headerlink" title="px和dpi"></a>px和dpi</h3><p><strong>px</strong></p>
<p>平常所说的 <em>1920×1080</em> 只是像素数量，也就是 1920px×1080px, 代表手机高度上有 1920 个像素点，宽度上有 1080 个像素点。</p>
<a id="more"></a>
<p><strong>dpi</strong></p>
<p>要想判别手机屏幕的显示好坏，还要考虑屏幕的宽高(英寸)，也就是用 <em>dpi</em> 即每英寸多少像素来评价屏幕的显示效果。（不然假如手机分辨率是 1920×1080, 但是屏幕是几十寸的，那显示效果将不会很好，甚至你有可能看到小的像素块，那将更影响视觉效果。）</p>
<p><strong>dp</strong></p>
<p><em>怎样理解 dp 才好呢 ?</em></p>
<ul>
<li>其实 dp 就是为了使得开发者设置的长度能够根据不同屏幕( 分辨率/尺寸也就是 dpi )获得不同的像素 ( px ) 数量。比如：我将一个控件设置长度为 1dp, 那么在 <em>160dpi</em> 上该控件长度为 1px, 在 <em>240dpi</em> 的屏幕上该控件的长度为 1 * 240 / 160 = 1.5 个像素点。</li>
<li><strong>也就是dp会随着不同屏幕而改变控件长度的像素数量。</strong></li>
<li>关于dp的官方叙述为当屏幕每英寸有 160个 像素时( 也就是 <em>160dpi</em> )，dp与px等价的。那如果每英寸 240 个像素呢？1dp —&gt;1*240/160=1.5px，即 1dp 与 1.5px 等价了。</li>
<li>其实记住一点，<strong>dp 最终都要化为像素数量来衡量大小的，因为只有像素数量最直观。</strong></li>
</ul>
<p><strong>计算dp的方法:</strong></p>
<ul>
<li>通常来说，我们写程序时几乎没用到计算dp，就是直接凭着自己的感觉写的。此处计算dp只是为了大家更好理解dp，如果有的人想精确设置控件大小，也可以这样计算的。</li>
<li>我直接画张图吧：<br><img src="http://img.godjiyi.cn/csdnblogImage.png" alt></li>
<li>计算dp往往是由程序员完成的，是创造的过程，顺叙的过程。但是写程序总会有两个历程的，一个是进行写，一个是返回读，这个读的话就用到了将 <em>dp</em> 转换了。</li>
</ul>
<p><strong>dp转px—(最常用的方法):</strong></p>
<ul>
<li>前面已经看到一个例子了如下(注：等号都是等价，是理解上的等于，不是直接的等于的)：安卓中如果手机每英寸有 <em>160px</em>，即手机是 <em>160dpi</em>，那么此时1dp就可以理解为1px，假如现在手机是240dpi，那么1dp=240/160 px=1.5px，<br><strong>从上可以看出dp转px只与屏幕的dpi有关。</strong></li>
<li>对于 <strong>Android</strong> 来说，最终我们能读懂或者衡量的都是px，所以最后我们都将dp化为px好理解一点。我总结了dp转px的公式如下：</li>
<li><strong>公式：dp值×（当前dpi/160dpi）=&gt;得出当前的像素数目</strong></li>
</ul>
<h3 id="手机屏幕dp最大值是多少？"><a href="#手机屏幕dp最大值是多少？" class="headerlink" title="手机屏幕dp最大值是多少？"></a>手机屏幕dp最大值是多少？</h3><ul>
<li>那么问题来了，一个手机屏幕最大有多大的dp呢，我能不能设置成 <em>100000dp</em> 呢？其实这也是我所思考的，下面我慢慢来讲。</li>
<li>假如现在将控件宽度设置为 160dp, 那不同 <em>dpi</em> 的手机所得到的像素是多少呢？<br><img src="http://img.godjiyi.cn/csdnblogt.png" alt><br><strong>从中可以看出最后所得像素值与dpi值相同，也就是说不管什么屏幕160dp，就相当于1英寸。</strong></li>
<li>所以要得到全屏最长的的dp，就等于<strong>160*宽(或者高英寸长)</strong><br>如第三个 1080*1920例子，160*3 = 480dp，所以 0-480dp 就是宽的 dp 范围。因为480*360/160=1080 个像素，正好等于宽的最大像素数量。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>dp</tag>
        <tag>px</tag>
        <tag>像素</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 中多选 ListView 的实现</title>
    <url>/2015/07/25/android-multiselected-listview/</url>
    <content><![CDATA[<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><h3 id="开始效果"><a href="#开始效果" class="headerlink" title="开始效果"></a>开始效果</h3><p><img src="http://img.godjiyi.cn/csdnblog11.png" alt></p>
<a id="more"></a>
<h3 id="多选后点击按钮效果"><a href="#多选后点击按钮效果" class="headerlink" title="多选后点击按钮效果"></a>多选后点击按钮效果</h3><p><img src="http://img.godjiyi.cn/csdnblog22.png" alt></p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="添加ListView"><a href="#添加ListView" class="headerlink" title="添加ListView"></a>添加ListView</h3><p>layout布局中添加ListView，将 <code>android:choiceMode=&quot;multipleChoice&quot;</code>属性设置成这样</p>
<h3 id="自定义item布局"><a href="#自定义item布局" class="headerlink" title="自定义item布局"></a>自定义item布局</h3><p>自定义ListView的item布局，这个布局和非多选的ListView的item布局设置一样。效果如下：</p>
<p><img src="http://img.godjiyi.cn/csdnblog33.png" alt></p>
<h3 id="自定义itemview"><a href="#自定义itemview" class="headerlink" title="自定义itemview"></a>自定义itemview</h3><p>为ListView的item布局写一个自定义View。正常的ListView实现时，item的布局是在自定义adapter里实现的，但是因为本ListView 是多选，如果只在adapter里调用item的Layout布局则不能实现多选。因为多选的ListView要求单个item的最外层布局要实现<code>Checkable</code>接口，这样多选ListView就能自己调用实现好的接口提供多选结果给我们。<br>自己写的View如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> JIYI</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleChoiceListItem</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> <span class="keyword">implements</span> <span class="title">Checkable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> CheckBox mCheckBox;</span><br><span class="line">	<span class="keyword">private</span> TextView mTextView;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MultipleChoiceListItem</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(context);</span><br><span class="line">		initview(context);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MultipleChoiceListItem</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(context, attrs);</span><br><span class="line">		initview(context);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MultipleChoiceListItem</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">		initview(context);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initview</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">		LayoutInflater inflater=LayoutInflater.from(context);</span><br><span class="line">		View v=inflater.inflate(R.layout.choicelistitem, <span class="keyword">this</span>,<span class="keyword">true</span>);</span><br><span class="line">		mCheckBox=(CheckBox) v.findViewById(R.id.syminfo_item_cb);</span><br><span class="line">		mTextView=(TextView) v.findViewById(R.id.syminfo_item_tv);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">		mTextView.setText(text);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChecked</span><span class="params">(<span class="keyword">boolean</span> checked)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		mCheckBox.setChecked(checked);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isChecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> mCheckBox.isChecked();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toggle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		mCheckBox.toggle();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="自定义-Adapter"><a href="#自定义-Adapter" class="headerlink" title="自定义 Adapter"></a>自定义 Adapter</h3><p>主要是 <code>getView()</code> 方法里要用到刚刚自定义的 <em>View</em>. 为什么直接new 一个对象，就是让 item 的最外层布局是实现了 <code>Checkable</code> 接口的控件。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleLvAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; mlistdata;</span><br><span class="line">	<span class="keyword">private</span> Context context;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MultipleLvAdapter</span><span class="params">(List&lt;String&gt; mlistdata,Context context)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="keyword">this</span>.mlistdata=mlistdata;</span><br><span class="line">		<span class="keyword">this</span>.context=context;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> mlistdata.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> mlistdata.get(position);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> position;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasStableIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		MultipleChoiceListItem choicelistitem=<span class="keyword">new</span> MultipleChoiceListItem(context);</span><br><span class="line">		choicelistitem.setText(mlistdata.get(position));</span><br><span class="line">		<span class="keyword">return</span> choicelistitem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>在 <code>Activity</code> 中调用即可。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> JIYI</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtyMultipleListView</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ListView mlistview;</span><br><span class="line">	<span class="keyword">private</span> MultipleLvAdapter madapter;</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; mlistdata=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.atymultiplelistview);</span><br><span class="line">		mlistview=(ListView) findViewById(R.id.multiplelv);</span><br><span class="line">		getData();</span><br><span class="line">		madapter=<span class="keyword">new</span> MultipleLvAdapter(mlistdata, <span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">/*ArrayAdapter&lt;String&gt; arrayAdapter=new ArrayAdapter&lt;&gt;(this, </span></span><br><span class="line"><span class="comment">				android.R.layout.simple_list_item_multiple_choice, objects);*/</span></span><br><span class="line">		mlistview.setAdapter(madapter);</span><br><span class="line">		</span><br><span class="line">		findViewById(R.id.multiplebt).setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">		mlistdata.add(<span class="string">"苏州大学"</span>);</span><br><span class="line">		mlistdata.add(<span class="string">"南京大学"</span>);</span><br><span class="line">		mlistdata.add(<span class="string">"浙江大学"</span>);</span><br><span class="line">		mlistdata.add(<span class="string">"北京大学"</span>);</span><br><span class="line">		mlistdata.add(<span class="string">"清华大学"</span>);</span><br><span class="line">		mlistdata.add(<span class="string">"扬州大学"</span>);</span><br><span class="line">		mlistdata.add(<span class="string">"哈哈大学"</span>);</span><br><span class="line">		mlistdata.add(<span class="string">"哈哈大学"</span>);</span><br><span class="line">		mlistdata.add(<span class="string">"呵呵大学"</span>);</span><br><span class="line">		mlistdata.add(<span class="string">"咯咯大学"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">		<span class="keyword">case</span> R.id.multiplebt:</span><br><span class="line">			okClick();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">okClick</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//保证自定义的MultipleLvAdapter里面的hasStableIds()方法返回true</span></span><br><span class="line">		<span class="keyword">long</span> selected[]=mlistview.getCheckedItemIds();</span><br><span class="line">		<span class="comment">//int count=mlistview.getCheckedItemCount();这是获取选中的总数</span></span><br><span class="line">		String str=<span class="string">"您选中了："</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selected.length; i++) &#123;</span><br><span class="line">			str=str+mlistdata.get(((<span class="keyword">int</span>)selected[i]))+<span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Toast.makeText(AtyMultipleListView.<span class="keyword">this</span>, str, Toast.LENGTH_SHORT).show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li><p>如果要在 <em>Adapter</em> 里直接用 <em>item</em> 的布局，可以将 <em>item</em> 布局的最外层的 <em>Layout</em> 控件改为自己实现 <code>Checkable</code> 接口的控件即可。</p>
</li>
<li><p><em>item</em> 中的图标更换，是在 <em>item</em> 布局中 <code>CheckBox</code> 控件的 <code>background</code> 更改的。你只需在 <code>drawable</code> 文件夹下新建一个 <code>checkboxbutton_bac.xml</code> 的文件,在里面写一个 <code>selector</code> 即可，如下：</p>
</li>
</ul>
<blockquote>
<blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/btn_check_on_holo_light"</span> <span class="attr">android:state_checked</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/btn_check_off_holo_light"</span> <span class="attr">android:state_checked</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</blockquote>
</blockquote>
<p>注意其中的 <code>state_checked=“false”或者&quot;true&quot;</code></p>
<p>为什么要用多选 <em>ListView</em> 呢？这个主要是为不定选项而设计的，并且多选 <em>ListView</em> 可以提供一个很好的方法获取所点击的item的id，即：<br>  <code>long selected[]=mlistview.getCheckedItemIds();</code> 还有获取选中的个数的方法: <code>int count=mlistview.getCheckedItemCount();</code> 等等，大家可以自己测试。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ListView</tag>
        <tag>多选 ListView</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 下拉图片变大的 ScrollView</title>
    <url>/2015/08/13/android-scrollview/</url>
    <content><![CDATA[<h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="http://img.godjiyi.cn/csdnblogGIF33.gif" alt></p>
<a id="more"></a>
<h1 id="实现简介"><a href="#实现简介" class="headerlink" title="实现简介"></a>实现简介</h1><h2 id="布局结构"><a href="#布局结构" class="headerlink" title="布局结构"></a>布局结构</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="http://img.godjiyi.cn/csdnblogjiegou.png" alt></p>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p><a href="https://git.oschina.net/jiyiren/PullToZoomScrollView/tree/master/app/src/main/java/app/jiyi/com/pulltozoomscrollview" target="_blank" rel="noopener">gitosc代码结构链接</a></p>
<p>一个主 <em>Activity</em>, 一个 <em>PullToZoomScrollView</em> ( 即自定义的 <em>ScrollView</em> )，还有一个工具类（ 可以忽略 ）</p>
<h3 id="布局结构-1"><a href="#布局结构-1" class="headerlink" title="布局结构"></a>布局结构</h3><p><a href="https://git.oschina.net/jiyiren/PullToZoomScrollView/tree/master/app/src/main/res/layout?dir=1&amp;filepath=app%2Fsrc%2Fmain%2Fres%2Flayout&amp;oid=96e02bbd650bf6e2f0a7b9bfd02c3848f6303180&amp;sha=6cbb8b692e73f28e28cbbb1a6b7542835850f405" target="_blank" rel="noopener">gitosc布局结构链接</a></p>
<ul>
<li><p>主布局：分为两块，一个为 <em>TopBar</em>, 即标题栏（这个不用说了），另外一个是自定义的 <em>ScrollView</em>, 即 <em>PullToZoomScrollView</em>。既然是 <em>ScrollView</em>, 它也是 <em>ViewGroop</em>, 所以它内部也可以包含多个布局。</p>
</li>
<li><p><em>PullToZoomScrollView</em> 布局：也包含两块，一个是上面要下拉可以变大的布局(即含背景图的布局)，一个就是下面的文字显示布局。我这里是分别写两个layout布局，在主布局里include进去的。</p>
</li>
</ul>
<h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><h2 id="主要介绍-PullToZoomScrollView-代码"><a href="#主要介绍-PullToZoomScrollView-代码" class="headerlink" title="主要介绍 PullToZoomScrollView 代码"></a>主要介绍 PullToZoomScrollView 代码</h2><p>代码链接：<a href="https://git.oschina.net/jiyiren/PullToZoomScrollView/blob/master/app/src/main/java/app/jiyi/com/pulltozoomscrollview/PullToZoomScrollView.java?dir=0&amp;filepath=app/src/main/java/app/jiyi/com/pulltozoomscrollview/PullToZoomScrollView.java&amp;oid=47b6121a5fe864ba3d3a5a9fb51f15f601ff9a23&amp;sha=6cbb8b692e73f28e28cbbb1a6b7542835850f405" target="_blank" rel="noopener">gitos代码链接</a></p>
<p>觉得下面代码不好看的，可以点上面的链接去开源中国的 <em>git</em> 里代码展示页面看。代码里注释很详细</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PullToZoomScrollView</span> <span class="keyword">extends</span> <span class="title">ScrollView</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">boolean</span> isonce;<span class="comment">//加载该View的布局时是否是第一次加载，是第一次就让其实现OnMeasure里的代码</span></span><br><span class="line">    <span class="keyword">private</span> LinearLayout mParentView;<span class="comment">//布局的父布局，ScrollView内部只能有一个根ViewGroup，就是此View</span></span><br><span class="line">    <span class="keyword">private</span> ViewGroup mTopView;<span class="comment">//这个是带背景的上半部分的View，下半部分的View用不到的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mScreenHeight;<span class="comment">//整个手机屏幕的高度，这是为了初始化该View时设置mTopView用的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTopViewHeight;<span class="comment">//这个就是mTopView的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCurrentOffset=<span class="number">0</span>;<span class="comment">//当前右侧滚条顶点的偏移量。ScrollView右侧是有滚动条的，当下拉时，</span></span><br><span class="line">    <span class="comment">//滚动条向上滑，当向下滑动时，滚动条向下滑动。</span></span><br><span class="line">    <span class="keyword">private</span> ObjectAnimator oa;<span class="comment">//这个是对象动画，这个在本View里很简单，也很独立，就在这里申明一下，后面有两个方法</span></span><br><span class="line">    <span class="comment">//两个方法是：setT(int t),reset()两个方法用到，其他都和它无关了。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化获取高度值，并记录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attrs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PullToZoomScrollView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        <span class="keyword">this</span>.setOverScrollMode(View.OVER_SCROLL_NEVER);</span><br><span class="line">        WindowManager wm= (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        DisplayMetrics metrics=<span class="keyword">new</span> DisplayMetrics();</span><br><span class="line">        wm.getDefaultDisplay().getMetrics(metrics);</span><br><span class="line">        mScreenHeight=metrics.heightPixels;</span><br><span class="line">        mTopViewHeight=mScreenHeight/<span class="number">2</span>-(<span class="keyword">int</span>) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">90</span>, context.getResources().getDisplayMetrics());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将记录的值设置到控件上，并只让控件设置一次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> widthMeasureSpec</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heightMeasureSpec</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        <span class="keyword">if</span>(!isonce) &#123;</span><br><span class="line">            mParentView = (LinearLayout) <span class="keyword">this</span>.getChildAt(<span class="number">0</span>);</span><br><span class="line">            mTopView = (ViewGroup) mParentView.getChildAt(<span class="number">0</span>);</span><br><span class="line">            mTopView.getLayoutParams().height = mTopViewHeight;</span><br><span class="line">            isonce=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> startY=<span class="number">0</span>;<span class="comment">//向下拉动要放大，手指向下滑时，点击的第一个点的Y坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isBig;<span class="comment">//是否正在向下拉放大上半部分View</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isTouchOne;<span class="comment">//是否是一次连续的MOVE，默认为false,</span></span><br><span class="line">    <span class="comment">//在MoVe时，如果发现滑动标签位移量为0，则获取此时的Y坐标，作为起始坐标，然后置为true,为了在连续的Move中只获取一次起始坐标</span></span><br><span class="line">    <span class="comment">//当Up弹起时，一次触摸移动完成，将isTouchOne置为false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> distance=<span class="number">0</span>;<span class="comment">//向下滑动到释放的高度差</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> action =ev.getAction();</span><br><span class="line">        <span class="keyword">switch</span> (action)&#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">if</span>(mCurrentOffset&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!isTouchOne)&#123;</span><br><span class="line">                        startY=ev.getY();</span><br><span class="line">                        isTouchOne=<span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    distance=ev.getY()-startY;</span><br><span class="line">                    <span class="keyword">if</span>(distance&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        isBig=<span class="keyword">true</span>;</span><br><span class="line">                        setT((<span class="keyword">int</span>)-distance/<span class="number">4</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">if</span>(isBig) &#123;</span><br><span class="line">                    reset();</span><br><span class="line">                    isBig=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                isTouchOne=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象动画要有的设置方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mTopView.getLayoutParams().height = mTopViewHeight-t;</span><br><span class="line">            mTopView.requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主要用于释放手指后的回弹效果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (oa != <span class="keyword">null</span> &amp;&amp; oa.isRunning()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        oa = ObjectAnimator.ofInt(<span class="keyword">this</span>, <span class="string">"t"</span>, (<span class="keyword">int</span>)-distance / <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">        oa.setDuration(<span class="number">150</span>);</span><br><span class="line">        oa.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个是设置向上滑动时，上半部分View滑动速度让其小于下半部分</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldl</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldt</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onScrollChanged</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> oldl, <span class="keyword">int</span> oldt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onScrollChanged(l, t, oldl, oldt);</span><br><span class="line">        mCurrentOffset = t;<span class="comment">//右边滑动标签相对于顶端的偏移量</span></span><br><span class="line">        <span class="comment">//当手势上滑，则右侧滚动条下滑，下滑的高度小于TopView的高度，则让TopView的上滑速度小于DownView的上滑速度</span></span><br><span class="line">        <span class="comment">//DownView的上滑速度是滚动条的速度，也就是滚动的距离是右侧滚动条的距离</span></span><br><span class="line">        <span class="comment">//则TopView的速度要小，只需要将右侧滚动条的偏移量也就是t缩小一定倍数就行了。我这里除以2速度减小1倍</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt;= mTopViewHeight&amp;&amp;t&gt;=<span class="number">0</span>&amp;&amp;!isBig) &#123;</span><br><span class="line">            mTopView.setTranslationY(t / <span class="number">2</span>);<span class="comment">//使得TopView滑动的速度小于滚轮滚动的速度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isBig)&#123;</span><br><span class="line">            scrollTo(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="Demo-下载"><a href="#Demo-下载" class="headerlink" title="Demo 下载"></a>Demo 下载</h1><ul>
<li><a href="http://download.csdn.net/detail/u010344269/8998225" target="_blank" rel="noopener">CSDN下载</a></li>
<li><a href="https://github.com/jiyiren/PullToZoomScrollView" target="_blank" rel="noopener">github下载</a></li>
<li><a href="https://git.oschina.net/jiyiren/PullToZoomScrollView/tree/master" target="_blank" rel="noopener">gitos下载</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>下拉放大</tag>
        <tag>ScrollView</tag>
      </tags>
  </entry>
  <entry>
    <title>单一职责原则，里氏替换原则</title>
    <url>/2016/08/30/designpattern/</url>
    <content><![CDATA[<h2 id="导语："><a href="#导语：" class="headerlink" title="导语："></a>导语：</h2><p>本篇文章是最近看了设计模式方面的知识，记录下自己的阅读内容以及笔记，以备以后翻录！</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>设计模式分为设计与模式两块，通常来说分为 <strong>6 大设计原则和 23 种模式</strong>，但随着后续研究者的发掘与探究，将来也会有一些新的设计模式出现！</li>
<li>在遇到开发难题时，可以借鉴这些设计模式！</li>
<li>在学习这些设计模式时，能结合自己以前做过的项目更好，可以自己一边思考以前自己写的代码不足之处，一边理解这些设计模式的规则要求！</li>
</ul>
<h2 id="一、单一职责原则"><a href="#一、单一职责原则" class="headerlink" title="一、单一职责原则"></a>一、单一职责原则</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>单一职责原则（ <em>Single Responsibility Principle</em> ）：<strong>指有且仅有一个原因引起类的变更</strong>。</p>
<p>理解：尽可能的将对象划分成<strong>单一性的类别</strong>，使类的复杂性降低，实现什么职责都有清晰明确的定义。</p>
<a id="more"></a>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><strong>要求：设计一个用户信息管理的类！</strong></p>
<p>接口 <em>IUserBO</em> ( Business Object 用户信息属性放在一个接口里)</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserBO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUserID</span><span class="params">(String userID)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getUserID</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getUserName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>接口 <em>IUserBL</em> ( Business Logic 用户信息逻辑处理放在一个接口里)</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserBL</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">changePassword</span><span class="params">(String oldPassword)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">deleteUser</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mapUser</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addOrg</span><span class="params">(<span class="keyword">int</span> orgID)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addRole</span><span class="params">(<span class="keyword">int</span> roleID)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>接口 <em>IUserInfo</em> ( 用户信息接口将上面两类接口融合为用户信息接口 )</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserInfo</span> <span class="keyword">extends</span> <span class="title">IUserBL</span>,<span class="title">IUserBO</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>类 <em>UserInfo</em> ( 用户信息管理类，实现上面的接口 )</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">implements</span> <span class="title">IUserInfo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userID;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">changePassword</span><span class="params">(String oldPassword)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"改变密码，"</span>+oldPassword);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"删除密码，"</span>+<span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mapUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"用户map"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addOrg</span><span class="params">(<span class="keyword">int</span> orgID)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"添加机构"</span>+orgID);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addRole</span><span class="params">(<span class="keyword">int</span> roleID)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"添加角色，"</span>+roleID);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserID</span><span class="params">(String userID)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.userID=userID;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getUserID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> userID;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.password = password;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> password;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.userName = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> userName;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在以上实例中，我们定义了三个接口和一个类，接口 <em>IUserInfo</em> 继承了接口 <em>IUserBO</em> 与 <em>IUserBL</em>，这样设计将 <em>IUserInfo</em> 的接口细化了，将属性操作和逻辑操作分开，这也就是印证了单一职责原则，<strong>IUserBO只负责用户属性操作，IUserBL只负责用户信息的逻辑操作</strong>！这样使得整个代码清晰易读！便于扩展！</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在开发过程中设计类或接口时，尽量要将 <strong>这些类和接口的职责唯一、明确</strong>。这样在进行合作开发时，不仅自己能够快速明确自己的目的，其他合作开发的程序员也能够明白你的意思。这样同样也可以降低代码的耦合性，有利于后期代码的维护。</p>
<h2 id="二、里氏替换原则"><a href="#二、里氏替换原则" class="headerlink" title="二、里氏替换原则"></a>二、里氏替换原则</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>里氏替换原则 ( Liskov Substitution Principle, LSP )：<strong>所有引用基类的地方必须能够透明地使用其子类的对象</strong>。</p>
<p>理解：子类继承父类时，<strong>除添加新的方法完成新增功能外，尽量不要重写父类的方法，也尽量不要重载父类的方法</strong>。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>我们想实现两数字的相减的功能，用 A 类来实现，如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(<span class="string">"100-50="</span>+a.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">        System.out.println(<span class="string">"100-80="</span>+a.func1(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span>-<span class="number">50</span>=<span class="number">50</span></span><br><span class="line"><span class="number">100</span>-<span class="number">80</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure></div>
<p>后来，我们需要增加一个新的功能：完成两数相加，然后再与 100 求和，由类 B 来负责。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a,b)+<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        System.out.println(<span class="string">"100-50="</span>+b.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">        System.out.println(<span class="string">"100-80="</span>+b.func1(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">        System.out.println(<span class="string">"100+20+100="</span>+b.func2(<span class="number">100</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span>-<span class="number">50</span>=<span class="number">150</span></span><br><span class="line"><span class="number">100</span>-<span class="number">80</span>=<span class="number">180</span></span><br><span class="line"><span class="number">100</span>+<span class="number">20</span>+<span class="number">100</span>=<span class="number">220</span></span><br></pre></td></tr></table></figure></div>
<p>我们发现原本运行正常的相减功能发生了错误。原因就是 <strong>类 B 在给方法起名时无意中重写了父类的方法</strong>，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。</p>
<p>在本例中，<strong>引用基类 A 完成的功能，换成子类 B 之后，发生了异常</strong>。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</p>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>里氏替换原则通俗的来讲就是：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。它包含以下4层含义：</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
</ul>
<p>看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？后果就是：你写的代码出问题的几率将会大大增加。</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2015/07/23/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></div>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a><br><a id="more"></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Begain</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Hexo 搭建 github 博客</title>
    <url>/2015/07/26/hexogithub/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>本篇将介绍使用 <em>Hexo</em> 框架和 <em>github pages</em> 来搭建简单的博客，主要涉及 <strong>环境搭建、github 空间创建、主题运用(新浪微博秀、多说评论，About 的完成)</strong> 等，其实这也就是个人博客最主要，最核心的组件的。</p>
<h2 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h2><h3 id="1、配置-Hexo-环境（Windows）"><a href="#1、配置-Hexo-环境（Windows）" class="headerlink" title="1、配置 Hexo 环境（Windows）"></a>1、配置 Hexo 环境（Windows）</h3><ul>
<li><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo官方主页</a></li>
<li><a href="https://hexo.io/zh-cn/docs/#安装前提" target="_blank" rel="noopener">Hexo官方环境安装介绍</a></li>
</ul>
<p>其实主要分三步：</p>
<h4 id="git-工具的安装"><a href="#git-工具的安装" class="headerlink" title="git 工具的安装"></a>git 工具的安装</h4><p><a href="http://git-scm.com/" target="_blank" rel="noopener">git官网</a></p>
<p><a href="http://git-scm.com/downloads" target="_blank" rel="noopener">git官网下载</a></p>
<a id="more"></a>
<p><img src="http://img.godjiyi.cn/csdnblog1.png" alt></p>
<p>安装后通常用到的 <strong>git bash</strong>. 你可以同过电脑的开始菜单里找到 <strong>git bash</strong>，或者通过桌面，但通常有一种方便的是在文件夹里右击就会有 git bash 的选项的（ 这个的好处就是自动将工作目录切换到你所在文件夹 ）</p>
<p><img src="http://img.godjiyi.cn/csdnblog2.png" alt></p>
<p><img src="http://img.godjiyi.cn/csdnblog3.png" alt></p>
<p>测试 <code>git</code> 环境成功，打开 git bash 输入 <code>git --version</code>, 出现版本号就行:</p>
<p><img src="http://img.godjiyi.cn/csdnblog4.png" alt></p>
<h4 id="Node-js环境的安装"><a href="#Node-js环境的安装" class="headerlink" title="Node.js环境的安装"></a>Node.js环境的安装</h4><p><a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js官网</a></p>
<p><a href="https://nodejs.org/download/" target="_blank" rel="noopener">Node.js官网下载</a></p>
<p><img src="http://img.godjiyi.cn/csdnblognodejs2.png" alt></p>
<p>根据自己电脑位数选择，下载完后双击安装就行，测试 <em>nodejs</em> 环境成功，还是打开 <strong>git bash</strong>，输入 <code>node -v</code>, 输出版本号就行：</p>
<p><img src="http://img.godjiyi.cn/csdnblognodejs4.png" alt></p>
<p>如果没有出现版本号，请将 <code>nodejs</code> 的安装目录加入电脑环境变量。</p>
<h4 id="Hexo环境的安装"><a href="#Hexo环境的安装" class="headerlink" title="Hexo环境的安装"></a>Hexo环境的安装</h4><p>经过上面的两步，这一步就十分的轻松了，依旧打开 <strong>git bash</strong> 输入安装命令就行，通常下面的这句就行了：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure></div>
<p>但是经过我的测试，不管输入什么安装的命令都是一直等待状态，搜索网上原来是安装源出的问题，我是用下面的这个方法解决的：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry http://registry.cnpmjs.org</span><br><span class="line"><span class="comment"># 输入完后测试命令如下</span></span><br><span class="line">npm info underscore</span><br><span class="line"><span class="comment"># 这句输入后会有字符串输出就行了</span></span><br></pre></td></tr></table></figure></div>
<p>现在再用 <strong>git bash</strong> 用安装命令试试，就可以安装成功了，有时安装第一行出现 <em>fault</em>，没关系的。</p>
<p>测试在 <strong>git bash</strong> 里输入 <code>hexo -v</code>，第一行为版本号就行了，到此Hexo环境配置完成。</p>
<p><img src="http://img.godjiyi.cn/csdnbloghexo1.png" alt></p>
<h3 id="2、在-github-上创建自己唯一的项目空间"><a href="#2、在-github-上创建自己唯一的项目空间" class="headerlink" title="2、在 github 上创建自己唯一的项目空间"></a>2、在 github 上创建自己唯一的项目空间</h3><p>这一步骤不多说，只介绍注意点：</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>注册时的账号邮箱尽量是微软，谷歌等国外大公司邮箱，国内的邮箱通常收不到消息。</p>
<h4 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h4><p>创建项目是的项目名称必须是 <code>UserName.github.io</code> 前面的 <code>UserName</code> 是你 <em>github</em> 的用户名，后面的 .<code>github.io</code> 是一定的，不变的，也就是每个用户只能建立一个这样的仓库的。</p>
<p><img src="http://img.godjiyi.cn/csdnbloggithub2.png" alt></p>
<h3 id="3、本地测试部署"><a href="#3、本地测试部署" class="headerlink" title="3、本地测试部署"></a>3、本地测试部署</h3><p>目的：把本地当服务器运行项目</p>
<h4 id="初始化Hexo项目"><a href="#初始化Hexo项目" class="headerlink" title="初始化Hexo项目"></a>初始化Hexo项目</h4><p>首先创建一个文件夹，然后在这个文件夹里右击 – 选择 <strong>git bash</strong>，然后执行如下命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">hexo init		<span class="comment"># 自动创建所需文件</span></span><br><span class="line">npm install hexo-server --save	<span class="comment"># 安装 server 命令工具</span></span><br><span class="line">npm install	<span class="comment"># 这句很重要，安装其他辅助工具</span></span><br></pre></td></tr></table></figure></div>
<h4 id="运行本地测试"><a href="#运行本地测试" class="headerlink" title="运行本地测试"></a>运行本地测试</h4><p>在新建的文件夹内，右击<strong> git bash</strong>，输入如下命令，访问 <code>localhost:4000</code>，效果如图。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></div>
<p><img src="http://img.godjiyi.cn/csdnbloghexo2.png" alt></p>
<h3 id="4、首次远程测试部署"><a href="#4、首次远程测试部署" class="headerlink" title="4、首次远程测试部署"></a>4、首次远程测试部署</h3><p>目的：把项目部署到 <em>github</em> 的项目里</p>
<h4 id="网站配置文件配置"><a href="#网站配置文件配置" class="headerlink" title="网站配置文件配置"></a>网站配置文件配置</h4><p>文件夹里有 <code>_config.yml</code> 文件，这个是配置整个网站的配置文件，下面会有主题中的<code>_config.yml</code>, 那个只是配置具体文章和显示的配置文件，不要搞混了。用编辑器打开，找到最后，该为如下样式 ( 请把两个 <em>jiyiren</em> 换为你的 github 名称就行了 )：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YML"><figure class="iseeu highlight /yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="attr">https://github.com/jiyiren/jiyiren.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></div>
<h3 id="生成部署"><a href="#生成部署" class="headerlink" title="生成部署"></a>生成部署</h3><p>输入下面两个命令即可，它会自动部署到 <em>github</em> 上，成功后就可以访问 <code>UserName.github.io</code> 看到效果了。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">hexo g		<span class="comment"># 生成静态页面</span></span><br><span class="line">hexo d		<span class="comment"># 部署静态页面到 github 项目</span></span><br></pre></td></tr></table></figure></div>
<h3 id="5、创建第一个测试博客并部署运行"><a href="#5、创建第一个测试博客并部署运行" class="headerlink" title="5、创建第一个测试博客并部署运行"></a>5、创建第一个测试博客并部署运行</h3><h4 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h4><p>创建博客通常在 <code>sources</code> 目录下的 <code>_posts</code> 目录下，新建 <code>.md</code> 的后缀名就可以直接写了。</p>
<p><img src="http://img.godjiyi.cn/csdnbloghexo4.png" alt></p>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>假如新建名为 <code>helloeveryone.md</code> 文件，文件内容如下，然后保存，回到主目录，<em>git bash</em>，然后 <code>hexo server</code>，浏览器输入 <code>localhost:4000</code>，看看有哪些变化吧。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YML"><figure class="iseeu highlight /yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">HelloEveryone</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2015</span><span class="bullet">-07</span><span class="bullet">-23</span> <span class="number">21</span><span class="string">:45:40</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Begin</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Hexo</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">这是主体部分</span></span><br></pre></td></tr></table></figure></div>
<h3 id="6、整体博客配置介绍"><a href="#6、整体博客配置介绍" class="headerlink" title="6、整体博客配置介绍"></a>6、整体博客配置介绍</h3><p>博客主 <code>_config.yml</code> 配置：我是初学者，可能写的不好，所以就大家推荐看 <a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">官网config说明</a> 我就是照着这个学会一点点的。</p>
<h3 id="7、运用-Jacman-主题"><a href="#7、运用-Jacman-主题" class="headerlink" title="7、运用 Jacman 主题"></a>7、运用 Jacman 主题</h3><p>该主题由我介绍肯定没有该主题制作者讲的明白了，请看作者博客介绍吧：<a href="http://wuchong.me/blog/2014/11/20/how-to-use-jacman/" target="_blank" rel="noopener">Jacman主题详细介绍</a></p>
<p>里面包括了新浪微博秀，添加多说评论，添加 <em>About</em> 等配置，我认为这个是一个博客的所有基本功能了，能满足大部分人建立博客的需求。</p>
<p><a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">更多主题</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-07-28 日志</title>
    <url>/2019/07/28/life_work/</url>
    <content><![CDATA[<p>最近，我也毕业入职了，用了一个月时间熟悉了身边新环境，虽说还可以，但仍旧心有不安。</p>
<p>今年都说工作形式不好，多家互联网企业被爆裁员。互联网，曾今是多么充满活力的名词，基本上是”万众创业”的根本，而现在给人的则是”赢者通吃”的感觉，再无敢与巨头相争，百花齐放的景象了。</p>
<p>虽说现在巨头当道，创业热情没有以前的高，但互联网仍然是最大的创业领域。目前，移动互联的创业确实少了，但是 5G、IoT、人工智能的创业项目却有很多。</p>
<p>很多时候我们都在以我们自己能看到的信息进行评判和决策的，由于我们都处于历史长河中的一部分，在那一部分中我们的绝大部分技能、信息都聚焦于某一种东西上，如果时代改变了这种东西的价值，那我们自身的价值也会相应变化，最坏的情况就是贬值，而这正是互联网的特性。</p>
<p>心有不安，不安在时代正在极速地改变着最吃香的技能，而自己的技能却在逐步被淘汰！很多人怕的不是被裁，而是怕自己已经适应不了社会的需求了！</p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Life</tag>
        <tag>日志</tag>
        <tag>Work</tag>
      </tags>
  </entry>
  <entry>
    <title>Mjoke App 全部开发过程</title>
    <url>/2015/09/18/mjokeapp/</url>
    <content><![CDATA[<h2 id="MJoke-APP上架"><a href="#MJoke-APP上架" class="headerlink" title="MJoke APP上架"></a>MJoke APP上架</h2><ol>
<li>小米商店：搜索 <strong>mjoke</strong> 即可下载。或者<a href="http://app.mi.com/detail/113066" target="_blank" rel="noopener">点我下载</a></li>
<li>360手机应用中心：搜索 <strong>mjoke</strong> 即可下载。或者<a href="http://shouji.360tpcdn.com/150917/806c975d3c51250c605ac6970cff9da9/app.jiyi.com.mjoke_2.apk" target="_blank" rel="noopener">点我下载</a></li>
<li>豌豆荚手机应用中心：搜索 <strong>mjoke</strong> 即可下载。或者<a href="http://www.wandoujia.com/apps/app.jiyi.com.mjoke" target="_blank" rel="noopener">点我下载</a></li>
</ol>
<h2 id="Mjoke界面展示"><a href="#Mjoke界面展示" class="headerlink" title="Mjoke界面展示"></a>Mjoke界面展示</h2><p><img src="http://img.godjiyi.cn/123.jpg" alt="1"></p>
<a id="more"></a>
<p><img src="http://img.godjiyi.cn/456.jpg" alt="4"></p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ul>
<li>JavaSDK: <em>JDK:1.7</em>；</li>
<li>服务器端：<em>Myeclipse + Tomcat7.0</em>；</li>
<li>数据库：<em>Mysql5.6 + MysqlWorkBench</em>;</li>
<li>客户端：<em>AndroidStudio + SDK19</em></li>
<li>部署服务器：阿里云 <em>ACE</em> ( 云引擎 ) + 云数据库 <em>RDS</em> ( Mysql ) + 对象存储 ( <em>oss</em> )</li>
</ul>
<h3 id="服务器端开发"><a href="#服务器端开发" class="headerlink" title="服务器端开发"></a>服务器端开发</h3><h4 id="项目结构如下："><a href="#项目结构如下：" class="headerlink" title="项目结构如下："></a>项目结构如下：</h4><p><img src="http://img.godjiyi.cn/csdnblogserver1.png" alt> </p>
<ul>
<li>bean 包为数据库里各个表对象</li>
<li>config包为配置包</li>
<li>dao为与数据库直接操作的包</li>
<li>outjson是每个servlet的对应输出json包</li>
<li>servlet是客户端直接请求的地址</li>
<li>util则是工具包，可以包含MD5，Base64或者mysql的工厂类等</li>
<li>dbconfig.properties则是数据库工厂模式配置文件</li>
</ul>
<h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><p>在本项目里我没有用框架，纯手动自己分类。也有了自己的开发想法 ( 可能别人早就想到了 )，我是在 <em>servelet</em> 里调用 <em>dao</em> 方法处理数据库，输出则调用 <em>outjson</em> 类里的一个方法。所有一个工作流程就是</p>
<ol>
<li>新建 <em>servlet</em> 如: <strong>LoginServlet</strong> ；</li>
<li>在 <em>dao</em> 包里只建立唯一一个类叫 <em>DbDao</em>, 在里面添加一个方法比如 <strong>isLoginSuc(User u)</strong> 返回为 <code>boolean</code></li>
<li>在 <em>OutJson</em> 里建立唯一一个类比如就叫 <em>OutJson</em>，里面添加一个方法比如<strong>outLoginResult(boolean islogins)</strong> 返回 <code>String</code></li>
<li>在 <em>Servlet</em> 里接受参数，传参数给 <strong>isLoginSuc()</strong>, 得到结果，根据返回结果再传参数给 <strong>outLoginResult()</strong>,得到 <code>json</code> 字符串直接 <strong>out.write(str)</strong>;就行。</li>
<li>在 <em>jsp</em> 页面写 <em>form</em> 表单，如果请求类型为 <em>post</em> 方法就 <code>method=&quot;post&quot;</code>，可以用 jsp 测试看看返回结果对不对，是不是 json 类型等，成功后再在 <em>android</em> 里调用，并且尽量在获得结果后Log出来看看结果。</li>
</ol>
<h4 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h4><ul>
<li><p>数据库的工厂模式网上很多，其实用到的技术就是 jdbc，搜索搜 jdbc 出现的教程应该很多，不想看文字教程的可以看看视频的去 <a href="http://www.jikexueyuan.com/" target="_blank" rel="noopener">极客学院</a>搜索 jdbc 就有很多，我当时就在里面学习的。当然极客学院有的需要付费的，土豪可以看看，质量确实不错。穷屌丝可以看看 <a href="http://www.imooc.com/course/list?c=mysql" target="_blank" rel="noopener">慕课网</a>，里面是完全免费的。</p>
</li>
<li><p>上面讲的是 java 操作数据库，但是不管怎样还得涉及到 mysql 的增删查改，我本地的mysql 是 rar 包安装的，进入查看内容都是同过命令，这个不仅效率不高而且容易出错，所以我用了官方推荐的图形化工具 <em>mysqlworkbench</em>，<em>个人推荐：</em> <strong>先在mysqlworkbench里用sql语句操作一遍，成功后再将语句复制到jdbc操作里面，我建议jdbc里用PreparedStatement的.setString(int,str)代替，就是在查询语句里的变量用？代替，然后用setString方法替换</strong></p>
</li>
</ul>
<h3 id="Android客户端开发"><a href="#Android客户端开发" class="headerlink" title="Android客户端开发"></a>Android客户端开发</h3><p><strong>项目结构</strong>：</p>
<p><img src="http://img.godjiyi.cn/csdnblogclient.png" alt></p>
<ul>
<li>最主要的是 <em>net</em> 包–网络操作；<em>utiltool</em> 包–工具类；<em>utilview</em> – 自定义view;最后那个是微信分享的。</li>
<li>图片加载显示的我用了Volley框架，这个是google官方给的网络操作框架。视频学习<a href="http://www.imooc.com/learn/468" target="_blank" rel="noopener">慕课网volley</a>;大神博客<a href="http://blog.csdn.net/guolin_blog/article/details/17482095" target="_blank" rel="noopener">AndroidVolley完全解析</a></li>
<li>Net操作封装，我是看了一个完整app开发教程，然后里面有net的封装。360云盘地址<a href="http://yunpan.cn/cHfyWp75eJ97K" target="_blank" rel="noopener">http://yunpan.cn/cHfyWp75eJ97K</a> （提取码：3ba2）</li>
<li>sqlite操作，建议写两个类，一个DBHelper，一个DBManager。DBHelper创建和更新数据库，继承SQLiteOpenHelper；DBManager调用DBHelper，并且所有的操作都写成一个方法放在DBManager，供外部的Activity调用。参考链接<a href="http://www.cnblogs.com/Excellent/archive/2011/11/19/2254888.html" target="_blank" rel="noopener">Android Sqlite讲解</a></li>
<li>开源控件合集：<a href="https://github.com/jiyiren/MaterialDesignLibrary" target="_blank" rel="noopener">github</a>,<a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=207708744&amp;idx=1&amp;sn=76f3ed599d4c9da415cf4d8e4fc1aebe&amp;scene=23&amp;srcid=0918wGIKNZgd2Fd6enY3Cnym#rd" target="_blank" rel="noopener">大神分享的控件</a></li>
<li>微信分享：<a href="http://www.imooc.com/learn/455" target="_blank" rel="noopener">慕课网微信分享视频教程</a></li>
</ul>
<h3 id="服务器选择"><a href="#服务器选择" class="headerlink" title="服务器选择"></a>服务器选择</h3><ul>
<li><a href="http://bce.baidu.com/index.html" target="_blank" rel="noopener">百度开放云</a></li>
<li><a href="http://www.aliyun.com/" target="_blank" rel="noopener">阿里云</a></li>
</ul>
<p><strong>以下主要介绍这两家的云服务。</strong></p>
<ol>
<li>通常所说的服务器就是一个 主机 + 外网ip，也就是一台云主机，相当于一台电脑。百度里叫做 <strong>云服务器BCC</strong>，阿里里叫做 <strong>云服务器ECC</strong>。如果对于一要靠 app 发展的一个企业来说，这个是最好的选择，因为所有的控制权都在自己的手里，价格对于企业来说应该还是厚道。</li>
<li>但是如果对于一个开发员，只想做一个上线后用户不太大，存储不是很大量的人来说，这种服务器就太贵了，一个月最基本的类型需要 80-100元/月 左右吧，百度阿里其实早就考虑到这个问题了，所以推出了应用服务引擎：百度叫做 <strong>应用引擎BAE</strong>，阿里叫做 <strong>云引擎ACE</strong>，这个通常作为无存储的 web 引擎，如微信后台这样就是部署在这里面，因为只是提供用户反馈，不需要存储东西的简单引擎。这个价格很便宜百度云 0.4元/天，阿里的可能贵几毛。这个一个月才 12元 很好。</li>
<li>但是我们的 app 不可不存东西的啊，是吧，比如我这个要存图片，我们是不能再ACE或者BAE 里直接 new File 存图片的，因为首先它的空间很小，每个项目就给你2G，然后它是不可以调出来的，也就是说用户存的图片进去，你不能备份到其他地方了。所以必须有个存储的地方，并且有 api 给我们调用</li>
<li>百度和阿里也考虑到了，百度提供 <strong>对象存储BOS</strong> 服务，阿里提供 <strong>对象存储OSS</strong>服务，这个也挺便宜，但是上传文件需要调用他们提供的api,官方都有的。</li>
<li>另外数据库我们也是需要的，百度提供 <strong>关系型数据库RDS</strong>，阿里提供 <strong>云数据库RDS</strong>，我们可以新建mysql数据库，上传我们的数据库表，把我们的数据库连接设置成他们的就行了</li>
<li>总结：<strong>BCC 或者 ECC</strong> 是一台电脑，所有的代码，存储，和数据库都放在那台电脑里，而 <strong>应用引擎</strong> 则是分布式的，将代码，存储和数据库分开存放，这样使得部署很灵活，易于备份。</li>
<li>附加：腾讯和新浪其实也有云服务，大家可以看看。云存储的话 <a href="http://www.qiniu.com/" target="_blank" rel="noopener">七牛云存储</a>也可以的，主要它免费的多，普通用户有一定的免费份额的。另外百度上传时我用git一直上传不上去，用svn就可以，大家注意一下。</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>MJoke</tag>
      </tags>
  </entry>
  <entry>
    <title>同个电脑多个 SSH Key 的配置使用</title>
    <url>/2015/07/26/multiple-ssh-key/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">多平台代码仓库，多账号免密登录</p>

<p>很多时候我们用的代码管理平台有很多，通常我们都会使用不止一个平台账号的。比如我比较喜欢 <a href="https://github.com/" target="_blank" rel="noopener">Github</a> 的开源功能，但是它的私有项目是收费的，所以我也用开源中国的 <a href="https://gitee.com/" target="_blank" rel="noopener">Git Oschina</a> 的平台 ( 因为它的 <em>private</em> 项目是免费的！)。但是，由于我们生成的公钥和私钥只有一份，也就是当前用户目录的 <em>.ssh</em> 文件夹下，如果多平台多账号，生成的时候就会覆盖掉了，那该如何设置多平台账号的公钥和私钥不会相互覆盖同时还能够自动解析免密访问？</p>
<p>本文就介绍用两个不同平台的 <em>Git</em> 账号来实现，同时免密登录。两个平台分别为 <a href="https://github.com/" target="_blank" rel="noopener">Github</a> 和开源中国的 <a href="https://gitee.com/" target="_blank" rel="noopener">GitSschina</a> 的。详细步骤如下。</p>
<h2 id="生成-SSH-Key"><a href="#生成-SSH-Key" class="headerlink" title="生成 SSH Key"></a>生成 SSH Key</h2><p>生成 <em>ssh key</em> 的命令我想大家都应该懂：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"youremail@email.com"</span></span><br></pre></td></tr></table></figure></div>
<p>当我们回车时，我想有的人是直接三个回车的吧，当然三个回车是没有问题的，但是我们要了解这三个回车是什么意思。</p>
<p><strong>第一个回车</strong>：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key &lt;/c/Users/JIYI/.ssh/id_rsa&gt;</span><br></pre></td></tr></table></figure></div>
<a id="more"></a>
<p>此处的回车代表将密钥默认存储在 <strong><em>C盘/Users/用户名/.ssh</em></strong> 的文件夹下</p>
<p><strong>第二个回车</strong>与<strong>第三个回车</strong>：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">Enter passphrase&lt;empty <span class="keyword">for</span> no passphrase&gt;:</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure></div>
<p>这个是为了设置提交项目的密码，为了避免其他人用你的电脑修改你的项目时提交的，通常直接回车，就代表不需要密码，我也建议这样做，可以避免多次输入密码，省时省力。</p>
<h2 id="多账号密钥生成"><a href="#多账号密钥生成" class="headerlink" title="多账号密钥生成"></a>多账号密钥生成</h2><p>因为有两个账号，如果生成密钥时都是三个回车则后执行的会替换先执行的。既然第一个回车的意思是保存地址，那我们就不能直接回车了，而是输入保存地址就可以了。</p>
<p>步骤如下：</p>
<p><strong>1. 正常生成第一个密钥</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;mygitoschina@qq.com&quot;</span><br></pre></td></tr></table></figure></div>
<p>连续三个回车，将 <strong>Oschina</strong> 的密钥默认保存</p>
<p><strong>2. 生成第二个密钥</strong></p>
<p>先打开 <em>C盘/Users/用户名/.ssh</em> 目录，在里面新建 <em>github</em> 文件夹</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;mygithub@gmail.com&quot;</span><br></pre></td></tr></table></figure></div>
<p>出现 <code>Enter file in which to save the key</code> 时输入</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">/c/Users/用户名/.ssh/github/id_rsa</span><br></pre></td></tr></table></figure></div>
<p>也就是将密钥保存在 <em>github</em> 文件夹下</p>
<p><img src="http://img.godjiyi.cn/csdnblogresultssk.jpg" alt></p>
<p>这样生成密钥完成</p>
<h2 id="创建-config-文件"><a href="#创建-config-文件" class="headerlink" title="创建 config 文件"></a>创建 config 文件</h2><p>在 <strong>C盘/Users/用户名/.ssh</strong> 目录下新建 <em>config</em> 文件，该文件没有后缀名的，这是为了配置映射功能的，在里面填入下面代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">#github的配置</span><br><span class="line">Host github.com</span><br><span class="line">	HostName github.com</span><br><span class="line">	IdentityFile ~/.ssh/github/id_rsa</span><br><span class="line">	User git</span><br></pre></td></tr></table></figure></div>
<p>主要是 <em>HostName</em> 和 <em>IdentityFile</em> 要改，<em>HostName</em> 是服务器域名，<em>IdentityFile</em> 就是密钥的地址了。上面设置，就是刚刚我们新建 <em>github</em> 下的生成密钥，那个 <strong>~</strong> 符号代表当前目录，<em>windows</em> 下默认就是 <strong>C盘/Users/用户名</strong>，所以再加上后面的地址就是我们上面所写的 <strong>C盘/Users/用户名/.ssh/github/id_rsa</strong>.</p>
<p>当然这里面也可以写多个配置的</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">#github配置</span><br><span class="line">Host github.com</span><br><span class="line">	HostName github.com</span><br><span class="line">	IdentityFile ~/.ssh/github/id_rsa</span><br><span class="line">	User git</span><br><span class="line">#gitoschina的配置</span><br><span class="line">Host git.oschina.net</span><br><span class="line">	HostName git.oschina.net</span><br><span class="line">	IdentityFile ~/.ssh/id_rsa</span><br><span class="line">	User git</span><br></pre></td></tr></table></figure></div>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试 <em>Github</em> 的</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">ssh -t git@github.com</span><br></pre></td></tr></table></figure></div>
<p>返回成功信息：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">Hi youname! You<span class="string">'ve successfully authenticated, but Github does not provide shell access.</span></span><br></pre></td></tr></table></figure></div>
<p><img src="http://img.godjiyi.cn/csdnblogsskgithub.jpg" alt></p>
<p>当然有的时候会问你是否授权连接，选 <em>y</em> 即可。</p>
<p>测试开源中国的 <em>GitOschina</em>:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@git.oschina.net</span><br></pre></td></tr></table></figure></div>
<p>返回成功信息为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">Welcome to Git@OSC, yourname!</span><br></pre></td></tr></table></figure></div>
<p><img src="http://img.godjiyi.cn/csdnblogsskgitosc.jpg" alt></p>
<p>这样在项目中就可以用多个 <strong>Git</strong> 平台的 <em>ssh</em> 了。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>SSH Key</tag>
      </tags>
  </entry>
  <entry>
    <title>Nexus 7 刷谷歌官方系统教程</title>
    <url>/2015/11/15/nexus_official/</url>
    <content><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><ul>
<li><em>Ubuntu 14.04</em> 环境；</li>
<li>官方 <em>Android SDK</em>；</li>
<li>Google 官方 <strong>5.0</strong> 镜像；</li>
</ul>
<h2 id="一、官方镜像"><a href="#一、官方镜像" class="headerlink" title="一、官方镜像"></a>一、官方镜像</h2><h3 id="1、官方镜像地址"><a href="#1、官方镜像地址" class="headerlink" title="1、官方镜像地址"></a>1、官方镜像地址</h3><p>下载地址：<a href="https://developers.google.com/android/nexus/images" target="_blank" rel="noopener">https://developers.google.com/android/nexus/images</a> ( 代理访问，下载时可以将链接复制到百度云离线下载，就不需要代理了 )</p>
<p>里面列出了谷歌旗下的所有设备的镜像下载链接。</p>
<p>我的设备是 <strong>Nexus 7 2012 年 wifi 版本</strong> 的。所以选择 <strong>“nakasi” for Nexus 7 (Wi-Fi)</strong> 栏目里的任意一个 Android 版本下载。</p>
<p><img src="http://img.godjiyi.cn/nexus7nexus7_down.png" alt></p>
<blockquote>
<p><strong>注：</strong> Nexus 7 分为两代，一代为 2012 年出的，一代为 2013 年出的；每一代都有两个版本，一个是 wifi 版本，一个是 mobile 版本。大家注意选择。</p>
</blockquote>
<a id="more"></a>
<h3 id="2、下载后的文件"><a href="#2、下载后的文件" class="headerlink" title="2、下载后的文件"></a>2、下载后的文件</h3><p>我下载 Android 5.0 的版本后的文件为：</p>
<p><img src="http://img.godjiyi.cn/nexus7nexus7_50.png" alt></p>
<blockquote>
<p>注：名称是有规律的，<strong>nakasi</strong> 为你设备的谷歌代号名, <strong>lrx21p</strong> 为版本名]</p>
</blockquote>
<p>解压该文件后内容为</p>
<p><img src="http://img.godjiyi.cn/nexus7nexus_jieyahou.png" alt></p>
<h3 id="3、环境设置"><a href="#3、环境设置" class="headerlink" title="3、环境设置"></a>3、环境设置</h3><p>下载 <em>Android SDK</em> 并加入环境变量。</p>
<p>地址：<a href="http://tools.android-studio.org/index.php/sdk" target="_blank" rel="noopener">http://tools.android-studio.org/index.php/sdk</a> ( 国内可访问，用百度云下载 )</p>
<p><img src="http://img.godjiyi.cn/nexus7nexus_sdk.png" alt></p>
<p>我是 <em>Linux</em> 所以下载 <em>Linux</em> 的。下载后解压到 <strong>home/Android/sdk</strong> 目录下，如图：</p>
<p><img src="http://img.godjiyi.cn/nexus7nexus_sdk_jieya.png" alt></p>
<p>我们要加入环境变量的是 <em>platform-tools</em> 目录。</p>
<p>打开终端输入：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo gedit ~/.bashrc</span><br></pre></td></tr></table></figure></div>
<p>加入：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ANDROID_SDK_TOOL=~/Android/sdk</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;ANDROID_SDK_TOOL&#125;</span>/platform-tools:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></div>
<p>然后重新打开终端</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">adb version</span><br></pre></td></tr></table></figure></div>
<p>出现版本号就说明环境搭建成功了。</p>
<h3 id="4、刷机"><a href="#4、刷机" class="headerlink" title="4、刷机"></a>4、刷机</h3><p>将设备用 <em>usb</em> 连接到电脑，然后在终端输入以下命令让设备进入 <strong>bootloader</strong> 模式</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>(或者按住按住设备的电源键和音量减键，两个要一起按住不放，知道重启到 <strong>bootloader</strong> 界面)</p>
</blockquote>
<p><img src="http://img.godjiyi.cn/nexus7nexus7_bootloader.png" alt></p>
<p>最下面的红字为 <strong>LOCK STATE - UNLOCKED</strong>, 就说明 <em>bootloader</em> 解锁了，但是通常的设备在出厂之前都是未解锁；但是不管解锁没解锁都可以用下面的命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">fastboot oem unlock</span><br></pre></td></tr></table></figure></div>
<p>我建议大家都应该输入该命令。</p>
<p>然后切换到之前下载镜像解压后的目录：</p>
<p><img src="http://img.godjiyi.cn/nexus7nexus7_jieyajingxiang.png" alt></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Downloads/nexus7/google/nakasi-5.0/nakasi-lrx21p</span><br></pre></td></tr></table></figure></div>
<p>执行刷机命令 ( 执行的是 <em>flash-all.sh</em> 后缀是 <strong>.sh</strong> 不要执行成 bat 了 )</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">./flash-all.sh</span><br></pre></td></tr></table></figure></div>
<p>然后就是静静的等待了。</p>
<h3 id="5、进入系统前验证"><a href="#5、进入系统前验证" class="headerlink" title="5、进入系统前验证"></a>5、进入系统前验证</h3><p>这个是刷谷歌官方镜像的最大缺点，因为谷歌在国内被墙了，所以通常的 <em>wifi</em> 都不能连接谷歌的。但是 <em>Cyanogenmod</em> 系统就不强制连接 <em>wifi</em> 的，所以如果有同学在这里实在是找不到代理连接到谷歌的就刷 <strong>Cyanogenmod</strong> 的镜像吧。但是还是要讲下怎么连接吧：</p>
<p><strong>连接无线网</strong></p>
<p>这里的连接无线网络的时候是个大问题，很多人在这里都无法连上网络，这是因为我们的网络都不能访问谷歌的，但是谷歌又强制连接，所以显示一直连接中。</p>
<p><strong>解决方法</strong></p>
<p>要有一个可以联网的无线网 ( 这个网络无须翻墙，如果可以翻墙则可以跳过以下了，不可以则继续看 )，然后点击无线网信号，输入密码，勾选 <strong>高级选项</strong>, 在高级选项的代理 <strong>ip</strong> 和代理端口号里输入可以连接谷歌的代理 <strong>ip</strong> 和端口。</p>
<p>我当时的代理ip: <strong>183.111.169.204</strong>, 代理端口：<strong>3128</strong></p>
<p>可能之后就不能用了，我给大家一个网址这个上面提供最新的国外代理 <a href="http://www.xicidaili.com/wn/" target="_blank" rel="noopener">http://www.xicidaili.com/wn/</a><br> 另外如果这个网址也不提供了，我建议大家用谷歌搜索“国外代理”，应该会有一些网站提供的。</p>
<blockquote>
<p><em>你如果用百度搜，前面10左右都是广告,😶</em></p>
</blockquote>
<h3 id="6、进入系统"><a href="#6、进入系统" class="headerlink" title="6、进入系统"></a>6、进入系统</h3><p>下拉菜单</p>
<p><img src="http://img.godjiyi.cn/nexus7nexus7_5.0finish.png" alt></p>
<p>任务管理器</p>
<p><img src="http://img.godjiyi.cn/nexus733333.png" alt></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title>无版权图库资源收集</title>
    <url>/2019/09/15/openimage/</url>
    <content><![CDATA[<p>我平常自己在写文档时，常常会搭配一些图片来展示。一般我都会去 <strong>无版权图片库</strong> 找一张搭配，毕竟程序员老是敲代码和文字打交道，已经苦不堪言了，来一点 <em>色彩图像</em> 刺激真的会让人耳目一新。很多时候程序员不仅仅应该是实现功能方，我们也应该要把自己当做甲方或者用户，去体验什么样的设计才能让自己感觉舒适。<strong>我喜欢有自己的个性，有自己的配色配图</strong>。</p>
<h1 id="pixabay"><a href="#pixabay" class="headerlink" title="pixabay"></a>pixabay</h1><ul>
<li><strong>推荐</strong>：★★★★★</li>
<li>地址：<a href="https://pixabay.com/" target="_blank" rel="noopener">https://pixabay.com/</a></li>
<li>主页：<img src="http://img.godjiyi.cn/jy_open-pixabay.jpg" alt></li>
</ul>
<h1 id="pexels"><a href="#pexels" class="headerlink" title="pexels"></a>pexels</h1><ul>
<li><strong>推荐</strong>：★★★★★</li>
<li>地址：<a href="https://www.pexels.com" target="_blank" rel="noopener">https://www.pexels.com/</a></li>
<li>主页：<img src="http://img.godjiyi.cn/jy_open-pexels.jpg" alt></li>
</ul>
<a id="more"></a>
<h1 id="isorepublic"><a href="#isorepublic" class="headerlink" title="isorepublic"></a>isorepublic</h1><ul>
<li><strong>推荐</strong>：★★★★★</li>
<li>地址：<a href="https://isorepublic.com/" target="_blank" rel="noopener">https://isorepublic.com/</a></li>
<li>主页：<img src="http://img.godjiyi.cn/jy_open-isorepublic.jpg" alt></li>
</ul>
<h1 id="gratisography"><a href="#gratisography" class="headerlink" title="gratisography"></a>gratisography</h1><ul>
<li><strong>推荐</strong>：★★★★</li>
<li>地址：<a href="https://gratisography.com/" target="_blank" rel="noopener">https://gratisography.com/</a></li>
<li>主页：<img src="http://img.godjiyi.cn/jy_open-gratisography.jpg" alt></li>
</ul>
<h1 id="rawpixel"><a href="#rawpixel" class="headerlink" title="rawpixel"></a>rawpixel</h1><ul>
<li><strong>推荐</strong>：★★★★</li>
<li>地址：<a href="https://www.rawpixel.com/" target="_blank" rel="noopener">https://www.rawpixel.com/</a></li>
<li>主页：<img src="http://img.godjiyi.cn/jy_open-rawpixel.jpg" alt></li>
</ul>
<h1 id="polayoutu"><a href="#polayoutu" class="headerlink" title="polayoutu"></a>polayoutu</h1><ul>
<li><strong>推荐</strong>：★★★★</li>
<li>地址：<a href="http://www.polayoutu.com/collections" target="_blank" rel="noopener">http://www.polayoutu.com/collections</a></li>
<li>主页：<img src="http://img.godjiyi.cn/jy_open-polayoutu.jpg" alt></li>
</ul>
<h1 id="pxhere"><a href="#pxhere" class="headerlink" title="pxhere"></a>pxhere</h1><ul>
<li><strong>推荐</strong>：★★★★</li>
<li>地址：<a href="https://pxhere.com/" target="_blank" rel="noopener">https://pxhere.com/</a></li>
<li>主页：<img src="http://img.godjiyi.cn/jy_open-pxhere.jpg" alt></li>
</ul>
<h1 id="picjumbo"><a href="#picjumbo" class="headerlink" title="picjumbo"></a>picjumbo</h1><ul>
<li><strong>推荐</strong>：★★★</li>
<li>地址：<a href="https://picjumbo.com/" target="_blank" rel="noopener">https://picjumbo.com/</a></li>
<li>主页：<img src="http://img.godjiyi.cn/jy_open-picjumbo.jpg" alt></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://pixabay.com/" target="_blank" rel="noopener">https://pixabay.com/</a></li>
<li><a href="https://www.pexels.com" target="_blank" rel="noopener">https://www.pexels.com/</a></li>
<li><a href="https://isorepublic.com/" target="_blank" rel="noopener">https://isorepublic.com/</a></li>
<li><a href="https://gratisography.com/" target="_blank" rel="noopener">https://gratisography.com/</a></li>
<li><a href="https://www.rawpixel.com/" target="_blank" rel="noopener">https://www.rawpixel.com/</a></li>
<li><a href="http://www.polayoutu.com/collections" target="_blank" rel="noopener">http://www.polayoutu.com/collections</a></li>
<li><a href="https://pxhere.com/" target="_blank" rel="noopener">https://pxhere.com/</a></li>
<li><a href="https://picjumbo.com/" target="_blank" rel="noopener">https://picjumbo.com/</a></li>
<li><a href="https://www.yuque.com/ruanyf/weekly/free-photos" target="_blank" rel="noopener">https://www.yuque.com/ruanyf/weekly/free-photos</a></li>
</ol>
]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>无版权</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title>博客界面更新</title>
    <url>/2017/10/06/picture-group/</url>
    <content><![CDATA[<p><strong>博客界面更新，应用个性化 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next</a> 主题</strong></p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="http://img.godjiyi.cn/nextpicdd.jpg" alt></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://img.godjiyi.cn/nextpicee.jpg" alt></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://img.godjiyi.cn/nextpica.jpg" alt></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="http://img.godjiyi.cn/nextpicf.jpg" alt></div></div></div></div>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 gitbook 的项目文档设计</title>
    <url>/2019/09/15/project-doc/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">基于 Gitbook 的开源生态，更具美观的项目文档设计</p>

<p><img src="http://img.godjiyi.cn/jy_blog-project-doc.jpg" alt></p>
<p><strong>项目源码地址</strong>：<a href="https://github.com/jiyiren/ProjectDoc" target="_blank" rel="noopener">https://github.com/jiyiren/ProjectDoc</a></p>
<p><strong>有色Demo预览地址</strong>：<a href="https://jiyiren.github.io/project-doc/" target="_blank" rel="noopener">https://jiyiren.github.io/project-doc/</a></p>
<p><strong>无色Demo预览地址</strong>：<a href="https://jiyiren.github.io/project-doc-plain/" target="_blank" rel="noopener">https://jiyiren.github.io/project-doc-plain/</a></p>
<a id="more"></a>
<p>无色样式：</p>
<p><img src="http://img.godjiyi.cn/jy_blog-project-doc-plain.jpg" alt></p>
<h2 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h2><h3 id="安装-Nodejs"><a href="#安装-Nodejs" class="headerlink" title="安装 Nodejs"></a>安装 Nodejs</h3><ul>
<li>全球官网：<a href="https://nodejs.org/en" target="_blank" rel="noopener">https://nodejs.org/en</a></li>
<li>中文官网：<a href="http://nodejs.cn/" target="_blank" rel="noopener">http://nodejs.cn/</a></li>
</ul>
<p>下载安装后测试下 Node 是否安装成功：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v10.15.3</span><br></pre></td></tr></table></figure></div>
<p>如果提示命令没找到，那么是由于 Node 没有加入环境变量，大家将安装的 Node 环境地址放在环境变量里就可以了。</p>
<h3 id="安装-gitbook"><a href="#安装-gitbook" class="headerlink" title="安装 gitbook"></a>安装 gitbook</h3><p>直接输入命令进行安装：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ npm install gitbook-cli -g</span><br></pre></td></tr></table></figure></div>
<p><code>npm</code> 也是和 <code>node</code> 一起安装的，<code>node</code> 存在 <code>npm</code> 就存在。<code>-g</code> 参数表示全局安装，也就是模块包会安装到全局环境里，这个是推荐做法，因为像这种工具命令全局安装是最好的。而项目依赖模块则项目内安装即可。</p>
<p>测试 gitbook 命令是否安装成功：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ gitbook -V</span><br><span class="line">CLI version: 2.3.2</span><br><span class="line">GitBook version: 3.2.3</span><br></pre></td></tr></table></figure></div>
<h3 id="使用-gitbook"><a href="#使用-gitbook" class="headerlink" title="使用 gitbook"></a>使用 gitbook</h3><p>任意找一个空目录，执行：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ gitbook init</span><br><span class="line">warn: no summary file <span class="keyword">in</span> this book </span><br><span class="line">info: create README.md </span><br><span class="line">info: create SUMMARY.md </span><br><span class="line">info: initialization is finished</span><br></pre></td></tr></table></figure></div>
<p>会在当前目录下创建出两个文件，分别是：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">README.md</span><br><span class="line">SUMMARY.md</span><br></pre></td></tr></table></figure></div>
<p>暂且先不管其他的，我们现在可以直接运行试试，先把流程走通：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ gitbook build</span><br><span class="line">$ gitbook serve</span><br></pre></td></tr></table></figure></div>
<p>上面的 <code>gitbook build</code> 是编译整个 <code>markdown</code> 文件，然后在当前目录生成 <code>_book</code> 目录，里面是 html 页面。这个主要在部署的时候用到。</p>
<p>而 <code>gitbook serve</code> 是本地调试开启服务命令，项目最终是要成网站的，因此, 该命令可以开启本地 <code>http://127.0.0.1:4000</code> 地址作为网站浏览地址。</p>
<p>假如大家执行 <code>gitbook serve</code> 出错，建议大家先 <code>gitbook build</code> 在 <code>gitbook serve</code>.</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>我们上面通过 <code>gitbook init</code> 生成的只有下面两个文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">README.md</span><br><span class="line">SUMMARY.md</span><br></pre></td></tr></table></figure></div>
<p>但实际上我们要定制我们的 gitbook 项目，项目还有一个配置文件的: <strong>book.json</strong>，只不过 <code>gitbook init</code> 没有自动创建出来。我们一看这文件名就应该知道这个配置文件就是 <code>json</code> 格式的。最基本的 <strong>book.json</strong> 长什么样子呢？如下所示：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"ProjectDoc"</span>,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"jiyiren"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"ProjectDoc"</span>,</span><br><span class="line">  <span class="attr">"language"</span>: <span class="string">"zh-hans"</span>,</span><br><span class="line">  <span class="attr">"links"</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"styles"</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"pluginsConfig"</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>基本 book.json 内容：</p>
<ul>
<li><strong>title</strong>: 网站标题;</li>
<li><strong>author</strong>: 网站作者;</li>
<li><strong>description</strong>: 网站描述;</li>
<li><strong>language</strong>: 网站语言;</li>
<li><strong>links</strong>: 侧边栏配置项;</li>
<li><strong>styles</strong>: 全局自定义网站样式;</li>
<li><strong>plugins</strong>: 插件配置项;</li>
<li><strong>pluginsConfig</strong>: 配置插件的配置项，为一些插件传入参数的;</li>
</ul>
<h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>上面最基本的 <strong>book.json</strong>，对默认界面基本无变动，其界面显示为：</p>
<p><img src="http://img.godjiyi.cn/jy_projectddocbasic.jpg" alt></p>
<p>我们来一个简单 gitbook 定制，<strong>book.json</strong> 如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"title"</span>: <span class="string">"ProjectDoc"</span>,</span><br><span class="line">	<span class="attr">"author"</span>: <span class="string">"jiyiren"</span>,</span><br><span class="line">	<span class="attr">"description"</span>: <span class="string">"ProjectDoc"</span>,</span><br><span class="line">	<span class="attr">"language"</span>: <span class="string">"zh-hans"</span>,</span><br><span class="line">	<span class="attr">"links"</span>: &#123;</span><br><span class="line">	  <span class="attr">"sidebar"</span>: &#123;</span><br><span class="line">	    <span class="attr">"本文托管"</span>: <span class="string">"https://github.com/jiyiren/ProjectDoc"</span></span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"styles"</span>: &#123;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"plugins"</span>: [</span><br><span class="line">	    <span class="string">"anchor-navigation-ex@0.1.8"</span></span><br><span class="line">	],</span><br><span class="line">	<span class="attr">"pluginsConfig"</span>: &#123;</span><br><span class="line">	    <span class="attr">"anchor-navigation-ex"</span>: &#123;</span><br><span class="line">	        <span class="attr">"isRewritePageTitle"</span>: <span class="literal">true</span>,</span><br><span class="line">	        <span class="attr">"isShowTocTitleIcon"</span>: <span class="literal">true</span>,</span><br><span class="line">	        <span class="attr">"tocLevel1Icon"</span>: <span class="string">"fa fa-hand-o-right"</span>,</span><br><span class="line">	        <span class="attr">"tocLevel2Icon"</span>: <span class="string">"fa fa-hand-o-right"</span>,</span><br><span class="line">	        <span class="attr">"tocLevel3Icon"</span>: <span class="string">"fa fa-hand-o-right"</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其界面为如下，多出左侧栏 <strong>本文托管</strong>，和文章右侧的 <strong>目录以及回到开头</strong> 按钮。</p>
<p><img src="http://img.godjiyi.cn/jy_projectdocselfdefine.jpg" alt></p>
<h2 id="必备插件"><a href="#必备插件" class="headerlink" title="必备插件"></a>必备插件</h2><p>插件使用</p>
<ul>
<li><p>插件添加：插件的使用就放在 <strong>book.json</strong> 的 <strong>plugins</strong> 和 <strong>pluginsConfig</strong> 键中，形式如：<code>pluginName@versionName</code> 也就是<strong>插件名@版本</strong>，当然没有版本时，采用最新默认版本。</p>
</li>
<li><p>插件删除：要删除自带的插件则使用 <code>-pluginName</code> 即 <strong>-插件名</strong></p>
</li>
</ul>
<p>下面介绍本文档使用到的插件。</p>
<h3 id="splitter"><a href="#splitter" class="headerlink" title="splitter"></a>splitter</h3><p>使侧边栏的宽度可以自由调节</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">    &quot;splitter&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>
<h3 id="simple-page-toc"><a href="#simple-page-toc" class="headerlink" title="simple-page-toc"></a>simple-page-toc</h3><p>文章页面右上角显示目录，这个目前已经被废弃，建议每个页面自己生成 md 目录。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"plugins"</span> : [</span><br><span class="line">        <span class="string">"simple-page-toc"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"pluginsConfig"</span>: &#123;</span><br><span class="line">        <span class="attr">"simple-page-toc"</span>: &#123;</span><br><span class="line">            <span class="attr">"maxDepth"</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">"skipFirstH1"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="search-plus"><a href="#search-plus" class="headerlink" title="search-plus"></a>search-plus</h3><p>支持中文搜索, 需要将默认的 search 和 lunr 插件去掉</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"plugins"</span>: [<span class="string">"-lunr"</span>, <span class="string">"-search"</span>, <span class="string">"search-plus"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="tbfed-pagefooter"><a href="#tbfed-pagefooter" class="headerlink" title="tbfed-pagefooter"></a>tbfed-pagefooter</h3><p>为页面添加页脚</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"plugins": [</span><br><span class="line">   <span class="string">"tbfed-pagefooter"</span></span><br><span class="line">],</span><br><span class="line">"pluginsConfig": &#123;</span><br><span class="line">    "tbfed-pagefooter": &#123;</span><br><span class="line">        "copyright":"Copyright &amp;copy zhangjikai.com 2017",</span><br><span class="line">        "modify_label": "该文件修订时间：",</span><br><span class="line">        "modify_format": "YYYY-MM-DD HH:mm:ss"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="anchor-navigation-ex"><a href="#anchor-navigation-ex" class="headerlink" title="anchor-navigation-ex"></a>anchor-navigation-ex</h3><p>添加Toc到侧边悬浮导航以及回到顶部按钮，这个自动生成的悬浮目录必须以下面形式书写，也就是一定要有一个是 <strong>h1</strong> 开头的，否则不能识别。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line"># h1</span><br><span class="line">## h2</span><br><span class="line">### h3</span><br></pre></td></tr></table></figure></div>
<p>配置代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"plugins"</span>: [</span><br><span class="line">        <span class="string">"anchor-navigation-ex"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"pluginsConfig"</span>: &#123;</span><br><span class="line">        <span class="attr">"anchor-navigation-ex"</span>: &#123;</span><br><span class="line">            <span class="attr">"isRewritePageTitle"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"isShowTocTitleIcon"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"tocLevel1Icon"</span>: <span class="string">"fa fa-hand-o-right"</span>,</span><br><span class="line">            <span class="attr">"tocLevel2Icon"</span>: <span class="string">"fa fa-hand-o-right"</span>,</span><br><span class="line">            <span class="attr">"tocLevel3Icon"</span>: <span class="string">"fa fa-hand-o-right"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="prism"><a href="#prism" class="headerlink" title="prism"></a>prism</h3><p>使用 <code>Prism.js</code> 为语法添加高亮显示，需要将 <code>highlight</code> 插件去掉。该插件自带的主题样式较少，可以再安装 <code>prism-themes</code> 插件，里面多提供了几种样式，具体的样式可以参考 <a href="https://github.com/PrismJS/prism-themes" target="_blank" rel="noopener">这里</a>，在设置样式时要注意设置 css 文件名，而不是样式名。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"-highlight"</span>,</span><br><span class="line">    <span class="string">"prism@^2.1.0"</span>,</span><br><span class="line">    <span class="string">"prism-themes@^0.0.2"</span></span><br><span class="line">  ],</span><br><span class="line"><span class="attr">"pluginsConfig"</span>: &#123;</span><br><span class="line">	<span class="attr">"prism"</span>: &#123;</span><br><span class="line">      <span class="attr">"css"</span>: [</span><br><span class="line">        <span class="string">"prism-themes/themes/prism-a11y-dark.css"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其他插件大家可以参考这个博主的：<a href="http://gitbook.zhangjikai.com/plugins.html" target="_blank" rel="noopener">http://gitbook.zhangjikai.com/plugins.html</a></p>
<p>最终的页面示例</p>
<p>有配色见：<a href="https://jiyiren.github.io/project-doc/" target="_blank" rel="noopener">https://jiyiren.github.io/project-doc/</a></p>
<p>无配色见：<a href="https://jiyiren.github.io/project-doc-plain/" target="_blank" rel="noopener">https://jiyiren.github.io/project-doc-plain/</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></li>
<li><a href="https://jiyiren.github.io/2018/08/04/kafka/" target="_blank" rel="noopener">https://jiyiren.github.io/2018/08/04/kafka/</a></li>
<li><a href="http://gitbook.zhangjikai.com/themes.html" target="_blank" rel="noopener">http://gitbook.zhangjikai.com/themes.html</a></li>
<li><a href="http://www.chengweiyang.cn/gitbook/" target="_blank" rel="noopener">http://www.chengweiyang.cn/gitbook/</a></li>
<li><a href="https://www.cnblogs.com/YangJieCheng/p/7991660.html" target="_blank" rel="noopener">https://www.cnblogs.com/YangJieCheng/p/7991660.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Gitbook</category>
      </categories>
      <tags>
        <tag>project</tag>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS 下多 Python 版本说明</title>
    <url>/2017/10/31/python_environmet/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">好的配置环境是保证产能的前提</p>

<p>应大数据和机器学习的要求，对处理数据的计算机语言需求越来大，之前虽然弄过 <strong>Python</strong> 环境，但是没有彻底搞清楚 <strong>Python</strong> 多版本执行程序以及多版本的模块位置，导致自己电脑上环境紊乱，今天花了点功夫解决下。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><hr>
<p>我的电脑是 <strong>MacOS</strong> 系统，并且 <strong>MacOS</strong> 系统是自带了 <strong>Python</strong>，而之前在捣鼓 <strong>Python</strong> 时，可能后装了很多次不同的版本，导致在我电脑上的的 <strong>Python</strong> 有诸多问题，这里主要说明以下几个问题：</p>
<ol>
<li><strong>多版本 Python 的安装路径识别</strong></li>
<li><strong>多版本 Python 对应的 pip 命令识别</strong></li>
<li><strong>多版本 Python 对应的 pip 安装模块位置确定</strong></li>
</ol>
<a id="more"></a>
<h3 id="安装路径识别"><a href="#安装路径识别" class="headerlink" title="安装路径识别"></a>安装路径识别</h3><p><strong>Python</strong> 现在分为两个版本 <em>2.X 版本</em> 和 <em>3.X 版本</em>，两代版本并不能够完全兼容，因此两个版本的模块包也会分开安装的，因此完全把握两种版本环境是很有必要的。</p>
<p><strong>Python 2.X版本</strong></p>
<p>此版本对应旧版本，其默认执行命令是 <code>python</code>, 因此我们在终端输入 <code>python --version</code> 通常会显示 2.X 的版本字样。</p>
<p>通过 <code>which python</code> 命令查看 <strong>Python</strong> 路径，然后用 <code>ls -l</code> 可查看该路径的 <strong>Python</strong> 执行文件属性如下：</p>
<p><img src="http://img.godjiyi.cn/pyset1.jpg" alt></p>
<p>上图显示 <strong>/usr/bin/python</strong> 文件非软链接文件，由于我们自己安装的 <strong>Python</strong> 通常是用软链接的方式链接到安装目录，因此这里的 <strong>python</strong> 应该属于本机自带的 <strong>Python</strong>, 其安装位置即为 <strong>/usr/bin/python</strong>.</p>
<p><strong>Python 3.X版本</strong></p>
<p>此版本对应新版本，其默认执行命令是 <code>python3</code>, 不是完全兼容旧版本的，但是代表了 <strong>Python</strong> 的发展方向，新人的话建议直接学习此版本。</p>
<p>通过 <code>which python3</code> 命令查看 <strong>Python3</strong> 路径，然后用 <code>ls -l</code> 查看路径的的文件属性：</p>
<p><img src="http://img.godjiyi.cn/pyset2.jpg" alt></p>
<p>上图显示 <strong>/usr/local/bin/python3</strong> 文件为软链接文件，链接的源位置为 <strong>/Library/Frameworks/Python.framework/Versions/3.5/bin/python3</strong>, 因此这就是 <strong>Python3</strong> 的安装位置，由此也可以知道当前 <strong>Python3</strong> 的版本是 <strong>3.5</strong>.</p>
<p>实际上系统自带的命令通常安装在 <strong>/usr/bin/</strong> 目录下，而用户自己安装的命令通常在 <strong>/usr/local/bin/</strong> 目录下，这通常是因为普通安装命令都是在 <strong>/usr/local/bin/</strong> 下有写的权限的。</p>
<h3 id="pip-命令识别"><a href="#pip-命令识别" class="headerlink" title="pip 命令识别"></a>pip 命令识别</h3><p><strong>Python</strong> 版本的不同导致 <strong>Python</strong> 下的包管理工具 <strong>pip</strong> 命令也不同，因此使得 <strong>pip</strong> 命令也产生很多的 <em>pipX</em> 命令。通常而言，对于 <strong>Python2x</strong> 版本其对应的 <strong>pip</strong> 命令为 <em>pip</em>, 而对于 <strong>Python3.X</strong> 版本其对应的 <strong>pip</strong> 命令为<em>pip3</em>. 此外，还有一种可同时执行不同版本 <strong>Python</strong> 的 <strong>pip</strong> 方式：<em>python -m pip install xxx</em> 或者 <em>python3 -m pip install xxx</em>, 这就不需要用不同的命令了，但是前提还是需要摸清自己本机的环境。</p>
<p><strong>Python2.X 版本的 pip</strong></p>
<p>通过 <code>which pip</code> 查看 <strong>pip</strong> 路径，然后用 <code>ll</code> 查看文件属性，该文件为非链接文件，其与上面的 <strong>Python</strong> 相对应</p>
<p><img src="http://img.godjiyi.cn/pyset3.jpg" alt></p>
<p>我们也可以通过命令来查看 <strong>pip</strong> 目录中有哪些 <code>pip</code>:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">ll /usr/<span class="built_in">local</span>/bin | grep pip</span><br></pre></td></tr></table></figure></div>
<p>结果：</p>
<p><img src="http://img.godjiyi.cn/pyset4.jpg" alt></p>
<p>我们看到上图有好多 <code>pip</code> 命令，到底哪些可用或者一致呢？我们可以看这些命令的 <strong>创建时间</strong> 基本可以判断前三个 <code>pip</code> 是同一时刻安装的，最后一个是另外时间安装的 <code>pip</code> 工具，我们可以通过 <code>pip</code> 命令安装一个已经存在的模块查看其已经安装的模块路径如下图，我们可以知道 <em>pip, pip2, pip2.7</em> 都是 <em>Python2.X 版本的</em> <code>python</code> 命令所对应的 <code>pip</code>.</p>
<p><img src="http://img.godjiyi.cn/pyset5.jpg" alt></p>
<p><strong>Python3.X 版本的 pip3</strong></p>
<p>通过 <code>which pip3</code>查看 <strong>pip</strong> 路径，然后用 <code>ll</code> 查看文件属性如下图，然而，<code>pip3</code> 并没有此命令，但我们从之前的查看命令可知存在 <code>pip3.5</code> 命令</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">ll /usr/<span class="built_in">local</span>/bin | grep pip</span><br></pre></td></tr></table></figure></div>
<p>再次执行 <code>which pip3.5</code>，情况如下：</p>
<p><img src="http://img.godjiyi.cn/pyset7.jpg" alt></p>
<p>我们天真地以为 <code>pip3.5</code> 命令就是我们 <strong>Python3.X 版本的</strong> <code>pip</code>，我们执行安装命令试试 <code>pip3.5 install numpy</code>，结果如下：</p>
<p><img src="http://img.godjiyi.cn/pyset9.jpg" alt></p>
<p>执行报错，这错误网上有解决方法 <a href="http://blog.chinaunix.net/uid-20940095-id-4304535.html" target="_blank" rel="noopener">这里</a>, 但是我们这里不确定此 <strong>Python3.5</strong> 是否关联我们本机的 <strong>Python3</strong>，因为这有可能是自己以前安装了 <strong>Python3.5</strong> 又卸载后存留的。这里我们再试试另外一种可能，<em>就是本机 Python3 的 pip 在另外地方，只不过它没有在环境变量中</em>，我们可以如下测试 <code>python3 -m pip --version</code>, 我们也可以尝试安装一个包，如图，可以确定通过 <strong>Python3</strong> 内部的 <strong>pip</strong> 可以将模块安装在内部目录里。</p>
<p><img src="http://img.godjiyi.cn/pyset10.jpg" alt></p>
<p>至此可以确定，<strong>Python3</strong> 对应的 <code>pip</code> 在自己安装路径内部，而不通过环境变量直接定位，需要通过 <code>python3 -m pip install xxxx</code> 来安装模块。</p>
<h3 id="pip模块安装路径确定"><a href="#pip模块安装路径确定" class="headerlink" title="pip模块安装路径确定"></a>pip模块安装路径确定</h3><p>到这里我想大家已经知道如何确定 <strong>pip</strong> 模块的安装位置了，主要要首先确定 <strong>Python</strong> 各个版本对应的 <strong>pip</strong>，然后通过 <strong>pip</strong> 的重复安装即可确定模块安装位置。</p>
<blockquote>
<p>注意：下面的安装位置仅仅是我自己系统上的环境位置，并非适用你自己的环境，需要自己确定自己的 <strong>Python</strong> 版本和 <strong>pip</strong> 版本</p>
</blockquote>
<p><em>Python2.X版本的模块位置</em>:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure></div>
<p><em>Python3.X版本的模块位置</em>:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">python3 -m pip install numpy</span><br></pre></td></tr></table></figure></div>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Python2.X</strong>:</p>
<p>执行路径: <strong>/usr/bin/python</strong></p>
<p>pip 路径: <strong>/usr/local/bin/pip</strong>, <strong>/usr/local/bin/pip2</strong>, <strong>/usr/local/bin/pip2.7</strong></p>
<p>模块位置:<strong>/usr/local/lib/python2.7/site-packages</strong></p>
<p><strong>Python3.X</strong>:</p>
<p>执行路径: <strong>/Library/Frameworks/Python.framework/Versions/3.5/bin/python3</strong></p>
<p>pip 路径: <strong>/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/pip-9.0.1-py3.5.egg</strong></p>
<p>模块位置: <strong>/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages</strong></p>
<p><strong>Python</strong> 存在不统一路径查找的原因：</p>
<p><em>(1). 通过 pkg 安装包</em>: Python 官网 <a href="https://www.python.org/downloads/" target="_blank" rel="noopener">https://www.python.org/downloads/</a>, 下载后文件为 <strong>python-3.6.3-macosx10.6.pkg</strong> 形式的文件，这种文件可直接双击安装，其安装的位置通常在 <strong>/Library/Frameworks</strong> 下。</p>
<p><em>(2). 通过 homebrew 安装</em>: Homebrew 官网 <a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a>, 其安装方式为:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">brew install python <span class="comment"># 安装python2.X</span></span><br><span class="line">brew install python3 <span class="comment"># 安装python3.X</span></span><br></pre></td></tr></table></figure></div>
<p>这种方式安装是先将包下载在 <strong>/usr/local/Cellar</strong> 目录下，然后自动在 <strong>/usr/local/bin/</strong> 下新建一个执行链接到 <strong>/usr/local/Cellar</strong>.</p>
<p>如：我们安装一个wget 工具：<code>brew install wget</code>，然后我们可以查看<em>wget</em>的原路径：</p>
<p><img src="http://img.godjiyi.cn/pyset11.jpg" alt></p>
<p>对于安装用 <strong>brew</strong> 安装 <strong>Python3</strong>，其也会自动下载对应的 <strong>pip3</strong> 的，并且都会将其放置在 <strong>/usr/local/bin/目录下</strong>，以软链接的形式链接到 <strong>/usr/local/Cellar下的对应文件</strong>.</p>
<p><em>(3). 通过源码包</em>: 这会自动放置在 <strong>/usr/local/bin</strong> 目录下，且不会用软链接。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.jianshu.com/p/51811fa24752/" target="_blank" rel="noopener">MacO S安装 Python2X 和 Python3</a></li>
<li><a href="https://www.zhihu.com/question/21653286/answer/95532074" target="_blank" rel="noopener">同时装了 Python3 和 Python2，怎么用 pip</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title>一份 LaTeX 报告形式模板</title>
    <url>/2018/12/13/report_paper/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">A LaTeX Template for Report, With Supporting Chinese Language</p>


<p><img src="http://img.godjiyi.cn/jy_hothit.jpg" alt></p>
<p><strong>项目源码地址</strong>：<a href="https://github.com/jiyiren/ReportPaper" target="_blank" rel="noopener">https://github.com/jiyiren/ReportPaper</a></p>
<p><strong>文档预览地址</strong>：<a href="http://img.godjiyi.cn/report_paper.pdf" target="_blank" rel="noopener">http://img.godjiyi.cn/report_paper.pdf</a></p>
<a id="more"></a>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>需要先安装 LaTeX 环境，而支持中文的 LaTeX 为 <a href="http://www.ctex.org/HomePage" target="_blank" rel="noopener">CTeX</a>，CTeX 也只是一种标准定义，其通常分为两个发行版：</p>
<ul>
<li>TeXLive: <a href="http://tug.org/texlive/" target="_blank" rel="noopener">http://tug.org/texlive/</a> </li>
<li>MiKTeX: <a href="https://miktex.org/" target="_blank" rel="noopener">https://miktex.org/</a></li>
</ul>
<p>两个发行版都是全平台支持的，很多人会将 <a href="http://tug.org/mactex/" target="_blank" rel="noopener">MacTex</a> 也作为一种发行版，但我喜欢将其归类于 TeXLive 发行版中，这看自己的意愿。</p>
<p>因此，环境的话大家可以自行选择，这里为使用 TeXLive，下面为安装包地址，大概有 3 GB 左右：</p>
<ul>
<li>MacOS: <a href="http://tug.org/mactex/" target="_blank" rel="noopener">MacTex</a></li>
<li>Windows: <a href="http://mirrors.hust.edu.cn/CTAN/systems/texlive/Images/" target="_blank" rel="noopener">TeXLive.iso</a></li>
</ul>
<p>安装后将命令加入环境变量，并使之生效，通过 <code>which latex</code> 可查看是否设置成功：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">which</span> latex</span><br><span class="line">/usr/<span class="built_in">local</span>/texlive/2018/bin/x86_64-darwin/latex</span><br></pre></td></tr></table></figure></div>
<h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>LaTeX 实际上如果 Java 语言一样，都需要先配置环境，然后选择一款自己喜欢的 IDE 进行编写“代码”。</p>
<p>当然所有文本编辑器都可以编写 LaTeX 或者 Java 等其他语言“代码”。这里的 IDE 指集成了一些语言本地化的功能，比如编译、特殊符号等等。</p>
<p>LaTeX 的发行版中会自带一款编辑器，用 TexLive 的话，MacOS 上会有个叫 <strong>TexShop</strong> 的编辑器，而 Windows 上则会是一个叫 <strong>TexWorker</strong> 的编辑器，这些是都可以胜任编写工作的。</p>
<p>另外，对于第三的 LaTeX 编辑器，笔者也用的不多，这里我推荐两个：</p>
<ul>
<li>TeXMaker: <a href="http://www.xm1math.net/texmaker/" target="_blank" rel="noopener">http://www.xm1math.net/texmaker/</a>, 全平台，免费，强烈推荐；</li>
<li>TeXStudio: <a href="http://texstudio.sourceforge.net/" target="_blank" rel="noopener">http://texstudio.sourceforge.net/</a> , 全平台，免费，推荐；</li>
<li>WinEdt: <a href="http://www.winedt.com/index.html" target="_blank" rel="noopener">http://www.winedt.com/index.html</a> , 只支持 Windows，收费，自己选；</li>
</ul>
<p>我个人推荐前两个，因为第三个收费且不跨平台，之所以写上第三个，主要是因为网络上很多博客或用户都推荐用第三个，这个我使用时也感觉不错，但每次我使用都得到 Windows 上使用，比较麻烦。当然，如果你使用 Windows 且有钱，WinEdt 确实使用体验和功能都是比较好的。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>上面两点都讲了没实际作用的环境配置，对于使用本项目实际上很简单：</p>
<ul>
<li><p>使用 XeLaTeX 编译：</p>
  <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">xelatex report_paper.tex</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>用 BiBTeX 再次编译生成的 <code>report_paper.aux</code> 文件：</p>
  <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">bibtex report_paper.aux</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>之后再次用 XeLaTeX 编译：</p>
  <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">xelatex report_paper.tex</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
<p>这时候生成的 <code>pdf</code> 文件是最全和完整的文档。</p>
<p>上面是命令行编译的，大家若使用 IDE 则是比较简单的操作：</p>
<ul>
<li>编译选择 XeLaTeX 编译一次；</li>
<li>再选择 BiBTeX 编译一次；</li>
<li>再选择 XeLaTeX 编译一次；</li>
</ul>
<p>这时产生的 <code>pdf</code> 和上面一致；通过编辑器形式不用自己指定文件名，因此更简单方便。</p>
<p>最终生成的 pdf 文档示例：</p>
<ul>
<li>github: <a href="https://github.com/jiyiren/ReportPaper/blob/master/report_paper.pdf" target="_blank" rel="noopener">report_paper.pdf</a></li>
<li>七牛：<a href="http://img.godjiyi.cn/report_paper.pdf" target="_blank" rel="noopener">report_paper.pdf</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.ctex.org/HomePage" target="_blank" rel="noopener">CTeX</a></li>
<li><a href="http://tug.org/texlive/" target="_blank" rel="noopener">TexLive</a></li>
<li><a href="https://miktex.org/" target="_blank" rel="noopener">MiKTeX</a></li>
<li><a href="http://www.tug.org/mactex/index.html" target="_blank" rel="noopener">MacTeX</a></li>
<li><a href="http://www.xm1math.net/texmaker/index.html" target="_blank" rel="noopener">TexMaker(全平台支持编辑器)</a></li>
<li><a href="http://texstudio.sourceforge.net/" target="_blank" rel="noopener">TeXstudio(全平台支持编辑器)</a></li>
</ul>
]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>report</tag>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring项目整合</title>
    <url>/2017/07/24/spbootapi/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">No Repeating, Just Coding</p>


<p>最近用 <code>Spring</code> 写后台较多，每次新建一个项目要从原来项目里拷贝很多配置文件，因此就想整合一个配置好的的基本项目架构。<code>Spring boot</code> 融合了 <code>tomcat</code>, 使用后爱不释手，因此主要基于 <strong>Spring boot + MVC</strong> 以及一些其他必要功能进行配置使用。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><hr>
<p>项目代码地址: <a href="https://github.com/jiyiren/SpbootApi" target="_blank" rel="noopener">https://github.com/jiyiren/SpbootApi</a></p>
<p>这个仓库主要是集成 <strong>Spring-boot, Spring-mvc, Mysql, Mybatis, C3p0, <a href="https://swagger.io/" target="_blank" rel="noopener">Swagger2</a></strong> 的项目架构,为便于每次新建项目不用从零开始,直接基于此项目结构可快速地进行项目二次开发，免去了 <strong>pom</strong> 内容的复制和配置文件的编写。</p>
<h3 id="整体项目结构"><a href="#整体项目结构" class="headerlink" title="整体项目结构"></a>整体项目结构</h3><p><img src="http://img.godjiyi.cn/spbootapi-arc.png" alt="项目结构"></p>
<a id="more"></a>
<h3 id="Swagger-API-UI-页面"><a href="#Swagger-API-UI-页面" class="headerlink" title="Swagger API UI 页面"></a>Swagger API UI 页面</h3><p>默认访问地址: <em><a href="http://127.0.0.1:8899/swagger-ui.html" target="_blank" rel="noopener">http://127.0.0.1:8899/swagger-ui.html</a></em></p>
<p><img src="http://img.godjiyi.cn/spbootapi-swaggerui.png" alt="SwaggerUi"></p>
<h3 id="Demo接口"><a href="#Demo接口" class="headerlink" title="Demo接口"></a>Demo接口</h3><p>测试接口: <em><a href="http://127.0.0.1:8899/user/1" target="_blank" rel="noopener">http://127.0.0.1:8899/user/1</a></em></p>
<p><img src="http://img.godjiyi.cn/spbootapi-json.png" alt="json"></p>
<h2 id="二次开发实践"><a href="#二次开发实践" class="headerlink" title="二次开发实践"></a>二次开发实践</h2><hr>
<p>下载项目:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/jiyiren/SpbootApi.git</span><br></pre></td></tr></table></figure></div>
<p>命令运行项目:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> SpbootApi</span><br><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure></div>
<p>IDE 运行项目 ( 推荐 Intellij IDEA ):</p>
<p>打开ApiApplication.class，内部包含main函数，右击 <code>Run ApiApplication</code>.</p>
<p>测试</p>
<p>访问:<a href="http://127.0.0.1:8899" target="_blank" rel="noopener">http://127.0.0.1:8899</a> 返回 <strong>Hello World!</strong></p>
<p>访问:<a href="http://127.0.0.1:8899/user/1" target="_blank" rel="noopener">http://127.0.0.1:8899/user/1</a> 返回 <strong>json</strong> 数据</p>
<p>修改包名(下面为包含包名的文件)</p>
<ul>
<li><em>resources/application.propertis</em> : 项目总配置文件</li>
<li><em>java/包名/Swagger2.class</em> : <strong>swagger-ui</strong> 配置文件</li>
<li><em>java/包名/c3p0/C3p0AutoConfiguration.class</em> : <strong>c3p0</strong> 连接池配置文件</li>
</ul>
<h2 id="POM依赖包"><a href="#POM依赖包" class="headerlink" title="POM依赖包"></a>POM依赖包</h2><hr>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--properties--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">jacksonVersion</span>&gt;</span>2.8.8<span class="tag">&lt;/<span class="name">jacksonVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">c3p0Version</span>&gt;</span>0.9.5.2<span class="tag">&lt;/<span class="name">c3p0Version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- web --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jdbc--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--aop--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mysql包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jackson包 jackson-core,jackson-databind,jackson-annotations --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jacksonVersion&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- c3p0 和 mchange-commons-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;c3p0Version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- swagger --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.jianshu.com/p/8033ef83a8ed" target="_blank" rel="noopener">Spring Boot中使用Swagger2构建强大的RESTful API文档</a></li>
<li><a href="http://www.cnblogs.com/xiaosiyuan/p/6255292.html" target="_blank" rel="noopener">springboot 使用c3p0数据库连接池的方法
</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>时序数据介绍</title>
    <url>/2018/06/22/time-sequence/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">基于时间序列，实现数据聚合</p>

<p><strong>时序数据</strong> 就是基于时间序列的数据，其常常表现为同一指标按时间序列记录的数据列，在需求实时性的场景中比较常见。而对于此种数据的运用通常使用基本的 <strong>聚合</strong> 方式就能达到需求了。当然，目前 <code>AI</code> 盛行的时代，机器学习领域也不断出现很多基于 <strong>时序预测</strong> 的算法。但本文主要介绍时序数据的基础认识，这部分的认知主要是从自己目前所做的数据监控项目的经验所得，若有不正确，请大家批评指正。</p>
<h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2><p><strong>时序数据</strong> 和一般的数据没什么区别的，基本上也都用 <strong>json</strong> 格式表示，唯一不同点就是数据中一定包含关于 <strong>时间</strong> 的信息，比如： <strong>时间戳</strong>。</p>
<p>一般一条时序数据只表示一个键值信息，而在时序数据中，这个键常常称为 <strong>指标</strong> 或 <strong>指标名</strong> (英: <em>metric</em> )，而值则就是指标对应的值了。因而，一个时序数据的基本格式如下：</p>
<a id="more"></a>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "timestamp": 1346846400,    // 时间戳</span><br><span class="line">  "metric": "sys.mem.bytes",  // 指标名</span><br><span class="line">  "value": 18				  // 指标值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要包含了 <strong>时间戳、指标名、指标值</strong>。其中，对于指标的值，也就是上面的 <strong>value</strong> 字段值，这个值一般都是 <strong>数值型</strong> ( <em>Integer、Float、Double</em> ) 的, 为什么大多是 <strong>数值型</strong> 的呢？这个下面会进行说明。</p>
<p>到这里，我们已经知道了一个时序数据的基本格式。但是，难道时序数据就是一个格式吗？即使加入了时间信息，那也和普通的 <strong>json</strong> 数据也没什么本质区别呀？</p>
<h2 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h2><p>的确，时序数据的存在可不是因为一个数据格式，而是由于 <strong>数据聚合</strong> 应用的需求而出现的。比如，我们现在有 1 台服务器，我想快速地知道今天上午 10 点到上午 12 点之间这台服务器的 <strong>内存</strong> 使用的 <em>平均值、最高值、最小值</em>，那我们怎么办？其中，这个指标可能也会是 <strong>CPU</strong>、<strong>磁盘 IO</strong> 等其他指标。</p>
<p>这里我们可以看出像 <em>平均值、最高值、最小值</em> 等等功能对于 <strong>metric</strong> 是通用的，因此，我们只需要将各种需求功能设计成通用的 <strong>聚合函数</strong>，那么我们需要看哪种指标的 <em>平均、最高、最小</em> 等聚合值时，只要选择对应的函数即可了。</p>
<p>这实际上也就是为什么 <strong>value</strong> 字段大多是 <strong>数值型</strong> 的原因，因为聚合函数绝大部分只是一些常规的 <strong>数学计算</strong>，数值型是最好处理的类型。当然这不是绝对的，只要你的后台明白如何处理对应的值类型即可了。</p>
<p>然而，上面举例是 1 台服务器，那我们如果有 2 或多台服务器，比如叫 hostA，hostB，host… 。 那么，我们直接对内存指标进行聚合那会计算到两台机器的聚合值，这个不是我们想要的，我们需要能对特定的主机进行聚合的能力，那该如何做？</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>这时就用到了 <strong>标签</strong> 功能，一个标签就是一个 <strong>键值对</strong>，通常标签是作为后台的过滤条件的，而由于过滤条件的多样化也需要标签的多样化，因此一个时序数据中可以包含多个标签的。从而我们需要在基本的时序数据格式中再添加一种 <strong>键名</strong>，即 <em>标签组</em> – <em>tags</em>，如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "timestamp": 1346846400,    // 时间戳</span><br><span class="line">  "metric": "sys.mem.bytes",  // 指标名</span><br><span class="line">  "value": 18,				  // 指标值</span><br><span class="line">  "tags":&#123;                    // 标签组</span><br><span class="line">    "host.name": "hostA",</span><br><span class="line">    "address": "shanghai"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样表示的时序数据更具有通用化、个性化、定制化的能力，从而我们可以先进行指标、标签的过滤后再进行相应的 <strong>聚合操作</strong>，这样就能更满足多样化的业务需求。而上面多台服务器的情况，则需要在上传数据时加入 <code>host.name</code> 值, 这样后台可根据该字段检索 <code>host.name = hostA</code> 也就是 A 主机的指标，然后对特定指标进行聚合即可。</p>
<h2 id="总结说明"><a href="#总结说明" class="headerlink" title="总结说明"></a>总结说明</h2><p>时序数据的需求通常是出现在 <strong>随着时间的推移某个指标值变化关系到业务运转</strong> 的情况下，因此我们就需要 <strong>间隔性地上传那个指标的数据</strong> 以实时地知道其状态值以应对突发情况，这个实际上就是一种 <strong>数据监控</strong> 场景。这里的 <strong>监控</strong> 可不是我们平常的视频监控，而是 <em>指标的检测与上报</em>，比如我们用 <strong>脚本</strong> 实时检测网站服务器的内存指标状态、CPU 状态、磁盘 IO 状态并上传到统一的后台，这个传输过程的数据格式就是使用时序数据，这样后台只需通过简单的 <strong>聚合功能</strong> 就能够对服务器的运行状态 <em>了如指掌</em> 了。</p>
<p>目前，时序数据应用最为广泛的也就是上面提到的 <em>实时检测服务器主机指标</em> 状态信息了，比如：阿里云、腾讯云等这些公有云服务提供商，当你购买一台服务器后，你在后台是可以看到一些服务器的性能指标的，这些指标信息就是实时监控主机并以 <strong>时序数据</strong> 格式传输出来的。</p>
<p>明白了上面的时序格式和应用方式，我们可以反过来想下，实际上时序数据的出现主要是由于 <strong>我们很想知道一段时间内一些指标信息的聚合结果</strong> 而产生的。为实现这种目的，我们不希望重复实现聚合功能，因此只需要实现一次可复用的聚合函数即可，这就产生了通用的 <strong>聚合函数</strong>。这相应地要求一条时序数据只包含一条 <strong>指标信息</strong> 以实现简单统一、包含一组 <strong>标签信息</strong> 以便实现筛选过滤。</p>
<p>因此，时序数据和其他一切业务名词一样，也<strong>都是由大量的实际需求逐渐演变成的统一化、规格化的结果！</strong>都是历史的选择！</p>
]]></content>
      <categories>
        <category>Metric</category>
      </categories>
      <tags>
        <tag>Metric</tag>
        <tag>Timing Data</tag>
      </tags>
  </entry>
  <entry>
    <title>WordPress 搭建网站教程</title>
    <url>/2015/12/14/wordpress_setupweb/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">建站从未如此简单</p>

<p><a href="https://cn.wordpress.org/" target="_blank" rel="noopener">WordPress</a> 是一个开源的网站框架平台，它可以在几分钟之内让你搭建一个简单易用而又美观大方的网站，它集成了前端、后台、数据库设计等所有技术设计，能让你很方便的维护更新网站！并且支持插件，拥有很大的开发平台！<a href="http://jyblog.duapp.com/" target="_blank" rel="noopener">http://jyblog.duapp.com/</a>这个是我搭建的 <strong>WordPress</strong> 博客，目前已不可访问，大家也可以将自己的应用部署在百度的 <strong><a href="https://cloud.baidu.com/product/bae.html" target="_blank" rel="noopener">BAE</a></strong> 服务里，简单外网可访问，且价格厚道；</p>
<p>下面我简单介绍在本地搭建一个博客系统的过程！</p>
<h2 id="下载官方源码"><a href="#下载官方源码" class="headerlink" title="下载官方源码"></a>下载官方源码</h2><p>官网地址：<a href="https://cn.wordpress.org/" target="_blank" rel="noopener">https://cn.wordpress.org/</a></p>
<p>点击右下角的</p>
<p><img src="http://img.godjiyi.cn/wpwinwp.png" alt></p>
<p>百度云地址:<a href="http://pan.baidu.com/s/1i401g6x" target="_blank" rel="noopener">http://pan.baidu.com/s/1i401g6x</a></p>
<p>百度云备用地址:<a href="http://pan.baidu.com/s/1eQK9KII" target="_blank" rel="noopener">http://pan.baidu.com/s/1eQK9KII</a></p>
<p>百度云里的是 <em>4.4</em> 的，如果大家以后下载可以将在官方的下载地址复制到百度云里的离线下载里下载到百度云，再从百度云里下载就更快了！</p>
<a id="more"></a>
<h2 id="本地服务器搭建"><a href="#本地服务器搭建" class="headerlink" title="本地服务器搭建"></a>本地服务器搭建</h2><p><strong>WordPress</strong> 是由 <strong>PHP</strong> 写的，数据库建议用 <strong>MySQL</strong>，所以我们要搭建一个 <strong>PHP</strong> 服务器环境。我使用的是 <a href="http://www.wampserver.com/en/" target="_blank" rel="noopener">WAMP</a> 软件，因为它集成了 <em>Apache</em>、<em>PHP</em>、<em>MySQL</em> 只要下载一个 <strong>WAMP</strong> 软件就行了。</p>
<h3 id="WAMP-下载与安装"><a href="#WAMP-下载与安装" class="headerlink" title="WAMP 下载与安装"></a>WAMP 下载与安装</h3><p>官网地址：<a href="http://www.wampserver.com/en/" target="_blank" rel="noopener">http://www.wampserver.com/en/</a></p>
<p>百度云地址:<a href="http://pan.baidu.com/s/1qXsLuBa" target="_blank" rel="noopener">http://pan.baidu.com/s/1qXsLuBa</a></p>
<p>备用百度云链接:<a href="http://pan.baidu.com/s/1bnT3uZd" target="_blank" rel="noopener">http://pan.baidu.com/s/1bnT3uZd</a></p>
<p>下载完后是这样的：</p>
<p><img src="http://img.godjiyi.cn/wpxamppwp.png" alt></p>
<p>直接双击安装就行了，打开软件会在电脑右下角有个图标，单击启动所有服务直到图标变为绿色</p>
<p><img src="http://img.godjiyi.cn/wpwpstart.png" alt></p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>单击右下角图标，鼠标放到 <strong>MySQL</strong> 上，点击 <strong>MySQL</strong> 控制台：</p>
<p><img src="http://img.godjiyi.cn/wpwpmysql.png" alt></p>
<p>进入一个 <em>cmd</em> 的窗口，默认密码为空，所以直接回车就进入 <strong>MySQL</strong> 数据库操作界面了:</p>
<p><img src="http://img.godjiyi.cn/wpmysqlenter.png" alt></p>
<p>敲入以下命令以创建数据库名为 <strong>wpblog</strong> 的数据库 ( 注意输入的时候标点符号都要是在英文状态！最后的分号不要忘掉 )</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> wpblog <span class="keyword">default</span> <span class="built_in">character</span> <span class="keyword">set</span> <span class="string">'utf8'</span> <span class="keyword">collate</span> <span class="string">'utf8_general_ci'</span>;</span><br></pre></td></tr></table></figure></div>
<p>敲入以上命令直接回车，就可以创建数据库了，返回 <em>Query OK</em> 就说明创建成功，也可以用以下命令查看已经创建好的数据库：<code>show databases;</code></p>
<p><img src="http://img.godjiyi.cn/wpmysqlsuccess.png" alt></p>
<h2 id="安装-WordPress"><a href="#安装-WordPress" class="headerlink" title="安装 WordPress"></a>安装 WordPress</h2><h3 id="解压压缩文件"><a href="#解压压缩文件" class="headerlink" title="解压压缩文件"></a>解压压缩文件</h3><p>解压前面下载的 <strong>WordPress</strong> 压缩文件到 <strong>WAMP</strong> 安装目录下的 <em>www</em> 目录， <strong>WAMP</strong> 下的目录：</p>
<p><img src="http://img.godjiyi.cn/wpwampwww.png" alt></p>
<p><strong>www</strong> 下的目录：</p>
<p><img src="http://img.godjiyi.cn/wampwwwwp.png" alt></p>
<p><strong>WordPress</strong> 下的目录:</p>
<p><img src="http://img.godjiyi.cn/wpwamppwpwww.png" alt="wordpress目录"></p>
<h3 id="安装-WordPress-1"><a href="#安装-WordPress-1" class="headerlink" title="安装 WordPress"></a>安装 WordPress</h3><p>浏览器访问 <a href="http://127.0.0.1/wordpress" target="_blank" rel="noopener">http://127.0.0.1/wordpress</a> 出现如下界面说明你离安装成功就差一步了：</p>
<p><img src="http://img.godjiyi.cn/wpwordpresshome.png" alt></p>
<p>点击现在开始，然后出现的页面是配置数据库的，按照如下填写 ( 由于默认 <strong>MySQL</strong> 数据库密码为空，这里大家可以空着不需要填试试，如果可以下一步则没有问题，如果不可以则需要 <a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;tn=sitehao123&amp;wd=%E4%BF%AE%E6%94%B9mysql%20root%E5%AF%86%E7%A0%81&amp;oq=wamp&amp;rsv_pq=d9090c190001bbbf&amp;rsv_t=48b2tY59ovj0zY8l%2FH9CnnbBZghinvZIlmqilrcq6sGnLZFCW82LcA6he0c88Be6uQ&amp;rsv_enter=1&amp;inputT=1650&amp;rsv_sug3=18&amp;rsv_sug1=17&amp;bs=wamp" target="_blank" rel="noopener">更改mysql的root密码</a> )：</p>
<p><img src="http://img.godjiyi.cn/wpsetupwp.png" alt></p>
<p>点击提交出现如下界面，点击进行安装:</p>
<p><img src="http://img.godjiyi.cn/wpsuwpsetup.png" alt></p>
<p>出现如下网站配置界面,按照要求填好后，点击安装：</p>
<p><img src="http://img.godjiyi.cn/wpwelcomewp.png" alt></p>
<p>最后就成功了，点击登录，进入后台界面，输入之前的 <em>admin</em>, 和密码 <em>123admin</em>，就进入了你网站的后台了。一个网站就搭建好了！</p>
<p><img src="http://img.godjiyi.cn/wpwpwplogin.png" alt></p>
<p>要想看看前台，点击左上角 <strong>WPBlog</strong> 就进入了前台了，当然你是以管理员登录的。你也可以用另外一个浏览器直接访问 <a href="http://127.0.0.1/wordpress" target="_blank" rel="noopener">http://127.0.0.1/wordpress</a> 进入前台。</p>
<p><img src="http://img.godjiyi.cn/wpwpfront.png" alt></p>
]]></content>
      <categories>
        <category>WordPress</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title>CDH-5.13 基于 Ubuntu 的布式部署</title>
    <url>/2017/11/09/CDH/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">企业大数据开源平台，从部署迈出第一步</p>

<p>最近应项目公司需求，我们需要为其构建一个大数据平台。<strong>开源的Hadoop生态应用</strong> 由于没有技术服务支持，公司不采用此种方案进行构建。因此我们选择采购具有技术支持的 <strong>第三方大数据平台</strong>，当然这些公司的平台也完全基于 <strong>Hadoop</strong>, 只不过他们有着一帮技术团队，可以为自己平台出现的问题提供技术服务。</p>
<p>第三方平台目前我们所接触了解的有四家：</p>
<ol>
<li><strong><a href="https://www.cloudera.com/" target="_blank" rel="noopener">Cloudera</a></strong></li>
<li><strong><a href="http://www.transwarp.cn/" target="_blank" rel="noopener">星环科技</a></strong></li>
<li><strong>华为</strong></li>
<li><strong>阿里</strong></li>
</ol>
<p>而由于 <strong>Cloudera</strong> 提供了开源免费版本的产品，因此这篇博客主要对 <strong>Cloudera</strong> 公司产品的部署过程进行记录。</p>
<h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><hr>
<ol>
<li><strong>Cloudera</strong>: Cloudera 公司目前是世界上最大的大数据平台提供商，其总部位于美国，且已经上市，2014进入中国市场，Hadoop 创始人 <strong>Doug Cutting</strong> 目前也就职于Cloudera，担任首席架构师，其内部有很多开源项目的 <strong>Committer</strong>，相比其他公司，其技术水平有着绝对的优势。</li>
<li><strong>CDH</strong>: Cloudera 公司目前主要的产品是 <strong>CDH</strong> ( <em>Cloudera’s Distribution including Apache Hadoop</em> ),是对 <strong>Hadoop 生态</strong>( hadoop + hive, hbase, flume, impala 等等)的一种封装融合，该产品是 <strong>完全免费下载和安装</strong> 的，其盈利方式是技术支持服务。</li>
<li><strong>Cloudera Manager</strong>: 由于大数据平台本身就是分布式，CDH 自然也不例外，为了便于用户快捷安装，Cloudera 公司提供了 <strong>Cloudera Manager</strong> 工具，可让用户在可视化的页面上组织自己的集群。</li>
<li><strong>部署方式</strong>：首先，Cloudera 公司提供了产品的<a href="https://www.cloudera.com/downloads/quickstart_vms/5-12.html" target="_blank" rel="noopener">尝鲜版本</a>，主要提供了<strong>Virtual Box、VMWare、KVM、Docker Image</strong> 等虚拟镜像，为了体验产品的用户可以尝试。此外，<strong>Cloudera</strong> 提供正式版本的<a href="https://www.cloudera.com/documentation/enterprise/latest/topics/installation.html" target="_blank" rel="noopener">安装说明</a>,下面就按照正式版本正式生产环境进行安装部署。</li>
</ol>
<a id="more"></a>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><hr>
<p>目前，Cloudera 最新版为 <strong><a href="https://www.cloudera.com/downloads/cdh/5-13-0.html" target="_blank" rel="noopener">CDH5.13</a></strong>，因此本教程基于 <strong>CDH5.13</strong> 安装</p>
<h3 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h3><p>搭建一个包含四个节点的集群，1 个 <strong>master</strong>, 3 个 <strong>slave</strong>, <strong>Host IP</strong> 对应关系如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">1. 192.168.1.100 master</span><br><span class="line">2. 192.168.1.101 slave1</span><br><span class="line">3. 192.168.1.102 slave2</span><br><span class="line">4. 192.168.1.103 slave3</span><br></pre></td></tr></table></figure></div>
<p>各个主机的物理配置如下，<strong>master</strong> 至少 16G 内存，<strong>slave</strong> [ 1-3 ]至少 4G 内存：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">master: CPU 16 核，32GB 内存，500G SSD</span><br><span class="line">slave[1-3]: CPU 8 核，16GB 内存，500G SSD</span><br></pre></td></tr></table></figure></div>
<h3 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h3><p>系统环境为<strong>Ubuntu16.04-Server</strong>版本，我们需要提前下好如下数据包：</p>
<ol>
<li>Cloudera Manager 安装包，约 <em>750MB</em>;</li>
<li>CDH 离线资源包，约 <em>1.9GB</em>;</li>
<li>CDH 离线包验证文件，约 <em>41B</em>;</li>
<li>CDH 离线包内的组件描述文件，约 <em>74KB</em>;</li>
<li>JDK8 安装包，约 <em>180MB</em>;</li>
</ol>
<p>其下载好的对应文件名如下：</p>
<ol>
<li><strong>cloudera-manager-xenial-cm5.13.0_amd64.tar.gz</strong></li>
<li><strong>CDH-5.13.0-1.cdh5.13.0.p0.29-xenial.parcel</strong></li>
<li><strong>CDH-5.13.0-1.cdh5.13.0.p0.29-xenial.parcel.sha</strong></li>
<li><strong>manifest.json</strong></li>
<li><strong>jdk-8u121-linux-x64.tar.gz</strong></li>
</ol>
<p>下载时需要确定自己系统的版本名称，<strong>Ubuntu 16.04</strong> 的对应的版本名称为 <strong>xenial</strong>，下面为对应文件的下载地址：</p>
<ol>
<li><em>Cloudera Manager</em>: <a href="http://archive.cloudera.com/cm5/cm/5/_index.html" target="_blank" rel="noopener">Cloudera 官网地址</a></li>
<li><em>CDH 资源包、CDH 校验文件、manifest.json</em>: <a href="http://archive.cloudera.com/cdh5/parcels/5.13.0/" target="_blank" rel="noopener">Cloudera 官网地址</a></li>
<li><em>JDK</em>: <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">Oracle 官网地址</a> 或者 <a href="https://gitee.com/jiyiren/linuxfile" target="_blank" rel="noopener">个人仓库地址</a></li>
</ol>
<h2 id="正式部署环境配置"><a href="#正式部署环境配置" class="headerlink" title="正式部署环境配置"></a>正式部署环境配置</h2><hr>
<p>正式的环境安装,以下操作均以 <strong>root</strong> 身份执行</p>
<h3 id="基本信息修改"><a href="#基本信息修改" class="headerlink" title="基本信息修改"></a>基本信息修改</h3><p>主要修改 <strong>Hostname</strong> 以及 <strong>Hosts</strong> 配置。修改 <strong>Hostname</strong> 是为了我们集群好查看和管理各个结点，而修改 <strong>Hosts</strong> 则是为了我们不用每次输入命令时都输入对方主机的 IP，我们直接输入 Hosts 中 IP 对应的名称即可。</p>
<p><strong>修改hostname</strong>: 所有节点，将各个主机名设置为对应的名称： <em>master, slave1, slave2, slave3</em>，<strong>master</strong> 主机修改为 <em>master</em>, <strong>slave[1-3]</strong> 则修改为 <em>slave1,slave2,slave3</em>, 修改命令如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line">vi /etc/hostname</span><br></pre></td></tr></table></figure></div>
<p><strong>Hosts配置</strong>：主要修改 <code>/etc/hosts</code> 文件，修改命令如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line">127.0.0.1     localhost</span><br><span class="line">192.168.1.100 master</span><br><span class="line">192.168.1.101 slave1</span><br><span class="line">192.168.1.102 slave2</span><br><span class="line">192.168.1.103 slave3</span><br></pre></td></tr></table></figure></div>
<h3 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h3><p>安装过程全部自动化，因此需要让 <strong>master</strong> 主机到所有其他 <strong>slave</strong> 主机可以免密登录。</p>
<p>由于是刚装的系统，<strong>Ubuntu</strong> 默认没有开启 <strong>root</strong> 远程登录的权限，所以需要先配置所有主机可 root 远程 ssh 登录，主要编辑配置文件 <code>/etc/ssh/sshd_config</code>,修改命令如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"><span class="comment"># PermitRootLogin prohibit-password # 原来的注释掉</span></span><br><span class="line">PermitRootLogin yes	<span class="comment"># 修改为这个新配置</span></span><br><span class="line">service ssh restart <span class="comment"># 重启 ssh 服务，使之生效</span></span><br></pre></td></tr></table></figure></div>
<p>其次，要配置 <strong>slave</strong> 信任 <strong>master</strong> 主机。首先在 <strong>master</strong> 节点上生成 <strong>ssh</strong> 公钥私钥，执行 <code>ssh-keygen -t rsa</code> 一直回车，会生成在用户目录下的 <strong>.ssh</strong> 文件夹里，里面存放了公钥和私钥。然后再将生成的公钥添加到 <strong>master 和 slave[1-3]</strong> 主机的信任授权列表里，命令如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master节点上</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub master</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub slave1</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub slave2</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub slave3</span><br></pre></td></tr></table></figure></div>
<p>最后，测试 <strong>master</strong> 免密登录各个节点是否成功，使用 <code>ssh [hostname]</code>，若回车后自动登录，则成功，操作命令如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master节点</span></span><br><span class="line">ssh master</span><br><span class="line">ssh slave1</span><br><span class="line">ssh slave2</span><br><span class="line">ssh slave3</span><br></pre></td></tr></table></figure></div>
<h3 id="配置JDK环境"><a href="#配置JDK环境" class="headerlink" title="配置JDK环境"></a>配置JDK环境</h3><p>首先，解压 JDK 压缩包</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line">tar -zxf jdk-8u121-linux-x64.tar.gz -C /opt <span class="comment"># 安装在 /opt 目录下</span></span><br><span class="line">mv /opt/jdk1.8.0_121 /opt/jdk8 <span class="comment"># 将目录重命名</span></span><br></pre></td></tr></table></figure></div>
<p>然后，配置 <code>JAVA_HOME</code> 和 <code>PATH</code> 环境变量</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line">vi /etc/profile <span class="comment"># 加入下面环境</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/jdk8</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib:<span class="variable">$JRE_HOME</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line">vi /etc/environment <span class="comment"># 添加如下，注意此处无需 export 关键字</span></span><br><span class="line">JAVA_HOME=/opt/jdk8</span><br><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line">vi ~/.bashrc <span class="comment"># 添加如下</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/jdk8</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib:<span class="variable">$JRE_HOME</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile			<span class="comment"># 让系统环境变量立即生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/environment		<span class="comment"># 让系统环境变量立即生效</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc				<span class="comment"># 让个人环境变量立即生效</span></span><br></pre></td></tr></table></figure></div>
<p>最后，测试 <strong>Java</strong> 是否安装成功，输入 <code>java -version</code> ，显示 <strong>Java</strong> 版本即可。</p>
<h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>这个在 <strong>master</strong> 节点安装即可</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master节点</span></span><br><span class="line">apt-get install mysql-server mysql-client</span><br></pre></td></tr></table></figure></div>
<h2 id="正式部署-–-安装-Manager"><a href="#正式部署-–-安装-Manager" class="headerlink" title="正式部署 – 安装 Manager"></a>正式部署 – 安装 Manager</h2><hr>
<p>安装之前需要将必要的软件上传到 <strong>master</strong> 节点上，文件包含：</p>
<ol>
<li><em>cloudera-manager-xenial-cm5.13.0_amd64.tar.gz</em>，</li>
<li><em>CDH-5.13.0-1.cdh5.13.0.p0.29-xenial.parcel</em>，</li>
<li><em>CDH-5.13.0-1.cdh5.13.0.p0.29-xenial.parcel.sha</em>，</li>
<li><em>manifest.json</em></li>
</ol>
<h3 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h3><p>解压 <em>cloudera-manager-xxx.tar.gz</em> 文件到 <code>/opt</code></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master节点</span></span><br><span class="line">tar -zxf cloudera-manager-xenial-cm5.13.0_amd64.tar.gz -C /opt</span><br></pre></td></tr></table></figure></div>
<h3 id="连接-MySQL"><a href="#连接-MySQL" class="headerlink" title="连接 MySQL"></a>连接 MySQL</h3><p>安装过程中 <strong>Cloudera Manager</strong> 需要用到 <strong>mysql</strong> 服务，所以这里需要先提供好 <strong>mysql</strong> 资源。</p>
<p>首先，安装 <em>mysql-connector-java</em> 包，并链接到 <strong>CM</strong> 库：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有节点安装库</span></span><br><span class="line">apt-get install libmysql-java</span><br><span class="line"><span class="comment"># 链接 mysql 连接库到 cm 库中给平台使用</span></span><br><span class="line">ln -s /usr/share/java/mysql-connector-java.jar /opt/cm-5.13.0/share/cmf/lib/mysql-connector-java.jar</span><br></pre></td></tr></table></figure></div>
<p>然后，再创建 <strong>cm5</strong> 的数据库：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master节点</span></span><br><span class="line"><span class="built_in">cd</span> /opt/cm-5.13.0/share/cmf/schema</span><br><span class="line">./scm_prepare_database.sh mysql -uroot -p123456 scm scm scm <span class="comment"># 创建数据库</span></span><br></pre></td></tr></table></figure></div>
<h3 id="配置Agent"><a href="#配置Agent" class="headerlink" title="配置Agent"></a>配置Agent</h3><p>这个 <strong>Agent</strong> 实际上就是安装代理，分布式的每台机器安装过程中都会产生这个进程，那这些 <strong>Agent</strong> 由谁来操控，通常是由 <strong>master</strong> 节点进行管理操作，所以要先将配置文件的管理这指向 <strong>master</strong>.</p>
<p>首先，修改配置文件的 <strong>server</strong>, 指向 <strong>master</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master节点</span></span><br><span class="line">vi /opt/cm-5.13.0/etc/cloudera-scm-agent/config.ini </span><br><span class="line"><span class="comment"># 将 server_host 修改为 master</span></span><br><span class="line">server_host=master</span><br></pre></td></tr></table></figure></div>
<p>然后，同步 <strong>Agent</strong> 到 <strong>slave[1-3]</strong> 节点</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master节点上</span></span><br><span class="line">scp -r /opt/cm-5.13.0/ root@slave1:/opt/</span><br><span class="line">scp -r /opt/cm-5.13.0/ root@slave2:/opt/</span><br><span class="line">scp -r /opt/cm-5.13.0/ root@slave3:/opt/</span><br></pre></td></tr></table></figure></div>
<p>最后，为所有节点创建 <strong>cloudera-scm</strong> 用户</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有节点</span></span><br><span class="line">useradd --system --home=/opt/cm-5.13.0/run/cloudera-scm-server/ --no-create-home --shell=/bin/<span class="literal">false</span> --comment <span class="string">"Cloudera SCM User"</span> cloudera-scm</span><br></pre></td></tr></table></figure></div>
<h3 id="配置-Parcels"><a href="#配置-Parcels" class="headerlink" title="配置 Parcels"></a>配置 Parcels</h3><p>要安装 <strong>CDH5</strong>, 我们需要配置 <strong>Parcels</strong>，这个是 <strong>Cloudera</strong> 给的安装包的镜像仓库地址，但是国内访问速度很慢，因此我们不使用在线安装，而是通过已经下载的 <strong>parcel</strong> 包，将其放置在下载镜像的目录，表示 <strong>parcel</strong> 包已经下载好了，这样就不会再联网下载了。</p>
<p>首先，在 <strong>master</strong> 节点，用下面命令创建文件夹</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master 节点</span></span><br><span class="line">mkdir -p /opt/cloudera/parcel-repo</span><br></pre></td></tr></table></figure></div>
<p>然后，传入三个文件：</p>
<ol>
<li><em>CDH-5.13.0-1.cdh5.13.0.p0.29-xenial.parcel</em>，</li>
<li><em>CDH-5.13.0-1.cdh5.13.0.p0.29-xenial.parcel.sha</em>，</li>
<li><em>manifest.json</em></li>
</ol>
<h3 id="启动-Server-和-Agent"><a href="#启动-Server-和-Agent" class="headerlink" title="启动 Server 和 Agent"></a>启动 Server 和 Agent</h3><p>在 <strong>master</strong> 节点启动 <strong>Server</strong> 进程</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master 节点</span></span><br><span class="line"><span class="built_in">cd</span> /opt/cm-5.13.0/etc/init.d</span><br><span class="line">./cloudera-scm-server start</span><br></pre></td></tr></table></figure></div>
<p>在所有节点启动 <strong>Agent</strong> 进程</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/cm-5.13.0/etc/init.d</span><br><span class="line">./cloudera-scm-agent start</span><br></pre></td></tr></table></figure></div>
<p>这里假如大家有错误，可以查看对应进程的日志：</p>
<blockquote>
<p>Server 进程 log 日志文件：</p>
<p><em>/opt/cm-5.13.0/log/cloudera-scm-server/cloudera-scm-server.log</em></p>
<p>Agent 进程 log 日志文件：</p>
<p><em>/opt/cm-5.13.0/log/cloudera-scm-agent/cloudera-scm-agent.log</em>,</p>
<p>如果没有 .log 文件，可以试试 .out 文件</p>
</blockquote>
<h2 id="正式部署–可视化集群配置"><a href="#正式部署–可视化集群配置" class="headerlink" title="正式部署–可视化集群配置"></a>正式部署–可视化集群配置</h2><hr>
<p>等待 Cloudera Manager <strong>Server</strong> 和 <strong>Agent</strong> 启动完毕后，就可以进行 <strong>CDH5</strong> 的可视化界面安装了，在浏览器打开 <a href="http://master:7180" target="_blank" rel="noopener">http://master:7180</a>, 注意，如果这是在 <strong>master, slave[1-3]</strong> 主机上时可以直接在浏览器里输入这个 url, 但如果 <strong>不在 master 和 slave[1-3]</strong> 节点上访问此 url，则需要修改主机的 <strong>hosts</strong> 文件，修改方法见 <em>正式部署环境配置</em> 中的 <strong>hosts</strong> 配置。</p>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>默认用户名和密码都是：<em>admin</em></p>
<p><img src="http://img.godjiyi.cn/cloudera01.jpg" alt></p>
<h3 id="同意条款"><a href="#同意条款" class="headerlink" title="同意条款"></a>同意条款</h3><p><img src="http://img.godjiyi.cn/cloudera02.jpg" alt></p>
<h3 id="选择版本"><a href="#选择版本" class="headerlink" title="选择版本"></a>选择版本</h3><p>选择中间的试用版本，肯定要体验最全的功能</p>
<p><img src="http://img.godjiyi.cn/cloudera03.jpg" alt> </p>
<h3 id="选择集群机器"><a href="#选择集群机器" class="headerlink" title="选择集群机器"></a>选择集群机器</h3><p>这里只显示启动了Agent进程的主机</p>
<p><img src="http://img.godjiyi.cn/cloudera05.jpg" alt></p>
<h3 id="选择集群安装方式"><a href="#选择集群安装方式" class="headerlink" title="选择集群安装方式"></a>选择集群安装方式</h3><p>这里选择 <strong>Parcel</strong>, 我们之前已经把离线包下载好并放在了 <strong>master</strong> 的仓库目录下，因此这里直接显示了我们已经下载的 <strong>CDH5</strong></p>
<p><img src="http://img.godjiyi.cn/cloudera06.jpg" alt></p>
<h3 id="分发-Parcel-包到各个结点"><a href="#分发-Parcel-包到各个结点" class="headerlink" title="分发 Parcel 包到各个结点"></a>分发 Parcel 包到各个结点</h3><p>这里自动由 <strong>master</strong> 将 <strong>CDH</strong> 包分发到 <strong>slave[1-3]</strong></p>
<p><img src="http://img.godjiyi.cn/cloudera07.jpg" alt></p>
<h3 id="检测安装环境"><a href="#检测安装环境" class="headerlink" title="检测安装环境"></a>检测安装环境</h3><p>这里出现下面警告，通过在所有主机上执行 <code>echo 10 &gt; /proc/sys/vm/swappiness</code>, 然后再重新检测下环境即可</p>
<p><img src="http://img.godjiyi.cn/cloudera08.jpg" alt></p>
<p><img src="http://img.godjiyi.cn/cloudera09.jpg" alt></p>
<h3 id="选择安装服务"><a href="#选择安装服务" class="headerlink" title="选择安装服务"></a>选择安装服务</h3><p>这里我就选择核心服务，因为后面管理界面可以任意 <em>增加、删除</em> 各个服务。</p>
<p><img src="http://img.godjiyi.cn/cloudera10.jpg" alt></p>
<h3 id="角色配置"><a href="#角色配置" class="headerlink" title="角色配置"></a>角色配置</h3><p>这里默认即可</p>
<p><img src="http://img.godjiyi.cn/cloudera11.jpg" alt></p>
<h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><p>这里是最重要也是最容易出错的地方，配置数据库前，需要先创建数据库,我们只需要在 <strong>master</strong> 主机上创建，这里主要需要创建 <em>四个数据库 ( hive, rman, ozzie, hue )</em> 和 <em>四个用户名 ( hive, rman, ozzie, hue )</em>.</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master主机</span></span><br><span class="line">mysql -u root -p <span class="comment"># 连接mysql数据库</span></span><br><span class="line"><span class="comment"># 创建四个数据</span></span><br><span class="line">create database hive DEFAULT CHARSET utf8; </span><br><span class="line">create database rman DEFAULT CHARSET utf8;</span><br><span class="line">create database oozie DEFAULT CHARSET utf8;</span><br><span class="line">create database hue DEFAULT CHARSET utf8;</span><br><span class="line"><span class="comment"># 创建四个用户名</span></span><br><span class="line">grant all on hive.* TO <span class="string">'hive'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'123456'</span>;</span><br><span class="line">grant all on rman.* TO <span class="string">'rman'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'123456'</span>;</span><br><span class="line">grant all on oozie.* TO <span class="string">'oozie'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'123456'</span>;</span><br><span class="line">grant all on hue.* TO <span class="string">'hue'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure></div>
<p>此外，这里还常常出现 <strong>Hue</strong> 测试连接数据库时失败，这种情况是因为 <em>依赖包</em> 没有安装，这里给出我测试成功需要的依赖包，更详细的依赖包查看 <a href="https://www.cloudera.com/documentation/enterprise/5-9-x/topics/cm_ig_install_path_c.html" target="_blank" rel="noopener">官网的 Install Package Dependencies 说明</a>：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仅master主机</span></span><br><span class="line">apt-get install python-mysqldb</span><br><span class="line">apt-get install libxslt1.1</span><br><span class="line">apt-get install apache2</span><br><span class="line">apt-get install libssl-dev</span><br></pre></td></tr></table></figure></div>
<p>然后，点击 <em>测试连接</em>，成功后进行下一步</p>
<p><img src="http://img.godjiyi.cn/cloudera13.jpg" alt></p>
<h3 id="进行安装"><a href="#进行安装" class="headerlink" title="进行安装"></a>进行安装</h3><p><img src="http://img.godjiyi.cn/cloudera14.jpg" alt></p>
<h3 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功"></a>安装成功</h3><p><img src="http://img.godjiyi.cn/cloudera15.jpg" alt></p>
<h3 id="集群界面"><a href="#集群界面" class="headerlink" title="集群界面"></a>集群界面</h3><p><img src="http://img.godjiyi.cn/cloudera16.jpg" alt></p>
<h3 id="添加服务"><a href="#添加服务" class="headerlink" title="添加服务"></a>添加服务</h3><p>点击 <em>集群右侧倒三角，选择添加服务</em></p>
<p><img src="http://img.godjiyi.cn/cloudera17.jpg" alt></p>
<p>出现服务选择界面，自己根据需求选择 <em>Hadoop 生态中的应用</em>：</p>
<p><img src="http://img.godjiyi.cn/cloudera18.jpg" alt></p>
<h3 id="添加主机到集群"><a href="#添加主机到集群" class="headerlink" title="添加主机到集群"></a>添加主机到集群</h3><p>点击菜单栏上的 <em>主机–所有主机</em></p>
<p><img src="http://img.godjiyi.cn/cloudera19.jpg" alt></p>
<p>会看到当前集群的所有主机列表，点击右上角的 <em>向集群添加新主机</em></p>
<p><img src="http://img.godjiyi.cn/cloudera20.jpg" alt></p>
<p>进入添加主机流程，大家一步一步下一步安装即可</p>
<p><img src="http://img.godjiyi.cn/cloudera21.jpg" alt></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cloudera.com/documentation/enterprise/5-9-x/topics/cm_ig_install_path_c.html" target="_blank" rel="noopener">Installation Path C - Manual Installation Using Cloudera Manager Tarballs</a></li>
<li><a href="https://christchen.me/archives/217.html" target="_blank" rel="noopener">CDH-5.12.0 分布式集群的离线部署</a></li>
</ul>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>大数据</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 学习笔记</title>
    <url>/2015/10/25/Gitstudy/</url>
    <content><![CDATA[<h2 id="一、Git简介"><a href="#一、Git简介" class="headerlink" title="一、Git简介"></a>一、Git简介</h2><p><img src="http://img.godjiyi.cn/gitstudy0.jpg" alt="git"></p>
<p><strong>Git</strong> 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何大小项目的版本管理。与 <strong>CVS</strong> 相比，它不是把版本库放在集中的存储服务器，而是每个开发者电脑上都是一个版本库，无须联网就可以管理代码版本，并且分支管理更高效，切换更快捷方便，已经成为现在开发者主流版本控制工具。</p>
<h2 id="二、前言"><a href="#二、前言" class="headerlink" title="二、前言"></a>二、前言</h2><p><strong>Git</strong> 仓库初始的创建通常有两种方式，<strong>一种是自己本地创建项目</strong>，再链接到远程仓库。<strong>另一种是先创建远程仓库</strong>，再将远程仓库克隆 ( <code>git clone</code> ) 到本地。接下来我就分别从这两个方式讲解。</p>
<a id="more"></a>
<h2 id="三、本地仓库创建"><a href="#三、本地仓库创建" class="headerlink" title="三、本地仓库创建"></a>三、本地仓库创建</h2><hr>
<p><strong>初始化仓库:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">mkdir gitstudy</span><br><span class="line"><span class="built_in">cd</span> gitstudy</span><br><span class="line">git init</span><br></pre></td></tr></table></figure></div>
<p><strong>加入暂存区:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git add hellogit.txt</span><br></pre></td></tr></table></figure></div>
<p>或者</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git add -A 或者 git add . // 是添加全部文件</span><br></pre></td></tr></table></figure></div>
<p><strong>将文件加入历史版本:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"add hellogit file"</span> // -m是该版本的说明语句</span><br></pre></td></tr></table></figure></div>
<p><strong>与远程仓库链接:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://gitcafe.com/jiyiren/gitstudy.git</span><br></pre></td></tr></table></figure></div>
<p><strong>提交到远程仓库:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git push -u origin master // -u 第一次提交让git记住本地仓库与远程仓库</span><br><span class="line">//的连接,以后可以不要</span><br></pre></td></tr></table></figure></div>
<h2 id="四、远程仓库先创建"><a href="#四、远程仓库先创建" class="headerlink" title="四、远程仓库先创建"></a>四、远程仓库先创建</h2><hr>
<p>创建远程仓库，可以到 <em>github</em> 或者 <em>gitcafe</em> 或者 <em>gitosc</em> 等</p>
<p>将远程仓库克隆 ( clone ) 下来,本地就会有对应的文件夹仓库</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitcafe.com/jiyiren/gitstudy.git</span><br></pre></td></tr></table></figure></div>
<p>修改后加入暂存区，提交到历史版本，再推送到远程</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">"modify hellogit file"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></div>
<h2 id="五、版本管理"><a href="#五、版本管理" class="headerlink" title="五、版本管理"></a>五、版本管理</h2><hr>
<h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1. 说明"></a>1. 说明</h3><p>我们有两个仓库，一个本地仓库，一个远程仓库，两个仓库互相关联。本地仓库为了开发代码，远程仓库为了记录版本和保存正确的代码。<strong>Git</strong> 的主要功能都应该在我们本地仓库里使用，那 Git 具体怎么管理代码的呢？这要先从本地仓库的划分说起。本地仓库也就是开发的文件夹里，分为<strong>工作区</strong>，<strong>暂存区</strong>和<strong>历史版本区</strong>，工作区就是我们实际操作的区域，暂存区就是git add后文件进入的暂存状态，历史版本区是 <code>git commit</code> 后文件记录在历史版本里的区域。我们的 <code>git push</code> 就是向远处推送 <strong>历史版本区</strong> 的内容，<strong>工作区</strong> 和 <strong>暂存区</strong> 为我们的版本回退提供方便。</p>
<h3 id="2-重要命令解释"><a href="#2-重要命令解释" class="headerlink" title="2. 重要命令解释"></a>2. 重要命令解释</h3><p>主要说明 <strong>Git</strong> 中使用频率很高的几个命令。</p>
<h4 id="1-git-status"><a href="#1-git-status" class="headerlink" title="(1). git status"></a>(1). git status</h4><p><code>$ git status</code> 查看当前的工作区的状态，通常有三种状态：</p>
<ul>
<li><strong>一种是工作区干净：</strong> <em>nothing to commit, working directory clean</em>, 无需更新操作版本；</li>
<li><strong>一种是使用了git add之后</strong>，显示<em>Changes not staged for commit(提示有已添加但是未提交的修改)</em> </li>
<li><strong>一种是新添加文件后</strong>，显示 <em>Untracked files(提示有未跟踪的文件)</em></li>
</ul>
<h4 id="2-git-diff"><a href="#2-git-diff" class="headerlink" title="(2). git diff"></a>(2). git diff</h4><p><code>$ git diff</code>命令描述图为:</p>
<p><img src="http://img.godjiyi.cn/gitstudygitstudy-diff.png" alt="diff"></p>
<ul>
<li><p>这个命令的理解点就是在参照物，也就是对比双方是谁。</p>
</li>
<li><p><code>$ git diff</code> 图片中 <strong>1</strong> 标号内容，该句将 <strong>工作区的修改与暂存区对比</strong>。例如：<code>$ git diff mtest.txt</code></p>
</li>
<li><code>$ git diff --cached</code> 图示 <strong>2</strong> 标号，这句则是将<br><strong>暂存区与本地历史版本区中的最新版本</strong> 对比。例如：<code>$ git diff --cached mtest.txt</code></li>
<li><code>$ git diff HEAD</code> 图示 <strong>3</strong> 标号，这句是将 <strong>本地工作区(包含了暂存区内容)与本地历史版本区里的最新版本</strong> 对比。如：<code>$ git diff HEAD -- mtest.txt</code>, 此处文件名要用 <code>--</code> 分隔，前后都有空格。</li>
<li>图示 4 和 图示 5 分别为两个历史版本 id 对比和本地与分支的对比。这个用的都比较少。</li>
</ul>
<h4 id="3-git-log"><a href="#3-git-log" class="headerlink" title="(3). git log"></a>(3). git log</h4><p><code>git log</code> 主要显示提交版本历史记录</p>
<ul>
<li><code>$ git log</code> 或者 <code>$ git log --pretty=oneline</code> 可以显示我们提交版本的记录，按照从近到远的版本显示。</li>
<li><p><code>$ git log --graph --pretty=oneline</code> 可以显示分支状态：<br><img src="http://img.godjiyi.cn/gitstudygitstudy-gitlog.png" alt="gitlog"></p>
</li>
<li><p><code>$ git log --graph --pretty=oneline --abbrev-commit</code>这个是简短形式：<br><img src="http://img.godjiyi.cn/gitstudygitstudy-gitshortlog.png" alt="shortlog"></p>
</li>
<li><p>主要是 <code>git log</code> 结合多种参数显示各种结果具体参数请看 <a href="http://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank" rel="noopener">git log参数</a></p>
</li>
</ul>
<h4 id="4-git-reset"><a href="#4-git-reset" class="headerlink" title="(4). git reset"></a>(4). git reset</h4><p><code>git reset --hard &lt;版本&gt;</code> 回退版本，有两种方式，<strong>一种是相对回退</strong>，我们都知道 <strong>HEAD</strong> 默认指向当前分支的最新历史版本，而 <strong>Git</strong> 给了我们一种以 <strong>HEAD</strong> 方式的相对语句就是 <code>HEAD^</code> 这个代表当前版本的上一个版本，<code>HEAD^^</code> 代表当前版本的上上一个版本，可以一直加 <code>^</code> 向上的箭头来回退版本。当然如果回退个数很多比如100个，那个写100个 <code>^</code> 也麻烦，所以有缩写就是<code>HEAD~100</code>。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^ //回退到上一个版本</span><br><span class="line">git reset --hard HEAD~100 //回退到上100个版本</span><br></pre></td></tr></table></figure></div>
<p><strong>另一种方式是绝对回退</strong>，上面的命令 <code>$ git log --pretty=oneline</code> 可以显示历史提交版本的 <em>commitid</em>, 当然很长，但是记录前面 7 个数字就可以了标识一个版本了。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">git reset --hard 3628164 // 回退到3628164..的版本</span><br></pre></td></tr></table></figure></div>
<h4 id="5-git-reflog"><a href="#5-git-reflog" class="headerlink" title="(5). git reflog"></a>(5). git reflog</h4><p><code>git reflog</code> 这个是命令历史记录。当我们回退到上一个或者几个版本时，我们用 <code>$ git log</code> 命令查看的只能显示是当前版本以及当前版本之前的，那比当前版本还新的版本我们就看不到了，那怎么办？<code>git reflog</code> 就可以显示我们所有操作的命令历史，注意与 <code>git log</code> 的区别，<code>git log</code> 是版本历史记录，<code>git reflog</code> 是命令历史记录。从这个里面就可以找到最新版本的 <code>commitid</code>，就可以回退到任意一个版本。</p>
<h4 id="6-git-checkout-reset"><a href="#6-git-checkout-reset" class="headerlink" title="(6). git checkout/reset"></a>(6). git checkout/reset</h4><p>这两个命令也有撤销修改的功能，其实回退版本也相当于撤销修改了，但是有特别的几个命令比较常用，这里讲下。</p>
<ul>
<li><code>git checkout -- filename</code> 这个是将工作区下的文件恢复到暂存区下的状态，<strong>取消本地未暂存的修改，暂存区不请空</strong>，也就是如果你后来的修改将被撤销。如：<code>$ git checkout -- mtext.txt</code>。</li>
<li><code>git reset HEAD filename</code> 这个是将 <strong>暂存区的修改恢复到本地工作区，暂存区将清空</strong>。如：<code>$ git reset HEAD mtext.txt</code>。</li>
</ul>
<h2 id="六、分支与合并"><a href="#六、分支与合并" class="headerlink" title="六、分支与合并"></a>六、分支与合并</h2><hr>
<p>下面列出最常用的分支操作，以及命令解释。</p>
<p><strong>查看分支:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git branch //查看本地分支</span><br><span class="line">git branch -r //查看远程分支</span><br><span class="line">git branch -a //查看所有分支(包括本地和远程)</span><br></pre></td></tr></table></figure></div>
<p><strong>创建分支:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git branch develop //创建develop分支</span><br></pre></td></tr></table></figure></div>
<p><strong>切换分支:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git checkout develop //切换到develop分支</span><br></pre></td></tr></table></figure></div>
<p><strong>创建并切换分支:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git checkout -b mdeve //创建并切换到mdeve分支</span><br></pre></td></tr></table></figure></div>
<p><strong>删除分支:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git branch -d mdeve //删除mdeve分支，强行删除用-D</span><br></pre></td></tr></table></figure></div>
<p><strong>合并分支默认 ff 模式:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git merge mdeve //合并mdeve分支到当前分支</span><br></pre></td></tr></table></figure></div>
<p>默认合并方式是 <em>Fast-forward</em>，也就是将要合并的分支直接向当前分支提交。没有提交信息</p>
<p><strong>解决冲突:</strong></p>
<p>很多时候用Fast-forward方式直接提交是不成功的，因为有冲突存在，所以我们要手动解决冲突</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git merge feature1 //合并feature1分支</span><br></pre></td></tr></table></figure></div>
<p><img src="http://img.godjiyi.cn/gitstudygitstudy-merge.png" alt="merge"></p>
<p>不成功的结果如上图，Git用 <code>&lt;&lt;&lt;&lt;&lt;</code> 这个箭头表示 <em>HEAD</em> 当前分支，<code>====</code> 这个为分隔线，<code>&gt;&gt;&gt;&gt;&gt;&gt;</code> 这个为 <em>feature1</em> 分支里的内容，只要手动删除这三处并自己选择内容作为最终结果。</p>
<p><strong>合并分支禁ff模式合并:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git merge --no-ff -m <span class="string">"merge no ff"</span> dev //采用no ff模式合并并添加了信息提示</span><br></pre></td></tr></table></figure></div>
<p><em>Fast-forward</em> 模式合并直接向当前分支提交，这种模式下如果删除掉分支，就会丢掉分支信息</p>
<p>如果用 <strong>no ff</strong> 这种模式合并, <strong>Git</strong> 就会在 <em>merge</em> 时生成一个新的 <em>commit</em>, 这样就可以从分支历史里查看出分支信息了。</p>
<p><strong>暂存临时现场:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git stash //把工作现场存储起来，使得工作区干净如初</span><br></pre></td></tr></table></figure></div>
<p>主要用于在自己工作到一半，没法提交，然后又有新的 <strong>bug</strong> 要修复，就用这个命令保存现场，然后切换到 <strong>bug</strong> 分支，修复。</p>
<p><strong>恢复临时现场:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ git stash list //查看临时工作区保存记录</span><br><span class="line">  stash@&#123;0&#125;: WIP on dev: 6224937 add merge//这是临时工作区记录列表</span><br><span class="line">$ git stash apply stash@&#123;0&#125;  //恢复刚刚的临时工作区</span><br><span class="line">$ git stash drop stash@&#123;0&#125;  //删除刚刚的临时保存记录</span><br></pre></td></tr></table></figure></div>
<p>上面的命令已经可以恢复并删除保存记录了，但是语句比较多，还有一种方法直接恢复到最近一次的临时现场：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git stash pop //既恢复工作区又删掉了保存记录</span><br></pre></td></tr></table></figure></div>
<h2 id="七、多人协作（重点）"><a href="#七、多人协作（重点）" class="headerlink" title="七、多人协作（重点）"></a>七、多人协作（重点）</h2><hr>
<h3 id="1-说明-1"><a href="#1-说明-1" class="headerlink" title="1. 说明"></a>1. 说明</h3><p>这是 <strong>Git</strong> 工具最常见的使用环境，也是开发者正是开发中的工作环境，一个团队离不开多人协作。</p>
<h3 id="2-讲解"><a href="#2-讲解" class="headerlink" title="2. 讲解"></a>2. 讲解</h3><p><strong>查看远程信息:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ git remote    //查看远程库的信息</span><br><span class="line">  origin</span><br><span class="line">$ git remote -v            //查看更详细信息</span><br><span class="line">  origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">  origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure></div>
<p><strong>推送分支:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git push origin master //推送主分支</span><br><span class="line">git push origin mdev //推送mdev分支</span><br></pre></td></tr></table></figure></div>
<p><strong>抓取分支:</strong>  </p>
<p>这里模拟多人协作，假如你自己和一个 <strong>A</strong> 同学协作：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">A同学：</span><br><span class="line">$ git <span class="built_in">clone</span> url.. //先从仓库克隆</span><br><span class="line">$ git branch  //查看分支，默认只有master分支，但是远程是有dev分支的</span><br><span class="line">$ git checkout -b dev origin/dev //所以要本地创建dev并与远程相连接</span><br><span class="line">$ git commit -m <span class="string">"add something by A"</span> //A同学修改了东西并添加入版本库</span><br><span class="line">$ git push origin dev //上传到远程仓库		</span><br><span class="line">我自己：</span><br><span class="line">$ git commit -m <span class="string">"add something by me"</span> //此时我自己也修改了一些东西，</span><br><span class="line">//并与A同学该的相同地方</span><br><span class="line">$ git push origin dev //此时推送将推送失败，提示先git pull</span><br><span class="line">$ git pull //于是你也就git pull,提示失败，本地dev未与远程连接</span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream dev origin/dev //再按照提示将本地分支与远程连接</span><br><span class="line">$ git pull //再次git pull,成功，但是出现冲突，解决冲突</span><br><span class="line">$ git commit -m <span class="string">"merge&amp;add something"</span> //提交冲突，至此就完成了多人协作</span><br></pre></td></tr></table></figure></div>
<p><strong>分支链接 ( 重要 )：</strong></p>
<p><code>$ git checkout -b dev origin/dev</code> 这个是新建本地分支为 <em>dev</em> 并与远程的 <em>dev</em> 相关联</p>
<p><code>$ git branch --set-upstream dev origin/dev</code> 这个是我之前新建了分支，但是没有关联到远程分支，这里是将已有的分支关联到远程分支。</p>
<h2 id="八、标签"><a href="#八、标签" class="headerlink" title="八、标签"></a>八、标签</h2><hr>
<p><strong>打标签两种方式：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">$ git branch //查看分支</span><br><span class="line">  *dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master  //切换到要打标签的分支</span><br><span class="line">  Switched to branch &apos;master&apos;</span><br><span class="line">$ git tag v1.0 //用git tag name来打标签，默认打在最新提交的commit上</span><br><span class="line">$ git tag //查看所有标签</span><br></pre></td></tr></table></figure></div>
<p>还可以如下打标签，按照 <em>commit id</em> 来打标签，如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline --abbrev-commit//查看commit历史，找到要打标签的id号</span><br><span class="line">git tag v1.0 622493</span><br><span class="line">git tag //查看标签列表(按照标签名列出)</span><br><span class="line">git show v1.0 //查看v1.0标签的详细信息</span><br></pre></td></tr></table></figure></div>
<p><strong>删除分支和推送分支：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git tag -d v0.9 //删除标签0.9，创建的分支默认都在本地，不会自动推送到远程。</span><br><span class="line">git push origin v1.0 //将标签1.0推送到远程</span><br><span class="line">git push origin --tags //一次性将全部未推送的标签推送到远程</span><br><span class="line">//要删除远程标签，有点麻烦的</span><br><span class="line">git tag -d v0.9 //先从本地删除标签</span><br><span class="line">git push origin :refs/tags/v0.9 //然后再从远程删除标签</span><br></pre></td></tr></table></figure></div>
<h2 id="九、图形化界面"><a href="#九、图形化界面" class="headerlink" title="九、图形化界面"></a>九、图形化界面</h2><hr>
<h3 id="1-Git-自带图形化界面的"><a href="#1-Git-自带图形化界面的" class="headerlink" title="1. Git 自带图形化界面的"></a>1. Git 自带图形化界面的</h3><p>(1). 在 <em>git bash</em> 里输入 <code>git gui</code> 就会显示图形化界面。</p>
<p><img src="http://img.godjiyi.cn/gitstudygitstudy-gitgui.png" alt="gui"></p>
<p>(2). 在git bash里输入<code>gitk</code> 就会显示图形化的log界面</p>
<p><img src="http://img.godjiyi.cn/gitstudygitstudy-gitloggui.png" alt="guilog"></p>
<h3 id="2-SourceTree"><a href="#2-SourceTree" class="headerlink" title="2. SourceTree"></a>2. SourceTree</h3><p><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">SourceTree</a> </p>
<p>这个自己看吧，这个工具在生产环境中应该用的最多的，但是就是下载后注册需要翻墙的，这里不多介绍，<strong>Mac</strong> 版本的比较容易使用。</p>
<h2 id="十、Git-教程链接"><a href="#十、Git-教程链接" class="headerlink" title="十、Git 教程链接"></a>十、Git 教程链接</h2><ol>
<li><a href="http://git-scm.com/docs" target="_blank" rel="noopener">官网英文教程</a></li>
<li><a href="http://git-scm.com/book/zh/v1" target="_blank" rel="noopener">官网中文教程</a></li>
<li><a href="http://www.bootcss.com/p/git-guide/" target="_blank" rel="noopener">快速简易指南</a></li>
<li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener">图解多语言(含中文)教程</a> – 极力推荐</li>
<li><a href="http://www.yidianzixun.com/n/06h47t53?s=9" target="_blank" rel="noopener">实战教程</a> – 比较长，但是很实用</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 简单配置与基本操作</title>
    <url>/2016/05/22/Mysql-simple-setting/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">MySQL 入坑指南</p>

<p>本篇文章主要记录自己在使用配置 <strong>MySQL</strong> 过程中的注意点和配置流程，因为自己常常帮别人配置 <strong>MySQL</strong> 环境，但是每次都需要重新查看下资料，我就自己记录下，为快速配置 <strong>MySQL</strong> 环境而节省时间。</p>
<h2 id="MySQL-的安装"><a href="#MySQL-的安装" class="headerlink" title="MySQL 的安装"></a>MySQL 的安装</h2><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p>个人建议选择zip包安装，这样Windows和Linux下配置过程很相似</p>
<p>5.7 或者最新版官网地址：<a href="http://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">http://dev.mysql.com/downloads/mysql/</a></p>
<p>5.6 版本百度云地址：<a href="http://pan.baidu.com/s/1b6hLCE" target="_blank" rel="noopener">http://pan.baidu.com/s/1b6hLCE</a></p>
<p>这里还要讲下有的下载的 <em>5.7 版本</em> 里面没有 <strong>data 目录</strong>，这个常常会导致安装失败，建议下载压缩包后解压看看里面有没有 <strong>data 目录</strong>，选择有 <strong>data 目录</strong> 的压缩包安装较好，如果没有可以从以前或者别人的目录里拷贝，上面百度云里的 <em>5.6 版本</em> 是有的。</p>
<a id="more"></a>
<h3 id="解压到安装目录"><a href="#解压到安装目录" class="headerlink" title="解压到安装目录"></a>解压到安装目录</h3><p>尽量避开系统盘，这样便于数据的恢复</p>
<h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>将 <strong>my-default.ini</strong> 复制为 <strong>my.ini</strong> 并修改如下两个配置:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">basedir = 解压后目录 ( bin 文件上一级目录 )</span><br><span class="line">datadir = 解压后目录下的 data 目录</span><br></pre></td></tr></table></figure></div>
<p>比如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">basedir = D:\DevePrograms\mysql-5.6.21-winx64</span><br><span class="line">datadir = D:\DevePrograms\mysql-5.6.21-winx64\data</span><br></pre></td></tr></table></figure></div>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>管理员身份</strong> 打开命令 <em>cmd</em> 窗口，<code>cd</code> 到 <em>bin</em> 文件夹下。（ <em>Windows7</em> 的话通常点击开始 – 附件 – 命令提示符右击 – 以管理员方式打开 ）</p>
<p>输入 <code>mysqld -install</code> ( 注意是 <em>mysqld</em> 而不是 <em>mysql</em>, 有个 d )，提示安装成功即可。</p>
<p>如果提示不成功，则 <code>mysqld -remove</code>, 再执行 <code>mysqld -install</code>.</p>
<h3 id="开启-关闭-mysql-服务"><a href="#开启-关闭-mysql-服务" class="headerlink" title="开启 / 关闭 mysql 服务"></a>开启 / 关闭 mysql 服务</h3><p><strong>MySQL</strong> 装成功实际上就是 <strong>MySQL</strong> 服务装成功，服务的开启与否决定能不能使用 <strong>MySQL</strong> 数据库。</p>
<p>开启服务：<code>net start mysql</code></p>
<p>关闭服务：<code>net stop mysql</code></p>
<p>如果大家按照第四部安装的，通常默认服务是开机自启动的，默认可以正常使用，如果用了什么安全管家加速电脑开机关闭了 <strong>MySQL</strong> 的服务，则就需要在使用 <strong>MySQL</strong> 服务前先开启下 <strong>MySQL</strong> 服务。</p>
<p>大家可以 [ 右击我的电脑 – 管理 – 服务和应用程序展开 – 服务 ] 里面就可以找到 <strong>MySQL</strong> 服务，如果大家想禁止开机自启或者想开机自启都可以在这里设置。</p>
<p><img src="http://img.godjiyi.cn/1.png" alt="mysql服务"></p>
<h3 id="登录使用-MySQL"><a href="#登录使用-MySQL" class="headerlink" title="登录使用 MySQL"></a>登录使用 MySQL</h3><p>开启服务后，用 <code>mysql -u root -p</code> 回车后会让输入密码，默认密码为空，直接再回车就进入了 <strong>MySQL</strong> 数据库操作里了。</p>
<h2 id="MySQL-编码设置"><a href="#MySQL-编码设置" class="headerlink" title="MySQL 编码设置"></a>MySQL 编码设置</h2><h3 id="配置文件设置"><a href="#配置文件设置" class="headerlink" title="配置文件设置"></a>配置文件设置</h3><p>在 <strong>my.ini</strong> 文件里写入以下配置</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br></pre></td></tr></table></figure></div>
<p>如果没有 <strong>my.ini</strong> 配置文件，则通过复制 <strong>my-default.ini</strong> 文件为 <strong>my.ini</strong>文 件再进行设置。</p>
<p>重启 <strong>MySQL</strong> 服务让设置生效：先关闭服务 <code>net stop mysql</code>, 再启动服务 <code>net start mysql</code>.</p>
<h3 id="创建数据库和表规范"><a href="#创建数据库和表规范" class="headerlink" title="创建数据库和表规范"></a>创建数据库和表规范</h3><p>创建数据库时带上编码集：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db_test <span class="built_in">character</span> <span class="keyword">set</span> <span class="string">'utf8'</span> <span class="keyword">collate</span> <span class="string">'utf8_general_ci'</span>;</span><br></pre></td></tr></table></figure></div>
<p>创建表带上编码集合和引擎：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_muser(<span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment primary <span class="keyword">key</span>,username <span class="built_in">char</span>(<span class="number">10</span>)) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure></div>
<p>查看已经创建的数据库编码格式：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure></div>
<p>查看已经创建的表编码格式：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> tb_muser;</span><br></pre></td></tr></table></figure></div>
<h3 id="编码排错语句"><a href="#编码排错语句" class="headerlink" title="编码排错语句"></a>编码排错语句</h3><p>显示所有设置项目的编码:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'character_%'</span>;</span><br><span class="line">// 通常有如下名称编码设置</span><br><span class="line">character_set_client</span><br><span class="line">character_set_connection</span><br><span class="line">character_set_server</span><br><span class="line">character_set_database</span><br><span class="line">character_set_results</span><br><span class="line">character_set_server</span><br><span class="line">character_set_system</span><br></pre></td></tr></table></figure></div>
<p>通过形似这样 <code>set character_set_NAME=utf8/gbk</code> 的命令设置上面查看到的非标准编码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> character_set_server=utf8;</span><br></pre></td></tr></table></figure></div>
<h2 id="MySQL-常用命令"><a href="#MySQL-常用命令" class="headerlink" title="MySQL 常用命令"></a>MySQL 常用命令</h2><h3 id="连接-MySQL"><a href="#连接-MySQL" class="headerlink" title="连接 MySQL"></a>连接 MySQL</h3><p>连接命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">mysql -h 服务器ip -u 用户名 -p	// 连接通用命令</span><br><span class="line">password:输入密码</span><br></pre></td></tr></table></figure></div>
<p>例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">mysql –h localhost/127.0.0.1 –u root –p // 连接本地计算机的 MySQL</span><br><span class="line">// 链接本地计算机 -h 也可以不写，如：mysql –u root –p</span><br></pre></td></tr></table></figure></div>
<h3 id="root-密码重置"><a href="#root-密码重置" class="headerlink" title="root 密码重置"></a>root 密码重置</h3><p>由于初始密码为空，如果想修改密码，首先要退出数据库，然后</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root passwrod 1234</span><br></pre></td></tr></table></figure></div>
<p>假设已经设置过密码了，又想修改，则命令如下：</p>
<p>方法一：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">mysql -u root -p		//需要先以 root 身份登录到数据库</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> <span class="keyword">FOR</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> = <span class="keyword">PASSWORD</span>(<span class="string">'newpass'</span>);</span><br></pre></td></tr></table></figure></div>
<p>方法二：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">mysql -u root -p		//也需要登录</span><br><span class="line"><span class="keyword">use</span> mysql;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> <span class="keyword">Password</span> = <span class="keyword">PASSWORD</span>(<span class="string">'newpass'</span>) <span class="keyword">WHERE</span> <span class="keyword">user</span> = <span class="string">'root'</span>;</span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;	// 刷新权限</span><br></pre></td></tr></table></figure></div>
<h3 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h3><p><strong>grant</strong> 语句</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">// <span class="keyword">grant</span>语句   所有权限   所有数据库    用户    登录地点             用户密码</span><br><span class="line"><span class="keyword">grant</span> all <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'jiyi2'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'123456'</span> <span class="keyword">with</span> <span class="keyword">grant</span> <span class="keyword">option</span>;</span><br><span class="line">// %号代表所有地方登录</span><br></pre></td></tr></table></figure></div>
<p>例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> reload,process <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'jiyi3'</span>@<span class="string">'localhost'</span>;</span><br><span class="line">// 给部分权限给jiyi3，localhost为本地登录</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">usage</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'jiyi4'</span>@<span class="string">'localhost'</span>;</span><br><span class="line">// 不给权限给用户jiyi4</span><br></pre></td></tr></table></figure></div>
<p><strong>insert</strong> 语句</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="string">'localhost/%'</span>,<span class="string">'jiyi'</span>,<span class="keyword">PASSWORD</span>(<span class="string">'123456'</span>),<span class="string">'Y'</span>,<span class="string">'Y'</span>,<span class="string">'Y'</span>,<span class="string">'Y'</span>,<span class="string">'Y'</span>,<span class="string">'Y'</span>,<span class="string">'Y'</span>,<span class="string">'Y'</span>,<span class="string">'Y'</span>,<span class="string">'Y'</span>,<span class="string">'Y'</span>,<span class="string">'Y'</span>,<span class="string">'Y'</span>,<span class="string">'Y'</span>);</span><br><span class="line">					//登录地(本地或者所有地)，用户名，密码，			后面的Y都是权限，所有都是Y相当于all privileges</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (Host,<span class="keyword">User</span>,<span class="keyword">Password</span>) <span class="keyword">VALUES</span>(<span class="string">'localhost'</span>,<span class="string">'jiyi'</span>,<span class="string">'123456'</span>);</span><br><span class="line">//指定地点用户</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>注意：<strong>insert</strong> 语句最后都要加一句<strong>flush privileges;</strong> 以刷新权限列表。</p>
</blockquote>
<h3 id="MySQL-导入-SQL-文件"><a href="#MySQL-导入-SQL-文件" class="headerlink" title="MySQL 导入 SQL 文件"></a>MySQL 导入 SQL 文件</h3><p><strong>MySQL</strong> 导入命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">source /data/sql/createDB.sql;</span><br><span class="line">// 该命令是将放在 mysql 文件夹内的 data/sql 文件夹内的.sql文件导入到 MySQL 中</span><br><span class="line">source D:/createDB.sql;</span><br><span class="line">// 这是将放在 D 盘的 .sql 文件导入到 MySQL 中</span><br></pre></td></tr></table></figure></div>
<p><strong>MySQL</strong> 备份命令：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">// 结构：</span><br><span class="line">mysqldump -u 用户名 -p 数据库名 表名 &gt; 导出的文件名</span><br><span class="line">// 如:</span><br><span class="line">mysqldump -uroot -p jiyidata &gt; jiyidata.sql	// 指定数据库</span><br><span class="line">mysqldump -uroot -p jiyidata jiyitable &gt; jiyitable.sql	// 指定数据库表</span><br></pre></td></tr></table></figure>
<p><strong>MySQL</strong> 导入文本数据</p>
<p>1、文本数据应符合的格式：字段数据之间用 tab 键隔开，null 值用 \n 来代替. </p>
<p>例： </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">3 rose 深圳二中 1976-10-10 </span><br><span class="line">4 mike 深圳一中 1975-12-23</span><br></pre></td></tr></table></figure></div>
<p>2、数据传入命令 </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"># load data local infile "文件名" into table 表名; </span><br><span class="line"># 如：</span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> <span class="keyword">infile</span> <span class="string">"jiyi.txt"</span> <span class="keyword">into</span> <span class="keyword">table</span> jiyitable;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>注意：你最好将文件复制到 <em>\mysql\bin</em> 目录下，并且要先用 <code>use</code> 命令打表所在的库。</p>
</blockquote>
<h3 id="数据库和表语句"><a href="#数据库和表语句" class="headerlink" title="数据库和表语句"></a>数据库和表语句</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> jiyidata;	// 创建 jiyidata 数据库</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;		// 显示所有数据库</span><br><span class="line"><span class="keyword">use</span> jiyidata;		// 使用 jiyidata 数据库，切换到 jiyidata 数据库下</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;		// 展示 jiyidata 中的所有表格</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> jiyitable;	// 如果存在 jiyitable 就删除</span><br></pre></td></tr></table></figure></div>
<p>创建表</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> jiyitable(<span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span> auto_increment,phonenumber <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">unique</span>);</span><br></pre></td></tr></table></figure></div>
<ol>
<li>不为空 <code>not null</code></li>
<li>主键 <code>primary key</code></li>
<li>自增长 <code>auto_increment</code></li>
<li>唯一 <code>unique</code></li>
<li>默认值 <code>default &#39;1&#39;</code> 默认为1</li>
<li><code>id int(11) unsigned</code> 代表 int 无符号，即都表示正数，这样比 signed 表示的更多数，其实当我们在选择使用 int 的类型的时候，不论是 int(3) 还是 int(11)，它在数据库里面存储的都是 4 个字节的长度，在使用 int(3) 的时候如果你输入的是 10，会默认给你存储位 010,也就是说这个 3 代表的是默认的一个长度，当你不足 3 位时，会帮你不全，当你超过 3 位时，就没有任何的影响。</li>
</ol>
<h3 id="表基本操作语句"><a href="#表基本操作语句" class="headerlink" title="表基本操作语句"></a>表基本操作语句</h3><p>查、增、改、删</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">// sql语句大概分为4中情况</span><br><span class="line">// 1. 查询</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> usertable;</span><br><span class="line">// 2. 插入</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> usertable(<span class="keyword">id</span>,phonenumber) <span class="keyword">values</span>(<span class="string">'3'</span>,<span class="string">'13140999025'</span>);</span><br><span class="line">// 3. 更新</span><br><span class="line"><span class="keyword">update</span> usertable <span class="keyword">set</span> phonenumber=<span class="string">'13140999029'</span>  <span class="keyword">where</span> <span class="keyword">id</span>=<span class="string">'3'</span>;</span><br><span class="line">// 4. 删除</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> usertable <span class="keyword">where</span> <span class="keyword">id</span>=<span class="string">'3'</span>;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 图形化排序算法</title>
    <url>/2016/11/24/android_sort/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">排序算法不好理解？那就来个 GUI 的!</p>

<p>上篇C语言实现各排序算法的完成，使得自己对排序有了一定的了解，最近看到一个 <em>iOS</em> 图形化排序过程，因此今天就完成 <em>Android</em> 端的图形化排序过程。</p>
<p>排序算法实现很简单，其重点是要实现安卓 <strong>View</strong> 跟随排序的动态变化。</p>
<p>由于计算机执行排序算法的高效性，对一定数量的数组排序都是 <strong>毫秒级</strong> 的，因此我们要考虑 <strong>放大排序时间</strong>，给可视化界面完整的动态过程。</p>
<h2 id="一、总体功能界面"><a href="#一、总体功能界面" class="headerlink" title="一、总体功能界面"></a>一、总体功能界面</h2><hr>
<h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p><img src="http://img.godjiyi.cn/jysortwelcome.gif" alt="maingif"></p>
<a id="more"></a>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>六种排序算法完成</li>
<li>可视动态化界面实现</li>
<li>时间计时器 </li>
<li>算法时间复杂度说明</li>
</ul>
<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><ol>
<li>Android 图形化排序地址：<a href="https://github.com/jiyiren/JYSort" target="_blank" rel="noopener">https://github.com/jiyiren/JYSort</a></li>
<li>C 实现排序项目地址：<a href="https://github.com/jiyiren/CSort" target="_blank" rel="noopener">https://github.com/jiyiren/CSort</a></li>
</ol>
<h2 id="二、实现重点"><a href="#二、实现重点" class="headerlink" title="二、实现重点"></a>二、实现重点</h2><h3 id="数据与界面的初始化"><a href="#数据与界面的初始化" class="headerlink" title="数据与界面的初始化"></a>数据与界面的初始化</h3><ol>
<li>数据是随机生成 <em>100个数组</em> 成一个数组，当然这个长度我们定义成全局变量，可以自行修改。</li>
<li>界面的初始化由上到下分别为 <strong>Toolbar菜单栏</strong>、<strong>主体排序可视窗口</strong>、<strong>时间复杂度</strong> 等。</li>
<li>重点在于中间主体排序 <strong>可视窗口的绘制</strong>：因为可视的 <em>View</em> 就是要表示数组中各个数据的大小，因而我们就将每个柱状 <em>View</em> 的高度用于表示数组中各个数据的大小，但是由于手机界面有限，如果有的数据过大那么绘制将超出屏幕。因此我们采取将 <em>3/5</em> 个屏幕像素与数组中最大值的<strong>比值</strong>作为每个数转为高度的一个因素，也就是说数组中数据不管多大，其高度最高最大为 <em>3/5</em> 个屏幕大小。而其宽度则是根据数组长度由屏幕宽度计算得出，具体如下：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化界面的柱状图</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll_root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        ll_root= (LinearLayout) findViewById(R.id.ll_root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ll_sortpart==<span class="keyword">null</span>) &#123;</span><br><span class="line">        ll_sortpart = (LinearLayout) ll_root.findViewById(R.id.ll_sortpart);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mViews.size()&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mArray.length; i++) &#123;</span><br><span class="line">            View view = <span class="keyword">new</span> View(<span class="keyword">this</span>);</span><br><span class="line">            ll_sortpart.addView(view);</span><br><span class="line">            LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) view.getLayoutParams();</span><br><span class="line">            columnWidth = (screenWidth - DensityUtil.dp2px(<span class="keyword">this</span>, paddingLR * <span class="number">2</span>)) / mArray.length</span><br><span class="line">                        -DensityUtil.dp2px(<span class="keyword">this</span>, intervalColumn);</span><br><span class="line">            layoutParams.setMargins(DensityUtil.dp2px(<span class="keyword">this</span>, intervalColumn), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            layoutParams.height = (<span class="keyword">int</span>) (mArray[i] * pixPerNum());</span><br><span class="line">            layoutParams.width = columnWidth;</span><br><span class="line">            view.setLayoutParams(layoutParams);</span><br><span class="line">            view.setBackgroundColor(ContextCompat.getColor(<span class="keyword">this</span>, R.color.colorPrimaryDark));</span><br><span class="line">            mViews.add(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//获得在高度上，单位数字所代表的像素，由于屏幕高度是像素，而我们的排序为int数字，要想形象化绘制成柱状图</span></span><br><span class="line"><span class="comment">//就要计算出单位数字的像素，然后通过数组中的数字相乘即可得到柱状view的高度了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">pixPerNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    columnPixPerNum=(<span class="keyword">double</span>) screenHeight*<span class="number">0.6</span>/(Max(mArray));</span><br><span class="line">    <span class="keyword">return</span> columnPixPerNum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得数组中最大数字，仅仅用于@pixPerNum方法中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max&lt;array[i])&#123;</span><br><span class="line">            max=array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="排序同时界面更新"><a href="#排序同时界面更新" class="headerlink" title="排序同时界面更新"></a>排序同时界面更新</h3><ol>
<li>界面的中每个柱状View与数组一一对应，这样我们只需要记住排序数组的下标就可以同步View数组了。</li>
<li>排序是耗时操作，我们需要开启线程进行排序，因此需要用到消息传递来通知界面的变化，这里主要使用<strong>Handler</strong>来进行处理线程消息。</li>
<li>整个流程为：在开启排序时，算法中的数组在进行数据交换时，我们会记录此时交换数据的两个下标，同时将这些数据包装成消息发送给<strong>Handler</strong>,<strong>Handler</strong>将界面柱状View数组中两个相同下标的View高度互换，达到界面显示与排序一致的效果。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (currentSortKind)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//快速</span></span><br><span class="line">                quicksort(mArray,<span class="number">0</span>,mArray.length-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//堆</span></span><br><span class="line">                HeadSort(mArray,mArray.length);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//归并</span></span><br><span class="line">                <span class="keyword">int</span>[] mtemp=<span class="keyword">new</span> <span class="keyword">int</span>[SIEZ_ARRAY];</span><br><span class="line">                MergeSort(mArray,mtemp,<span class="number">0</span>,mArray.length-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//插入</span></span><br><span class="line">                insertsort(mArray,<span class="number">0</span>,mArray.length-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//冒泡</span></span><br><span class="line">                bubblesort(mArray,<span class="number">0</span>,mArray.length-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:<span class="comment">//选择</span></span><br><span class="line">                selectsort(mArray,<span class="number">0</span>,mArray.length-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        handler.sendEmptyMessage(WHAT_SORT_FINISH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startIndex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> endIndex</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectsort</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,minIndex;</span><br><span class="line">    <span class="keyword">for</span>(i=startIndex;i&lt;endIndex;i++)&#123;</span><br><span class="line">        minIndex=i;</span><br><span class="line">        <span class="comment">//选出最小下标，放在最前面</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=endIndex;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[minIndex]&gt;array[j])&#123;</span><br><span class="line">                minIndex=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minIndex!=i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=array[i];</span><br><span class="line">            array[i]=array[minIndex];</span><br><span class="line">            array[minIndex]=temp;</span><br><span class="line">            <span class="comment">//此处发送消息通知Handler更新View层变化</span></span><br><span class="line">            sleepAndSendMessage(i,minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换两个View的高度，这是Handler处理界面变化的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapColumHeight</span><span class="params">(View viewone,View viewtwo)</span></span>&#123;</span><br><span class="line">    LinearLayout.LayoutParams paramsone= (LinearLayout.LayoutParams) viewone.getLayoutParams();</span><br><span class="line">    LinearLayout.LayoutParams paramstwo= (LinearLayout.LayoutParams) viewtwo.getLayoutParams();</span><br><span class="line">    <span class="keyword">int</span> temp=paramsone.height;</span><br><span class="line">    paramsone.height=paramstwo.height;</span><br><span class="line">    paramstwo.height=temp;</span><br><span class="line">    viewone.setLayoutParams(paramsone);</span><br><span class="line">    viewtwo.setLayoutParams(paramstwo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="排序延迟操作"><a href="#排序延迟操作" class="headerlink" title="排序延迟操作"></a>排序延迟操作</h3><p>由于排序算法只有在对数以万计的数据时才会有可见的时间长度，因而我们如果像正常一样设置排序和界面更新时，每个排序算法都几乎在毫秒级别完成，并且界面变化几乎不可见。</p>
<p>因此，我们需要让排序算法尽可能地延长一定时间，达到界面的变化可视化级别。</p>
<p>我们在数组交换数据时发送消息给 <strong>Handler</strong> 处进行了一定的时间延迟，当然不会过长，此处设置了 <strong>10ms</strong>。( 也同时因为这样的设置，界面显示的耗时操作实际上并非算法真正的排序时间，而应该减去延迟时间乘以延迟操作的次数。)</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换的信号</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleepAndSendMessage</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	 <span class="comment">//此处延迟10ms</span></span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        Message message=<span class="keyword">new</span> Message();</span><br><span class="line">        message.what=WHAT_SORT_SWAP_VIEW;</span><br><span class="line">        message.arg1=i;</span><br><span class="line">        message.arg2=j;</span><br><span class="line">        handler.sendMessage(message);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="三、动画演示"><a href="#三、动画演示" class="headerlink" title="三、动画演示"></a>三、动画演示</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><img src="http://img.godjiyi.cn/jysortfast.gif" alt="fast"></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="http://img.godjiyi.cn/jysortheap.gif" alt="heap"></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img src="http://img.godjiyi.cn/jysortmerge.gif" alt="merge"></p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><img src="http://img.godjiyi.cn/jysortinsert.gif" alt="insert"></p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><img src="http://img.godjiyi.cn/jysortbubble.gif" alt="bubble"></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p><img src="http://img.godjiyi.cn/jysortselect.gif" alt="select"></p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="项目-1"><a href="#项目-1" class="headerlink" title="项目"></a>项目</h3><ol>
<li>Android图形化排序地址：<a href="https://github.com/jiyiren/JYSort" target="_blank" rel="noopener">https://github.com/jiyiren/JYSort</a></li>
<li>C实现排序项目地址：<a href="https://github.com/jiyiren/CSort" target="_blank" rel="noopener">https://github.com/jiyiren/CSort</a></li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cnblogs.com/jingmoxukong/p/4308823.html" target="_blank" rel="noopener">http://www.cnblogs.com/jingmoxukong/p/4308823.html</a></li>
<li><a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="noopener">http://blog.csdn.net/morewindows/article/details/6684558</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言实现各排序算法</title>
    <url>/2016/11/24/csort/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">面试官：“ 先手写一个快速排序吧！”</p>

<p>最近整理了一些排序算法，并记录下实现过程！作为备忘笔记。主要有：<strong>快速排序</strong>、<strong>堆排序</strong>、<strong>归并排序</strong>、<strong>插入排序</strong>、<strong>冒泡排序</strong>、<strong>选择排序</strong>等。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><strong>算法是程序的灵魂</strong>。无论程序多么的复杂，只要我们能够抓住程序的主要“矛盾”，就能够适时地解决这些问题，而算法就是其主要矛盾。</li>
<li><strong>排序算法是算法的基础</strong>。我们需要学习算法，就必然需要打好自己学习的基石，排序算法作为最基本易懂的算法，我们不精通它又怎么能驾驭得了其他高级算法呢？</li>
<li><strong>C 语言</strong>：本文选择 <code>C</code> 作为实现语言，主要是本人在看 <code>Linux</code> 下的 C 编程一书，于是就顺便直接在 Linux 系统下开写了！我想 C 语言是每个人都能看得懂的语言，并且其特殊性很少，几乎完全能转化为其他各式语言 ( <code>Java</code>, <code>Php</code>, <code>Python</code> 等 )，因此这也是 C 的好处。</li>
</ul>
<h2 id="排序算法说明"><a href="#排序算法说明" class="headerlink" title="排序算法说明"></a>排序算法说明</h2><h3 id="一、快速排序-FastSort"><a href="#一、快速排序-FastSort" class="headerlink" title="一、快速排序 / FastSort"></a>一、快速排序 / FastSort</h3><p>快速排序是 <em>C.R.A.Hoare</em> 于 1962 年提出的一种划分交换排序方法，其核心是分治法。</p>
<p>实现过程：</p>
<p>从数列中选取一个作为 <strong>基准数</strong> ( 不妨就选第一个，通常也都是选择第一个 )；然后进行<strong>分区</strong>，将比它小的数放在它左边，比其大的则放在右边；然后对 <strong>左右区间进行相同操作</strong> ( 也就是递归 )，直到各个区间只剩一个数。</p>
<a id="more"></a>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(startIndex&lt;endIndex)&#123;</span><br><span class="line">  	 <span class="comment">//x作为基准数</span></span><br><span class="line">    <span class="keyword">int</span> i=startIndex,j=endIndex,x=<span class="built_in">array</span>[startIndex];</span><br><span class="line">    <span class="comment">//下面进行分区</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">      <span class="keyword">while</span>(i&lt;j&amp;&amp;<span class="built_in">array</span>[j]&gt;=x)&#123;</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="built_in">array</span>[i++]=<span class="built_in">array</span>[j];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(i&lt;j&amp;&amp;<span class="built_in">array</span>[i]&lt;x)&#123;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="built_in">array</span>[j--]=<span class="built_in">array</span>[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">array</span>[i]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左右区间进行相同操作</span></span><br><span class="line">    quicksort(<span class="built_in">array</span>,startIndex,i<span class="number">-1</span>);</span><br><span class="line">    quicksort(<span class="built_in">array</span>,i+<span class="number">1</span>,endIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="二、堆排序-HeapSort"><a href="#二、堆排序-HeapSort" class="headerlink" title="二、堆排序 / HeapSort"></a>二、堆排序 / HeapSort</h3><p>堆排序是 <em>Robert W．Floyd</em> 和 <em>J．Williams</em> 在 1964 年共同发明的，其核心是堆数据结构的运用。</p>
<p>堆：是一种数据结构，属于树类，它是 <strong>一棵完全二叉树</strong> ( 也就是二叉树的儿子要么没有要么一定要有左儿子，不会出现只有右儿子的情况 )，并且通常父亲要大于其两个儿子 ( 也就是大堆 )。</p>
<p>实现过程：首先将数组建成堆数据结构，然后将堆的根结点与最后结点交换，再对前 <em>n-1</em> 个数再进行调整堆，从而根结点又是 <em>n-1</em> 个数中最大的，与最后结点再次交换，如此循环。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本函数功能是：根据数组array构建大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> i,<span class="keyword">int</span> nLength)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> nChild;</span><br><span class="line">  <span class="keyword">int</span> nTemp;</span><br><span class="line">  <span class="keyword">for</span>(;<span class="number">2</span>*i+<span class="number">1</span>&lt;nLength;i=nChild)&#123;</span><br><span class="line">    <span class="comment">//子节点的位置=2*(父节点位置)+1</span></span><br><span class="line">    nChild=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//得到子节点中较大的节点</span></span><br><span class="line">    <span class="keyword">if</span>(nChild&lt;nLength<span class="number">-1</span>&amp;&amp;<span class="built_in">array</span>[nChild+<span class="number">1</span>]&gt;<span class="built_in">array</span>[nChild])&#123;</span><br><span class="line">      ++nChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果较大的子节点大于父节点那么把较大的子节点往上移动，替换它的父节点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[i]&lt;<span class="built_in">array</span>[nChild])&#123;</span><br><span class="line">      nTemp=<span class="built_in">array</span>[i];</span><br><span class="line">      <span class="built_in">array</span>[i]=<span class="built_in">array</span>[nChild];</span><br><span class="line">      <span class="built_in">array</span>[nChild]=nTemp;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">break</span>;<span class="comment">//否则退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,temp;</span><br><span class="line">  <span class="comment">//调整序列的前半部分元素，调整完之后第一个元素是序列的最大元素</span></span><br><span class="line">  <span class="comment">//length/2-1是最后一个非叶节点，（length为下标加1）</span></span><br><span class="line">  <span class="keyword">for</span>(i=length/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">    HeapAdjust(<span class="built_in">array</span>,i,length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//从最后一个元素开始对序列进行调整，不断缩小调整的范围直到第一个元素</span></span><br><span class="line">  <span class="keyword">for</span>(i=length<span class="number">-1</span>;i&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">    temp=<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>]=<span class="built_in">array</span>[i];</span><br><span class="line">    <span class="built_in">array</span>[i]=temp;</span><br><span class="line">    <span class="comment">//不断缩小调整heap的范围，每一次调整完毕保证第一个元素是当前序列的最大值</span></span><br><span class="line">    HeapAdjust(<span class="built_in">array</span>,<span class="number">0</span>,i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="三、归并排序-MergeSort"><a href="#三、归并排序-MergeSort" class="headerlink" title="三、归并排序 / MergeSort"></a>三、归并排序 / MergeSort</h3><p>归并排序核心也是 <strong>分治法</strong>。</p>
<p>实现过程：首先是<strong>申请变量空间</strong>，归并排序是这些算法中空间占用最大的算法，然后循环将数组分为两个子序列，再将两子序列合并为有序段。</p>
<p>归并排序的算法我们通常用递归实现，先把待排序区间 [s,t] 以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间 [s,t]。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将两个有序数列合并成一个有序数列</span></span><br><span class="line"><span class="comment">//sourceArr为待合并数列，tempArr为合并后序列，仅仅作为中转操作存储</span></span><br><span class="line"><span class="comment">//startIndex,midIndex,endIndex分别为sourceArr中分为两序列的前中后下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> sourceArr[],<span class="keyword">int</span> tempArr[],<span class="keyword">int</span> startIndex,<span class="keyword">int</span> midIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=startIndex,j=midIndex+<span class="number">1</span>,k=startIndex;</span><br><span class="line">  <span class="comment">//分别从两个序列的起始开始，逐一比较两个序列中元素大小</span></span><br><span class="line">  <span class="keyword">while</span>(i!=midIndex+<span class="number">1</span> &amp;&amp; j!=endIndex+<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(sourceArr[i]&gt;sourceArr[j])&#123;</span><br><span class="line">      <span class="comment">//较小的存入合并序列</span></span><br><span class="line">      tempArr[k++]=sourceArr[j++];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//较小的存入合并序列</span></span><br><span class="line">      tempArr[k++]=sourceArr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将未合并的直接放到合并序列里</span></span><br><span class="line">  <span class="keyword">while</span>(i!=midIndex+<span class="number">1</span>)&#123;</span><br><span class="line">    tempArr[k++]=sourceArr[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(j!=endIndex+<span class="number">1</span>)&#123;</span><br><span class="line">    tempArr[k++]=sourceArr[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//最后将合并序列在放入原始数列中</span></span><br><span class="line">  <span class="keyword">for</span>(i=startIndex;i&lt;=endIndex;i++)&#123;</span><br><span class="line">    sourceArr[i]=tempArr[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sourceArr为原待排序列，tempArr为合并后序列，作为临时存放区</span></span><br><span class="line"><span class="comment">//startIndex为数组开始下标，endIndex为结束下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> sourceArr[],<span class="keyword">int</span> tempArr[],<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> midIndex;</span><br><span class="line">  <span class="keyword">if</span>(startIndex&lt;endIndex)&#123;</span><br><span class="line">    <span class="comment">//将原序列二分为两个序列</span></span><br><span class="line">    midIndex=(startIndex+endIndex)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//分别对两个序列，再进行二分</span></span><br><span class="line">    MergeSort(sourceArr,tempArr,startIndex,midIndex);</span><br><span class="line">    MergeSort(sourceArr,tempArr,midIndex+<span class="number">1</span>,endIndex);</span><br><span class="line">    <span class="comment">//对每个二分序列进行合并</span></span><br><span class="line">    Merge(sourceArr,tempArr,startIndex,midIndex,endIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="四、插入排序-InsertSort"><a href="#四、插入排序-InsertSort" class="headerlink" title="四、插入排序 / InsertSort"></a>四、插入排序 / InsertSort</h3><p>插入排序是将未排序的数插入到已经排好序的数组里，使得新生成的数列也是有序的。</p>
<p><em>实现过程</em>：将第一个数作为已经排好的序列，然后从后面开始循环插入到第一个数列中，插入的方法是从第一个序列的最后一位开始循环与待插入的数对比，如果比其大则往后移动，直至小于等于其大小或则循环到第一个数为止。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两层循环，外循环从下标+1处开始到结束</span></span><br><span class="line"><span class="comment">//内层循环，将外层循环中的数与其前面的所有数对比插入。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertsort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j,item;</span><br><span class="line">  <span class="keyword">if</span>(endIndex&gt;startIndex)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=startIndex+<span class="number">1</span>;j&lt;=endIndex;j++)&#123;</span><br><span class="line">      item=<span class="built_in">array</span>[j];</span><br><span class="line">      i=j<span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">while</span>(i&gt;=startIndex&amp;&amp;item&lt;<span class="built_in">array</span>[i])&#123;</span><br><span class="line">        <span class="comment">//i&gt;=startIndex为防止i--越界</span></span><br><span class="line">        <span class="built_in">array</span>[i+<span class="number">1</span>]=<span class="built_in">array</span>[i];<span class="comment">//将比item大的数依次后移</span></span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">array</span>[i+<span class="number">1</span>]=item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="五、冒泡排序-BubbleSort"><a href="#五、冒泡排序-BubbleSort" class="headerlink" title="五、冒泡排序 / BubbleSort"></a>五、冒泡排序 / BubbleSort</h3><p>冒泡排序应该是最简单的排序算法了，它的实现过程就是利用两层数组循环，逐一将两个数进行对比，将小数放前面，大数放后面。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序--顺序比较</span></span><br><span class="line"><span class="comment">//array为数组，startIndex为开始下标(&gt;=0),endIndex为结束下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="keyword">for</span>(i=startIndex;i&lt;endIndex;i++)&#123;</span><br><span class="line">    <span class="comment">//将最大值放在最后面</span></span><br><span class="line">    <span class="keyword">for</span>(j=startIndex;j&lt;endIndex-i;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">array</span>[j]&gt;<span class="built_in">array</span>[j+<span class="number">1</span>])&#123;</span><br><span class="line">        swap(&amp;<span class="built_in">array</span>[j],&amp;<span class="built_in">array</span>[j+<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="六、选择排序-SelectSort"><a href="#六、选择排序-SelectSort" class="headerlink" title="六、选择排序 / SelectSort"></a>六、选择排序 / SelectSort</h3><p>选择排序其实现过程是通过两层循环，每次找出剩余序列中的最小值，最终得到排序好的数组。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每次选择剩余中的最小值，依次到结束</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectsort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j,minIndex;</span><br><span class="line">  <span class="keyword">for</span>(i=startIndex;i&lt;endIndex;i++)&#123;</span><br><span class="line">    minIndex=i;</span><br><span class="line">    <span class="comment">//选出最小下标，放在最前面</span></span><br><span class="line">    <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=endIndex;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">array</span>[minIndex]&gt;<span class="built_in">array</span>[j])&#123;</span><br><span class="line">        minIndex=j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minIndex!=i)&#123;</span><br><span class="line">      swap(&amp;<span class="built_in">array</span>[i],&amp;<span class="built_in">array</span>[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="项目实现"><a href="#项目实现" class="headerlink" title="项目实现"></a>项目实现</h3><ol>
<li><p>C实现排序项目地址：<a href="https://github.com/jiyiren/CSort" target="_blank" rel="noopener">https://github.com/jiyiren/CSort</a></p>
</li>
<li><p>Android图形化排序地址：<a href="https://github.com/jiyiren/JYSort" target="_blank" rel="noopener">https://github.com/jiyiren/JYSort</a></p>
</li>
</ol>
<h3 id="归并排序和堆排序、快速排序的比较"><a href="#归并排序和堆排序、快速排序的比较" class="headerlink" title="归并排序和堆排序、快速排序的比较"></a>归并排序和堆排序、快速排序的比较</h3><ul>
<li>若从<em>空间复杂度</em>来考虑：首选<strong>堆排序</strong>，其次是<strong>快速排序</strong>，最后是<strong>归并排序</strong>。</li>
<li>若从<em>稳定性</em>来考虑，应选取<strong>归并排序</strong>，因为堆排序和快速排序都是不稳定的。</li>
<li>若从<em>平均情况</em>下的排序速度考虑，应该选择<strong>快速排序</strong>。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cnblogs.com/jingmoxukong/p/4308823.html" target="_blank" rel="noopener">http://www.cnblogs.com/jingmoxukong/p/4308823.html</a></li>
<li><a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="noopener">http://blog.csdn.net/morewindows/article/details/6684558</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>依赖倒置原则，接口隔离原则</title>
    <url>/2016/08/31/dip_isp/</url>
    <content><![CDATA[<h2 id="三、依赖倒置原则"><a href="#三、依赖倒置原则" class="headerlink" title="三、依赖倒置原则"></a>三、依赖倒置原则</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>依赖倒置原则(Dependence Inversion Principle ,DIP):<strong>高层模块不应该依赖低层模块，应该依赖其抽象，抽象不应该依赖其细节，细节应该依赖其抽象。</strong></p>
<p>理解：<strong>低层模块</strong>：具体细化的 <strong>Java</strong> 类。<strong>高层模块</strong>：是由多个低层模块组成的。<strong>抽象</strong>：指的是接口或者抽象类。<strong>依赖</strong>：存在类 A 的一个方法 S, S 传入的参数是另一个类 B 的实例，那么类 A 依赖于类 B, 也就是类 A 中引用了类 B, 则 A 依赖 B, 因为 A 类中缺少了 B 类就无法正常运行了！</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>先举一个反例子：一个司机开宝马车。正常思维是定义一个司机类 Driver, 并实现一个开车 <code>void drive(BMWCar bmwcar)</code> 的方法，该方法传入的是宝马车的一个实例！</p>
<a id="more"></a>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//宝马车类，实现run()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWCar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"宝马车开动了...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//司机类，实现开车方法，传入宝马车实例参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(BMWCar bmwcar)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"司机开车..."</span>);</span><br><span class="line">        bmwcar.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Driver driver=<span class="keyword">new</span> Driver();</span><br><span class="line">		driver.drive(<span class="keyword">new</span> BMWCar());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">司机开车...</span><br><span class="line">宝马车开动了....</span><br></pre></td></tr></table></figure></div>
<p>结果得到没有问题！但现在我们更改需求了，司机现在改开奔驰了，那么如果在这个类的基础上更改，我们需要给司机提供一个 <code>drive(BenCar bencar)</code> 的方法。而如果后续要司机开各种车难道都要实现一个方法吗？这不免造成依赖性太强和冗余过度情况！</p>
<p>现在的解决方案：定义接口 <em>ICar</em>, 让 <em>BMWCar</em> 等其他车类都实现 <em>ICar</em> 接口，而司机 <em>Driver</em> 类只需在 <code>drive(ICar car)</code> 的方法里传入 <em>ICar</em> 类型即可实现司机开各种车型的功能！</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMWCar</span> <span class="keyword">implements</span> <span class="title">ICar</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"宝马开动了。。。"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenCar</span> <span class="keyword">implements</span> <span class="title">ICar</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"奔驰开动了。。。"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>司机Driver类</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(ICar car)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"司机开车。。。"</span>);</span><br><span class="line">		car.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DipMain</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Driver driver=<span class="keyword">new</span> Driver();</span><br><span class="line">		BMWCar bmwcar=<span class="keyword">new</span> BMWCar();</span><br><span class="line">		BenCar bencar=<span class="keyword">new</span> BenCar();</span><br><span class="line">		driver.drive(bmwcar);</span><br><span class="line">		driver.drive(bencar);<span class="comment">//实现司机开大奔了！</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上面就遵循了依赖倒置原则，另外上面依赖的传递是通过参数直接传的！实际上依赖传递分为三种情况：</p>
<blockquote>
<blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、通过构造方法传递</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ICar car;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver2</span><span class="params">(ICar car)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"司机发动车了..."</span>);</span><br><span class="line">        car.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、通过setter方法传递</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ICar car;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"司机开车....."</span>);</span><br><span class="line">        car.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(ICar car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、通过接口传递(也就是我们上面例子的使用方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(ICar car)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"司机发动车了..."</span>);</span><br><span class="line">        car.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
</blockquote>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在实际编程中，我们一般需要做到如下3点：</p>
<p>1、<strong>低层模块尽量都要有抽象类或接口，或者两者都有</strong>。<br>2、<strong>变量的声明类型尽量是抽象类或接口</strong>。<br>3、<strong>使用继承时遵循里氏替换原则</strong>。</p>
<p>依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</p>
<h2 id="四、接口隔离原则"><a href="#四、接口隔离原则" class="headerlink" title="四、接口隔离原则"></a>四、接口隔离原则</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>接口隔离原则 ( Interface Segregation Principle ): <strong>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上</strong>。</p>
<p>理解：将臃肿的接口根据其他类需要使用的方法拆分为独立的几个接口。也就是采用接口隔离原则。实际上该原则与单一职责原则有点相似，都是将方法拆分成多份！不同点是单一职责通常适用于类，并且根据职责拆分；而接口隔离原则主要适用于接口，根据其他类的使用需求拆分！</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>首先定义了一个接口 I, 并定义 5 个方法, 并定义类 A 类 C, 这两个类依赖 I；类A依赖于接口I中的 method1(), method2(), method3()三个方法；类 C 依赖接口I中的 method1(), method()4, method5() 三个方法。</p>
<p>类 B, 类 D 则是 A, B 依赖接口I的具体方法实现。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">		i.method1();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">		i.method2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">		i.method3();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">		i.method1();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">		i.method4();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">		i.method5();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"类B实现接口I的方法1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"类B实现接口I的方法2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"类B实现接口I的方法3"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法，</span></span><br><span class="line">	<span class="comment">//所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"类D实现接口I的方法1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法，</span></span><br><span class="line">	<span class="comment">//所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"类D实现接口I的方法4"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"类D实现接口I的方法5"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		A a = <span class="keyword">new</span> A();</span><br><span class="line">		a.depend1(<span class="keyword">new</span> B());</span><br><span class="line">		a.depend2(<span class="keyword">new</span> B());</span><br><span class="line">		a.depend3(<span class="keyword">new</span> B());</span><br><span class="line">		C c = <span class="keyword">new</span> C();</span><br><span class="line">		c.depend1(<span class="keyword">new</span> D());</span><br><span class="line">		c.depend2(<span class="keyword">new</span> D());</span><br><span class="line">		c.depend3(<span class="keyword">new</span> D());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口 I 进行拆分。</p>
<p>我们将接口 I 拆分为三个接口 I1, I2, I3; 而类 B, 类 D 的实现则不用完全实现 I 了，而只需实现自己需要的方法接口了！</p>
<blockquote>
<blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I2</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"类B实现接口I1的方法1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"类B实现接口I2的方法2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"类B实现接口I2的方法3"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I3</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"类D实现接口I1的方法1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"类D实现接口I3的方法4"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"类D实现接口I3的方法5"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同时A,C中的方法参数类型改为对应的接口即可！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;</span><br><span class="line">		i.method1();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I2 i)</span></span>&#123;</span><br><span class="line">		i.method2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I2 i)</span></span>&#123;</span><br><span class="line">		i.method3();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;</span><br><span class="line">		i.method1();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I3 i)</span></span>&#123;</span><br><span class="line">		i.method4();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I3 i)</span></span>&#123;</span><br><span class="line">		i.method5();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
</blockquote>
<p>本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>接口隔离原则的含义是：<strong>建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少</strong>。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p>
<p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p>
<p>1、接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。<br>2、为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。<br>3、提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 常用命令</title>
    <url>/2018/03/18/docker/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">为虚拟化应用而生，生产环境一键打包</p>

<p><code>Docker</code> 是一个开源的 <strong>应用容器引擎</strong>，基于 <code>Go</code> 语言 并遵 <code>从Apache2.0</code> 协议开源。<code>Docker</code> 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 <code>Linux</code> 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（ 类似 <code>iPhone</code> 的 <code>App</code> ），更重要的是容器性能开销极低。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><hr>
<ul>
<li><code>Web</code> 应用的自动化打包和发布；</li>
<li>自动化测试和持续集成、发布；</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用；</li>
<li>从头编译或者扩展现有的 <code>OpenShift</code> 等平台来搭建自己的PaaS环境；</li>
</ul>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><hr>
<p>官网：<a href="www.docker.com">www.docker.com</a></p>
<p>仓库：</p>
<ol>
<li><code>docker</code> 官网仓库: <a href="http://hub.docker.com" target="_blank" rel="noopener">http://hub.docker.com</a></li>
<li><code>docker</code> 中国区官网仓库: <a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a></li>
<li>阿里镜像仓库: <a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">https://dev.aliyun.com</a></li>
<li>163 仓库(需注册): <a href="http://c.163yun.com/hub" target="_blank" rel="noopener">http://c.163yun.com/hub</a></li>
</ol>
<a id="more"></a>
<p>安装：</p>
<ol>
<li><code>MacOS</code> 安装: <a href="https://docs.docker.com/docker-for-mac/install/" target="_blank" rel="noopener">官网教程地址</a></li>
<li><code>Ubuntu</code> 安装: <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">官网教程地址</a></li>
<li><p><code>Ubuntu</code> 简单旧版安装:</p>
 <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">uname -r 	<span class="comment"># 内核版本需要 &gt; 3.10</span></span><br><span class="line">sudo apt-get install -y docker.io <span class="comment"># 安装系统自带的 docker ( 可能不是最新版本 )</span></span><br><span class="line">docker version <span class="comment"># 出现客户端和服务端版本</span></span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<h2 id="Docker初体验"><a href="#Docker初体验" class="headerlink" title="Docker初体验"></a>Docker初体验</h2><hr>
<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>docker pull <strong>[OPTIONS]</strong> NAME<strong>[:TAG]</strong></p>
<p><em>NAME</em> 必须指定，<em>TAG</em> 表示版本，默认不写为 <code>latest</code> 最新版本</p>
<p>默认 <code>pull</code> 的地址为 <code>docker</code> 官方镜像地址: <a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">https://hub.docker.com/explore/</a></p>
<p>如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">docker pull hello-world		<span class="comment"># 拉取 hello-world 镜像</span></span><br><span class="line">docker pull tomcat			<span class="comment"># 拉取 tomcat 镜像</span></span><br><span class="line">docker pull nginx			<span class="comment"># 拉取 nginx 镜像</span></span><br><span class="line">docker pull mysql			<span class="comment"># 拉取 mysql 镜像</span></span><br></pre></td></tr></table></figure></div>
<p>但是国内该地址常常被墙，所以国内大公司出了自己的镜像仓库，在上一节已经说明。</p>
<p>这里以用 163 蜂巢的镜像为例，地址: <a href="https://c.163.com/hub#/m/home/" target="_blank" rel="noopener">https://c.163.com/hub#/m/home/</a></p>
<p>地址里含有 <strong>libary</strong> 为 163 从 <code>docker</code> 官网复制过来的镜像。</p>
<p>如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">docker pull hub.c.163.com/library/tomcat:latest	<span class="comment"># 拉取 tomcat 镜像</span></span><br><span class="line">docker pull hub.c.163.com/library/nginx:latest	<span class="comment"># 拉取 nginx 镜像</span></span><br><span class="line">docker pull hub.c.163.com/library/mysql:latest	<span class="comment"># 拉取 mysql 镜像</span></span><br></pre></td></tr></table></figure></div>
<h3 id="查看本机镜像"><a href="#查看本机镜像" class="headerlink" title="查看本机镜像"></a>查看本机镜像</h3><p>docker images <strong>[OPTIONS]</strong> <strong>[REPOSITORY[:TAG]]</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></div>
<h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><p>docker run <strong>[OPTIONS]</strong> IMAGE<strong>[:TAG]</strong> <strong>[COMMAND] [ARG]</strong></p>
<p>一个镜像运行起来就变为容器了，容器是动态的运行时的称呼。同一个镜像可以运行出多个容器，因为只要运行镜像，其内部内存占用等等一定不相同，所以镜像与容器是 <strong>1对多</strong> 的关系。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接运行</span></span><br><span class="line">docker run hello-world	<span class="comment"># 如果没有此镜像则会自动从官方下载镜像</span></span><br><span class="line">docker run tomcat		<span class="comment"># 通过命令行运行 tomcat，按 ctrl+c 就可以结束</span></span><br><span class="line"><span class="comment"># 也可以带参数 [OPTIONS] 运行</span></span><br><span class="line">docker run -d hello-world	<span class="comment"># -d 表示后台运行tomcat镜像</span></span><br><span class="line"><span class="comment"># 也可以带命令运行</span></span><br><span class="line">docker run learn/tutorial <span class="built_in">echo</span> <span class="string">"hello word"</span>	<span class="comment"># 输出 hello world</span></span><br><span class="line">docker run learn/tutorial apt-get install -y ping <span class="comment"># 安装 ping 工具</span></span><br><span class="line">docker run lean/ping ping www.google.com <span class="comment"># 执行 ping 命令</span></span><br></pre></td></tr></table></figure></div>
<h3 id="查看本机容器"><a href="#查看本机容器" class="headerlink" title="查看本机容器"></a>查看本机容器</h3><p>相信用过 Linux 的同学应该知道 <code>ps</code> 这个工具，代表 <code>process</code> 即进程。程序与进程的区别 和 镜像与容器的关系是一致的，进程和容器都是运行时状态，因此，查看本机容器的关键名也是 <code>ps</code>.</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前 docker 所运行的容器</span></span><br><span class="line">docker ps	<span class="comment"># 列出所有运行着的容器</span></span><br><span class="line"><span class="comment"># 要查看所有容器，包括未运行的容器</span></span><br><span class="line">docker ps -a	<span class="comment"># 显示所有容器</span></span><br></pre></td></tr></table></figure></div>
<h3 id="运行容器命令"><a href="#运行容器命令" class="headerlink" title="运行容器命令"></a>运行容器命令</h3><p>docker exec <strong>[OPTIONS]</strong> CONTAINER <strong>[COMMAND] [ARG]</strong></p>
<p>前面 <strong>运行镜像</strong> 时已经说明直接运行镜像时可以带上命令以一起运行，那如果容器已经被启动了，怎么再在里面运行命令呢？那就是这个命令。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在容器中运行命令，查看帮助文档</span></span><br><span class="line">docker <span class="built_in">exec</span> --<span class="built_in">help</span>	<span class="comment"># 查看帮助文档</span></span><br><span class="line"><span class="comment"># 其中 -i 和 -t 参数最常用，其这两者常搭配使用</span></span><br><span class="line"><span class="comment"># -i 表示以交互模式运行容器；</span></span><br><span class="line"><span class="comment"># -t 表示为容器重新分配一个伪输入终端；</span></span><br><span class="line">docker <span class="built_in">exec</span> -it f4e5 bash	<span class="comment"># 在某个容器里运行 bash</span></span><br><span class="line"><span class="comment"># 其中 f4e5 表示运行着的容器的 ID ，大家用前面的 docker ps 看到的 ID 就是；</span></span><br><span class="line"><span class="comment"># ID 可以选择前几个字符就可以的，因为前几个字符基本就能确定到这个容器了。</span></span><br></pre></td></tr></table></figure></div>
<h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p>docker stop <strong>CONTAINER_ID</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止某个容器 ( 可以为容器的 Id，也可以是容器的名称 )</span></span><br><span class="line">docker stop 56f433965490	<span class="comment"># 以容器 Id 停止容器</span></span><br></pre></td></tr></table></figure></div>
<h3 id="打包成镜像"><a href="#打包成镜像" class="headerlink" title="打包成镜像"></a>打包成镜像</h3><p>docker commit <strong>CONTAINER_ID</strong> <strong>IMAGE_NAME</strong></p>
<p>容器既然是镜像运行时状态，那我们如果在容器里装很多软件，而自己又不想每次用这个镜像都想重新装一遍软件，那么就可以将自己 DIY 的容器存为镜像，以后我们再 DIY 时就从我们已经装完软件的那个时刻开始了。将容器打包为镜像命令如上。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将容器打包成一个新的镜像</span></span><br><span class="line">docker commit 56f tomcat/property</span><br><span class="line"><span class="comment"># 将 Id 为 56f 的容器打包成一个镜像，镜像名称自己起就可以了</span></span><br></pre></td></tr></table></figure></div>
<h3 id="删除镜像和容器"><a href="#删除镜像和容器" class="headerlink" title="删除镜像和容器"></a>删除镜像和容器</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 删除容器</span></span><br><span class="line">docker rm CONTAINER_ID</span><br><span class="line"><span class="comment"># 2. 删除所有容器，-q 表示显示容器 Id</span></span><br><span class="line">docker rm $(docker ps -a -q)</span><br><span class="line"><span class="comment"># 3. 删除镜像，rmi 中的 i 表示 image</span></span><br><span class="line">docker rmi IMAGES_NAME</span><br><span class="line"><span class="comment"># 4：举例：删除 tomcat 镜像</span></span><br><span class="line">docker rmi tomcat</span><br></pre></td></tr></table></figure></div>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><hr>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>下面给出做 web 方向常用到的一些命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从 163镜像中心 下载 nginx 镜像</span></span><br><span class="line">docker pull hub.c.163.com/library/nginx:latest</span><br><span class="line"><span class="comment"># 或者从官网镜像中心下载 nginx 镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 Nginx 镜像， 没有端口映射，只能本机访问</span></span><br><span class="line">docker run hub.c.163.com/library/nginx		<span class="comment"># 前台运行</span></span><br><span class="line">docker run -d hub.c.163.com/library/nginx	<span class="comment"># 后台运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 Nginx 镜像，端口映射本机 80 端口,</span></span><br><span class="line"><span class="comment"># 这样其他机器访问本机的 80 自动映射到容器 80 服务</span></span><br><span class="line"><span class="comment"># docker run -d -p 80:80 --name webserver nginx </span></span><br><span class="line"><span class="comment"># --name 表示给容器起名，这里为 webserver</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止运行 Nginx 镜像的 webserver 容器</span></span><br><span class="line">docker stop webserver</span><br><span class="line"><span class="comment"># 或者用容器 Id 停止</span></span><br><span class="line">docker stop CONTAINER_ID</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器里运行 bash</span></span><br><span class="line">docker <span class="built_in">exec</span> -it f4e5 bash	<span class="comment"># 打开 f4e5 容器里的 bash 命令行界面</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器 ip</span></span><br><span class="line">docker inspect f4e5 | grep IPAddress</span><br></pre></td></tr></table></figure></div>
<h3 id="容器端口映射"><a href="#容器端口映射" class="headerlink" title="容器端口映射"></a>容器端口映射</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将本机 8080 端口映射到容器的 80 端口，-p 代表开放端口</span></span><br><span class="line">docker run -d -p 8080:80 hub.c.163.com/library/nginx</span><br><span class="line">netstat -na | grep 8080  // 可以检查本机端口状态</span><br><span class="line"><span class="comment"># 将本机随机的端口映射到容器的 80 和 443 端口</span></span><br><span class="line">docker run -d -P hub.c.163.com/library/nginx</span><br></pre></td></tr></table></figure></div>
<h3 id="容器运行-WAR-包"><a href="#容器运行-WAR-包" class="headerlink" title="容器运行 WAR 包"></a>容器运行 WAR 包</h3><p>这是我在一个项目里面用这种方式尝试过了，使用 <code>tomcat</code> 镜像运行出的容器，把本地的 <code>war</code> 包映射到容器 <code>tomcat</code> 里的 <code>ROOT</code> 目录，同时端口也要映射出来，最后可以通过外网访问。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">docker run -d -it -p 8089:8080 -v $(<span class="built_in">pwd</span>)/ROOT.war:/usr/<span class="built_in">local</span>/tomcat/webapps/ROOT.war -v $(<span class="built_in">pwd</span>)/ROOT:/usr/<span class="built_in">local</span>/tomcat/webapps/ROOT -v $(<span class="built_in">pwd</span>)/uploads:/usr/<span class="built_in">local</span>/webapps/uploads tomcat</span><br><span class="line"><span class="comment"># 1. 将本地 8089 映射到容器的 8080 端口,</span></span><br><span class="line"><span class="comment"># 2. 将本地磁盘的 ROOT.war 映射到容器里 tomcat 的 webapps 目录，</span></span><br><span class="line"><span class="comment"># 3. 将本地磁盘的 ROOT 目录，映射到容器里 tomcat 的 ROOT 目录，</span></span><br><span class="line"><span class="comment"># 4. 将本地磁盘的 uploads 目录，映射到容器里 tomcat 的 webapps/uploads 目录 (这是我们项目上传文件的地址)</span></span><br><span class="line"><span class="comment"># 5. 最后为镜像名称，如果为 163蜂巢的镜像名 则应改为蜂巢的镜像名</span></span><br><span class="line"><span class="comment"># -v : 为加载本地硬盘</span></span><br><span class="line"><span class="comment"># -it : 为执行容器里命令开启</span></span><br><span class="line"><span class="comment"># -i : --interactive 打开STDIN，用于控制台交互   </span></span><br><span class="line"><span class="comment"># -t : --tty 分配tty设备，该可以支持终端登录</span></span><br></pre></td></tr></table></figure></div>
<h3 id="制作自己的镜像"><a href="#制作自己的镜像" class="headerlink" title="制作自己的镜像"></a>制作自己的镜像</h3><p>这个是从构建文件制作自己的镜像的，主要是写 <code>Dockerfile</code>, 这个目前还涉及的较少，只写下基本的构建过程。主要分为 <code>Dockerfile</code> 编写 和 <code>build</code> 命令：</p>
<p><strong>Dockerfile</strong> </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">from hub.c.163.com/library/tomcat		<span class="comment"># 镜像从 tomcat 继承</span></span><br><span class="line">MAINTAINER jiyi xxx@163.com			<span class="comment"># 著作者名和邮箱</span></span><br><span class="line">COPY jpress.war  /usr/<span class="built_in">local</span>/tomcat/webapps	<span class="comment"># 镜像操作，这里将 jpress.war 放到 tomcat/webapps 目录下</span></span><br></pre></td></tr></table></figure></div>
<p>docker build <strong>[OPTIONS]</strong> <strong>[PATH]</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接在包含 Dockerfile 的当前目录 build</span></span><br><span class="line">docker build .</span><br><span class="line"><span class="comment"># 或者 -t 为生成的镜像配一个 tag 说明，这里 jpress 为名字，lastest 为 tag</span></span><br><span class="line"><span class="comment"># 注意还有一个 . 表示 [PATH]，这里还是指当前路径</span></span><br><span class="line">docker build -t jpress:latest .</span><br></pre></td></tr></table></figure></div>
<h2 id="私有仓库部署"><a href="#私有仓库部署" class="headerlink" title="私有仓库部署"></a>私有仓库部署</h2><p>很多公司里需要构建自己的私有仓库，因此这里也简单介绍下。</p>
<p>假设有两台机器: </p>
<p><strong>A: 192.168.31.115 (作为仓库)</strong></p>
<p><strong>B: 192.168.31.215 (提交镜像者)</strong></p>
<p><strong>(1). A: 下载仓库镜像</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure></div>
<p><strong>(2). A: 运行镜像</strong></p>
<p>应该将本地某个目录映射到 <code>/tmp/registry</code> 中以保存镜像，官方文档: <a href="https://docs.docker.com/registry/deploying/#customize-the-storage-location" target="_blank" rel="noopener">点我</a>，这里还是说下不同版本的 <code>registry</code> 镜像中仓库地址是不一样的：</p>
<ul>
<li>版本 1.0 的数据保存在 <strong><del>/tmp/registry</del></strong></li>
<li>版本 2.0 的数据存储在 <strong>/var/lib/registry</strong></li>
</ul>
<p>示例命令如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry registry</span><br></pre></td></tr></table></figure></div>
<p><strong>(3). B: 先下载一个小镜像</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">docker pull busybox</span><br></pre></td></tr></table></figure></div>
<p><strong>(4). B: 修改该镜像的 tag</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">docker tag busybox 192.168.31.115:5000/busybox</span><br></pre></td></tr></table></figure></div>
<p><strong>(5). B: 上传镜像</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">docker push 192.168.31.115:5000/busybox</span><br></pre></td></tr></table></figure></div>
<p>出现问题不能 https，官方说明配置:<a href="https://docs.docker.com/registry/insecure/" target="_blank" rel="noopener">https://docs.docker.com/registry/insecure/</a>，这里说下我自己尝试的方法：</p>
<p>如果是在 Mac 上操作的，直接在<code>docker</code> 图标的设置里添加 <code>Insecure-registry:192.168.31.115:5000</code>, 保存重启软件就可以了。</p>
<p>如果是 Linux 系统，则修改 Docker 的配置文件 <code>/etc/docker/daemon.json</code>, 如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"insecure-registries"</span> : [<span class="string">"myregistrydomain.com:5000"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>(6). B: 检查是否上传成功</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">curl -XGET http://registry:5000/v2/_catalog</span><br><span class="line">curl -XGET http://192.168.31.115:5000/v2/_catalog</span><br><span class="line">curl -XGET http://registry:5000/v2/image_name/tags/list</span><br><span class="line">curl -XGET http://192.168.31.115:5000/v2/192.168.31.115:5000/busybox/tags/list</span><br></pre></td></tr></table></figure></div>
<p>返回结果示例：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"repositories"</span>: [</span><br><span class="line">		<span class="string">"busybox"</span></span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="http://www.runoob.com/docker/" target="_blank" rel="noopener">http://www.runoob.com/docker/</a></li>
<li><a href="http://hub.docker.com" target="_blank" rel="noopener">http://hub.docker.com</a></li>
<li><a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a></li>
<li><a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">https://dev.aliyun.com</a></li>
<li><a href="http://c.163yun.com/hub" target="_blank" rel="noopener">http://c.163yun.com/hub</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>容器</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>Java synchronized 的用法</title>
    <url>/2016/09/01/java_synchronized/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">同步学习，才能不落伍</p>

<p>最近好好整理下 <code>Java</code> 方面的知识点，在练习到线程方面时，对同步方面的知识还是模糊不清的，于是开学今天好好地看了相关博客，下面仅仅记录下以备以后参考查询！</p>
<h2 id="一、同步、异步、synchronized"><a href="#一、同步、异步、synchronized" class="headerlink" title="一、同步、异步、synchronized"></a>一、同步、异步、synchronized</h2><p>首先我们先了解下什么是 <strong>同步</strong>、<strong>异步</strong> 与 <strong>synchronzied</strong>：</p>
<p><em>同步</em>：在计算机领域，指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去！</p>
<p><em>异步</em>：是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。</p>
<p><em>synchronized</em>: 是 <code>Java</code> 中的关键词，其意思也是同步，其主要用在多线程中需要同步的情况下！</p>
<a id="more"></a>
<h2 id="二、synchronized-用法"><a href="#二、synchronized-用法" class="headerlink" title="二、synchronized 用法"></a>二、synchronized 用法</h2><p>我先收集了实际应用过程中用到的写法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、修饰方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"><span class="comment">//2、修饰类内部this引用</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;&#125;</span><br><span class="line"><span class="comment">//3、修饰对象</span></span><br><span class="line"><span class="keyword">synchronized</span>(Obj1)&#123;&#125;</span><br><span class="line"><span class="comment">//4、修饰类</span></span><br><span class="line"><span class="keyword">synchronized</span>(A.class)&#123;&#125;</span><br></pre></td></tr></table></figure></div>
<p>我一开始的误区就是不知道同步的时候该用哪种写法，实际上 <code>synchronized</code> 的用法只有两种，主要分为：<strong>synchronized修饰方法</strong> 和 <strong>synchronized修饰代码块</strong>。上面第一种是修饰方法的，后三种都是修饰代码块的！下面将分别对这两种用法说明！</p>
<h3 id="1、synchronized-修饰方法"><a href="#1、synchronized-修饰方法" class="headerlink" title="1、synchronized 修饰方法"></a>1、synchronized 修饰方法</h3><p>下面用实例来说明：</p>
<p><em>情况1</em>：正常情况，未使用 <code>synchronized</code> 修饰</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="comment">//a方法没有加synchronized关键字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">5</span>;</span><br><span class="line">		<span class="keyword">while</span>(i--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread()+<span class="string">":a:"</span>+i);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">500</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> A ma=<span class="keyword">new</span> A();</span><br><span class="line">		<span class="comment">//下面两个线程分别在内部调用类A的对象ma的a方法</span></span><br><span class="line">		Thread thread1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				ma.a();<span class="comment">//线程1调用a方法</span></span><br><span class="line">			&#125;&#125;,<span class="string">"Thread1"</span>);</span><br><span class="line">		Thread thread2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				ma.a();<span class="comment">//线程2也调用a方法</span></span><br><span class="line">			&#125;&#125;,<span class="string">"Thread2"</span>);</span><br><span class="line">		thread1.start();</span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>输出结果：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">Thread1:a:<span class="number">4</span></span><br><span class="line">Thread2:a:<span class="number">4</span></span><br><span class="line">Thread2:a:<span class="number">3</span></span><br><span class="line">Thread1:a:<span class="number">3</span></span><br><span class="line">Thread2:a:<span class="number">2</span></span><br><span class="line">Thread1:a:<span class="number">2</span></span><br><span class="line">Thread1:a:<span class="number">1</span></span><br><span class="line">Thread2:a:<span class="number">1</span></span><br><span class="line">Thread2:a:<span class="number">0</span></span><br><span class="line">Thread1:a:<span class="number">0</span></span><br></pre></td></tr></table></figure></div>
<p>我们可以发现 <strong>未加同步</strong> 时，两个线程是互相交替执行 a 方法的，由于不同步所以类 A 的对象 ma 两个进程可同时访问，而哪个先执行由 <em>CPU</em> 自动调度！</p>
<p><em>情况2</em>：使用同步，<em>synchronized</em> 修饰方法</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">//a方法加了synchronized关键字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">5</span>;</span><br><span class="line">		<span class="keyword">while</span>(i--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			System.out.println(Thread.currentThread()+<span class="string">":a:"</span>+i);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">500</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> A ma=<span class="keyword">new</span> A();</span><br><span class="line">		<span class="comment">//下面两个线程分别在内部调用类A的对象ma的a方法</span></span><br><span class="line">		Thread thread1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				ma.a();<span class="comment">//线程1调用a方法</span></span><br><span class="line">			&#125;&#125;,<span class="string">"Thread1"</span>);</span><br><span class="line">		Thread thread2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				ma.a();<span class="comment">//线程2也调用a方法</span></span><br><span class="line">			&#125;&#125;,<span class="string">"Thread2"</span>);</span><br><span class="line">		thread1.start();</span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>输出结果为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">Thread1:a:<span class="number">4</span></span><br><span class="line">Thread1:a:<span class="number">3</span></span><br><span class="line">Thread1:a:<span class="number">2</span></span><br><span class="line">Thread1:a:<span class="number">1</span></span><br><span class="line">Thread1:a:<span class="number">0</span></span><br><span class="line">Thread2:a:<span class="number">4</span></span><br><span class="line">Thread2:a:<span class="number">3</span></span><br><span class="line">Thread2:a:<span class="number">2</span></span><br><span class="line">Thread2:a:<span class="number">1</span></span><br><span class="line">Thread2:a:<span class="number">0</span></span><br></pre></td></tr></table></figure></div>
<p>我们发现加了 <em>synchronized</em> 后，对象 <code>ma</code> 中的 <code>a</code> 方法变成了同步输出了，必须等到 <em>Thread1</em> 线程使用完 <code>ma</code> 对象后，<em>Thread2</em> 才能再使用 <code>ma</code> 对象。</p>
<p>实际上 <code>synchronized</code> 的同步就是 <strong>在类的对象上加上一把“锁”</strong>，当一个线程获得该对象就会立即锁定该对象，其他线程必须等待使用该对象的线程释放对象锁才能使用此对象资源！</p>
<p>也因此当 A 类中如果有多个加了 <code>synchronized</code> 的方法时，其他线程还是不能调用同步的方法，但是对于类A中没有加同步的方法，其他线程是可以调用的！也就是说 <strong>类中所有的同步方法同一时刻只能有一个线程访问，而非同步方法则允许多个线程访问</strong>。</p>
<h3 id="2、synchronized-修饰代码块"><a href="#2、synchronized-修饰代码块" class="headerlink" title="2、synchronized 修饰代码块"></a>2、synchronized 修饰代码块</h3><p>分别说明 <code>synchronized(this)</code>, <code>synchronized(Obj)</code>, <code>synchronized(A.class)</code> 三种使用情景。</p>
<h4 id="synchronized-this"><a href="#synchronized-this" class="headerlink" title="synchronized(this){}"></a>synchronized(this){}</h4><p>此用法效果和 <code>synchronized</code> 修饰方法的效果完全一样,只不过它是写在方法里面的！如下面例子的写法。</p>
<p>但这里要说明下 <code>this</code> 的含义，此 <code>this</code> <strong>不是指类A，而是指类A的对象</strong>！<code>synchronized(this)</code> 表示将本类的对象加锁同步！其原型应该是<code>synchronized(Obj)</code> 也就是下一个使用情景。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> i=<span class="number">5</span>;</span><br><span class="line">			<span class="keyword">while</span>(i--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				System.out.println(Thread.currentThread()+<span class="string">":a:"</span>+i);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">500</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="synchronized-Obj"><a href="#synchronized-Obj" class="headerlink" title="synchronized(Obj){}"></a>synchronized(Obj){}</h4><p>这一代码块修饰法是最特别也是与其他写法有最大不同的地方！</p>
<p>代码中 <em>Obj</em> 是一个对象，当是当前方法类本身的对象时，其用法就和<code>synchronized(this)</code> 完全一样，那当然也和 <code>synchronized</code> 修饰方法的情况用法一样。对于 <code>synchronized(this)</code> 和此写法关系，<strong>通常认为 <code>synchronized(this)</code> 是 <code>synchronized(Obj)</code> 的一个特例</strong>。</p>
<p>当 <em>Obj</em> 指代其他对象 ( 非本类对象 ) 时，那么它只限制 <em>Obj</em> 所指代的对象同步。此种情况的用法填补了前面几种方法 ( 包括 <code>synchronized(A.class)</code> ) 的缺陷，下面详细说明：</p>
<p><strong>synchronized 修饰方法和修饰本类对象的缺陷：当某个线程进入同步方法获得对象锁，那么其他线程访问这里对象的同步方法时，必须等待或者阻塞，这对高并发的系统是致命的，这很容易导致系统的崩溃。如果某个线程在同步方法里面发生了死循环，那么它就永远不会释放这个对象锁，那么其他线程就要永远的等待。这是一个致命的问题。</strong></p>
<p>例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Bclass:a!before"</span>);</span><br><span class="line">		SynObject so=<span class="keyword">new</span> SynObject();</span><br><span class="line">		so.testsy();	</span><br><span class="line">		System.out.println(<span class="string">"Bclass:a!after"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynObject</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testsy</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"SynObject:testsy!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>B 类里有多个同步方法 a, b, c 等，并且在 a 方法里 <code>SynObject so=new SynObject();</code> 实例化了类 SynObject 得到 so 对象，并调用了 <code>so.testsy();</code>。那么当某个线程进入了这个方法之后，这个对象其他同步方法都不能给其他线程访问了。假如这个方法需要执行的时间很长，那么其他线程会一直阻塞，影响到系统的性能。</p>
<p>如果这时用 <code>synchronized(Obj)</code> 来修饰代码块，修改后的代码如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Bclass:a!before"</span>);</span><br><span class="line">		SynObject so=<span class="keyword">new</span> SynObject();</span><br><span class="line">		<span class="keyword">synchronized</span>(so)&#123;<span class="comment">//只修饰so对象</span></span><br><span class="line">		    so.testsy();	</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"Bclass:a!after"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynObject</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testsy</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"SynObject:testsy!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>那么这个方法加锁的对象是 so 这个对象，跟执行这行代码的对象没有关系，当一个线程执行这个方法时，这对其他同步方法时没有影响的，因为他们持有的锁都完全不一样。</p>
<p>另外上面这个例子里面，B 类 a 方法中的第一句 <code>print</code> 语句在 <code>synchronized(Obj)</code> 代码块之前，也就是说外界阻塞也会在这句 <em>print</em> 语句打印完后才会阻塞进行同步。这我们应该感觉到与 <code>synchronized</code> 修饰方法的区别，<code>synchronized</code> 修饰方法会将整个方法内部所有语句都阻塞，而 <code>synchronized(Obj)</code> 只阻塞我们需要同步的类对象处！</p>
<h4 id="synchronized-A-class"><a href="#synchronized-A-class" class="headerlink" title="synchronized(A.class){}"></a>synchronized(A.class){}</h4><p>此用法实际上是为静态方法实现 <code>synchronized</code> 代码块而使用的，直接给大家一个类比：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a1</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(C.class)&#123;</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(C.class)&#123;</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>a1 方法与 a2 方法效果一样，而 b1, b2, c 的效果也是一样的，</p>
<p>对于 <code>synchronized(C.class)</code> 只要在方法中申名，不管方法前面加没加 <code>static</code> 其意义都是和加了 <code>static</code> 一样的！</p>
<p>普通方法通过 <code>synchronized(C.class)</code> 可以转化为静态同步方法，而静态方法不能通过 <code>synchronized(this)</code> 转化为普通同步方法。</p>
<p>普通方法的同步与静态方法的同步互不冲突。也就是说 <em>Thread1</em> 获得该类的一个对象并调用了 a1 方法，Thread2 线程则不能调用 a1, a2 方法，但是可以调用 b1, b2, c 方法！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个类的对象锁和另一个类的对象锁是没有关联的，当一个线程获得 <em>A</em> 类的对象锁时，它同时也可以获得 <em>B</em> 类的对象锁。</p>
<p>判断哪些方法可以调用，哪些资源可以访问主要看 <code>synchronized</code> 修饰的是什么！我画了张图仅供参考：</p>
<p><img src="http://img.godjiyi.cn/synchronize_kind.jpg" alt="synchronized分类图"></p>
<p>如果还是很难理解，<a href="http://www.cnblogs.com/GnagWang/archive/2011/02/27/1966606.html" target="_blank" rel="noopener">http://www.cnblogs.com/GnagWang/archive/2011/02/27/1966606.html</a> 这里面有例子大家可以参考看下！</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka</title>
    <url>/2018/08/04/kafka/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">分布式消息系统，解耦模块的桥梁</p>

<p><strong><a href="http://kafka.apache.org/" target="_blank" rel="noopener">Kafka</a></strong> 是一个基于 <strong>发布-订阅</strong> 的分布式消息系统，主要面向于大数据应用场景。它最初由 <em>LinkedIn</em> 公司开发，之后成为 <em>Apache</em> 项目的一部分。<strong>Kafka</strong> 是一种快速、可扩展、本身就专注于分布式的、实时消息流系统。<strong>Kafka</strong> 在2010 年正式向 <em>Apache</em> 社区开源，目前社区活跃。目前在互联网公司使用非常广泛，已经成为大数据分析的基础服务。</p>
<a id="more"></a>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>Kafka 是众多消息系统中的一种实现方式，那我们为什么需要用到 <strong>消息系统</strong> ？这里我列出以下几种在业务中常常碰到的场景，分别从 <strong>系统架构视角</strong>、<strong>消息传播视角</strong>、<strong>消息处理视角</strong>、<strong>自身系统结构视角</strong> 共四个角度的应用场景来说明：</p>
<!-- more -->
<h3 id="模块解耦"><a href="#模块解耦" class="headerlink" title="模块解耦"></a>模块解耦</h3><blockquote>
<p>从系统架构视角看</p>
</blockquote>
<p>这个我想是最明显的一点了，在业务系统上通常会存在一些系统产生数据，一些系统消费数据，这实际上就是 <strong>生产者–消费者</strong> 模式。这里的解耦是什么意思呢？我把消息系统独立出来了，那我的消息系统则会依赖生产者系统，消费系统则会依赖消息系统，不是多出了两个依赖，何为 <strong>解耦</strong> 呢？</p>
<p>这里的解耦实际上是解耦 <strong>不等速率依赖</strong> (这个名词是我造的，纯属个人观点)。也就是说生产者系统和消费者系统之间会有 <em>生产和消费速度不一致</em> 而导致消息丢失的情况。而消息系统与生产者系统、消息系统与消费者系统之间则没有这种情况，即使有也不会造成消息丢失(只会暂存下来)。因此，破除了生产者系统和消费者系统的依赖关系就叫 <strong>解耦</strong>，而消息系统正是为此而生。</p>
<h3 id="异步通信-缓冲队列"><a href="#异步通信-缓冲队列" class="headerlink" title="异步通信/缓冲队列"></a>异步通信/缓冲队列</h3><blockquote>
<p>从消息传播视角看</p>
</blockquote>
<p>很多时候，或并发达到一定量级的时候，系统是不能完全提供 <strong>实时消息</strong> 处理的能力的。这时不能立即处理的消息我们必须把这些请求放入 <strong>缓冲队列</strong> 中以等待处理。这种场景在一个公司中可能会有多种业务都会涉及到，因此，领先者们自然想到可以将缓冲队列设计成一个独立的平台，以满足各种业务的接入，从而，<strong>消息系统作为缓冲异步队列轰然降临</strong>。</p>
<p>这里我使用的是 <strong>缓冲</strong> 队列而非 <strong>缓存</strong> 队列，主要是因为通常我们所说的缓存都是基于内存的，而 <strong>缓冲</strong> 则更普遍一点，你可以让它基于内存，也可以让它基于 <strong>硬盘</strong> 的。通常消息系统基本上都是基于硬盘存储的，包括 Kafka 其也是持久化到硬盘的。</p>
<p>那 <strong>缓冲队列</strong> 与我们的 <strong>Redis/Memcached 缓存</strong> 或者 <strong>DB 数据库</strong> 有什么区别呢，为什么不用 Redis/Memcached 或者 DB 实现 <strong>缓冲</strong> 功能呢？</p>
<p>这里我也大概谈下自己的看法：</p>
<ol>
<li>先说 <em>基于内存的缓存</em> 吧，缓存的出现都是为了用昂贵的内存代价换来性能上的提升的，缓存通常是暂存那些常被访问的数据以提升较好的用户体验而设计，我们的 <strong>消息系统</strong> 并不是为了 <strong>快</strong>，而是为了 <strong>数据完整性，不丢失</strong> 而作的缓冲设计。因此，我们无需用如此昂贵的内存来作为消息系统的存储介质。另外一点就是缓冲的队列有可能会很大，达到<strong>千万甚至更多级别</strong>，这样如果用内存，那么代价就更昂贵了。</li>
<li>再说 <em>DB 数据库</em>，上面讲了内存昂贵，那我用数据库总可以了吧！那我们还是先想想数据库的原生作用：数据库是为持久化，通常是恒久的持久化而生的，也就是数据存下去，基本就不用变了，只会少量的修改删除。我们再想想缓冲队列，它是为 <strong>临时存储</strong> 而生的。用持久化的数据库来存临时数据，那会造成频繁的增删操作，势必会给数据库带来极大的性能消耗。</li>
<li>总结下，缓冲队列目标是：<strong>数据完整性</strong> (而非存读的快速性，不是缓存)，<strong>临时存储能力</strong> (而非恒久持久性，不是数据库)。</li>
</ol>
<h3 id="数据一致性保障"><a href="#数据一致性保障" class="headerlink" title="数据一致性保障"></a>数据一致性保障</h3><blockquote>
<p>从消息处理视角看</p>
</blockquote>
<p>有些情况下，我们将数据提交给某个系统处理，有可能那个系统突然崩溃了，那传给它的数据就都覆灭了，这可是企业不能容忍的！因此，我们可以利用消息系统，作为临时备份处，将消息同时发送给消息系统以及那个处理系统，当处理系统处理成功后，发送确认操作让消息系统删除那条消息，也就是采用 “<strong>插入-获取-删除</strong>“ 范式。这样，假如处理系统崩溃，那数据仍然在消息队里中，重启处理系统就可以了。</p>
<p>这里，我们都是假设消息系统很可靠，比处理系统更可靠！为什么有这个依据呢？这实际上也是消息系统的另一大特性，就是可扩展性强，部分组件失效可容忍。</p>
<h3 id="可扩展性强，部分组件失效可容忍"><a href="#可扩展性强，部分组件失效可容忍" class="headerlink" title="可扩展性强，部分组件失效可容忍"></a>可扩展性强，部分组件失效可容忍</h3><blockquote>
<p>从自身结构视角看</p>
</blockquote>
<p>这部分的内容我们在后面几节进行说明。</p>
<h2 id="消息模式"><a href="#消息模式" class="headerlink" title="消息模式"></a>消息模式</h2><p>消息模式就是消息系统实现时需要考虑的业务场景中的不同情况。由于生产者(系统)和消费者(系统)都可能是多个，那么就会产生一些微妙的不同。这里我们只考虑它们都处理相同的消息。对于多个生产者而言，消息系统就是不断接受消息的一个存储域，因此没有什么不同。而对于多个消费者而言就会有两种情况了：</p>
<ol>
<li>一个消息只给一个消费者消费：这个是最常见的情况了，一个消息无法被重复消费的，因此这种情况对应到消息模式就是 <strong>点对点模式或者叫队列模式</strong>。</li>
<li>一个消息可以给多个消费者消费：这个情况类比订阅付费服务，比如我是一家报社，有很多人订阅了我的报纸，只要我这边有新报纸刊登，我就需要把这些新报纸寄送给每一个订阅的人。因此这种情况对应到消息模式就叫 <strong>发布/订阅模式</strong>。</li>
</ol>
<p>以上两种模式就是消息模式最常见的两种，所有的消息系统的实现都会考虑这两种模式的，因此大家在学习一个新的消息系统的时候就可以考虑这个消息系统 <strong>如何实现者两种情况的</strong>。对于 Kafka 我们会在下面讲到其对应的两种模式。</p>
<h2 id="平台对比"><a href="#平台对比" class="headerlink" title="平台对比"></a>平台对比</h2><p>消息系统目前最有名气的大概有四个：<strong>ActiveMQ</strong>、<strong>RabbitMQ</strong>、<strong>Kafka</strong>、<strong>RocketMQ</strong>. 它们的对比网上也应该有很多了，我就不一一列举了。</p>
<p>这里我将我之前做过的 PPT 拿过来放这里作下对比，我简单说明下：</p>
<ul>
<li>下图各个消息系统从左到右，支持的消息量级越来越大，<strong>ActiveMQ</strong> 最小，<strong>RocketMQ</strong> 最大；</li>
<li><strong>ActiveMQ、RabbitMQ</strong> 稳定性是相对较好的，<strong>RabbitMQ</strong> 稳定性更好同时数据安全性最高，如果对实时性、数据不允许丢失要求高时，可以用 <strong>RabbitMQ</strong>；</li>
<li><strong>RocketMQ</strong> 是阿里开源的，其处理量是最高的，但是生态比较少，因此若使用过程中出现问题，你只能找原开发者或维护者了；</li>
<li><strong>Kafka</strong> 是目前生态链最广、社区最活跃的消息系统了。但是其会存在消息丢失情况，通常应用在分布式日志消息处理等这些对消息丢失可容忍性的场景。目前，大数据已成主流的今天，<em>Kafka 也逐渐成为使用的主流消息系统</em>，因为大数据对消息丢失一般都是可容忍的，比如训练集中丢了几条数据等等，都是无相关的。而对于 <strong>支付、会员</strong> 等这些消息则不推荐用 Kafka ，可转用其他 MQ 系统。</li>
</ul>
<p><img src="img.godjiyi.cn/csdnblogdistribute_msg.jpg" alt></p>
<h2 id="宏观结构"><a href="#宏观结构" class="headerlink" title="宏观结构"></a>宏观结构</h2><p>下图是 Kafka 消息系统的 <strong>分布式宏观架构图</strong>，这里分别讲下各个组件的作用及其关系：</p>
<ol>
<li><em>Producer</em>: 数据的生产客户端，生产数据发送到 <strong>Kafka Cluster</strong>；</li>
<li><em>Zookeeper</em>: 负责整体集群的协调工作，保存 <strong>Broker</strong> 与 <strong>Consumer</strong> 交互的元信息，并进行数据变更监控；</li>
<li><em>Broker</em>: <strong>Broker</strong> 实际上就是单台服务器，其主要接收 <strong>Producer</strong> 和 <strong>Consumer</strong> 请求，持久化<strong>Message</strong>，其中会通过选举产生一个 <strong>Controller</strong>，来主持协调工作；</li>
<li><em>Kafka Cluster</em>: 由多个 <strong>Borker</strong> 和一套 <strong>Zookeeper</strong> 组成，<strong>Broker</strong> 之间无主从关系，地位平等，可任意增删节点，这主要由 <strong>Zookeeper</strong> 维护；</li>
<li><em>Consumer</em>: 数据的消费客户端，用于从 <strong>Broker</strong> 中订阅/拉取消息；</li>
</ol>
<p><img src="http://img.godjiyi.cn/csdnblog20180805003823.png" alt></p>
<h2 id="微观设计"><a href="#微观设计" class="headerlink" title="微观设计"></a>微观设计</h2><p>Kafka <strong>内部消息传递流程</strong> 如下图所示：</p>
<p><img src="http://img.godjiyi.cn/csdnblogkafka-arc.jpg" alt></p>
<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>一个 <strong>消息主题</strong>，也就是一个分布式业务消息队列。不同的生产者将不同的业务消息分发到不同的 <strong>topic</strong> 上，这样，消费者就可以根据 <strong>topic</strong> 进行对应的业务消息消费了。</p>
<h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p>这个就是 topic 分布式的体现，由于一个 topic 就是一个业务消息，这些消息可能会源源不断来，并且有可能会同时并发很大地进入队列，将这些消息合理地分布在分布式机器中则可以保证机器的负载均衡性，同时也可以使得不同的消费者可以同时拉取不同 partition 中的消息，可提升消费者并发性能，这里总结下 <strong>partition</strong> 特性：</p>
<ul>
<li>一个 <strong>topic</strong> 分成多个 <strong>partion</strong>；</li>
<li>多个 <strong>producer</strong> 生产消息可以并行入队，多个 <strong>Consumer</strong> 可并行消费；</li>
<li>同一个 <strong>partition</strong> 里保证消息有序, 不同 <strong>partition</strong> 则不能完全保证有序；</li>
</ul>
<h3 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h3><p>消费者组应该是 Kafka 最大的特色了，消费者组就是消费者组成的一个组，消费者在向 Kafka 拉取数据的时候需要提供一个组名，这个名称就是消费者组名，上面的两种消息模式都可以在消费者组中得到实现：</p>
<ol>
<li><em>点对点/队列模式</em>：一个消息只能被一个消费者消费，我们只需要将这些消费者放在同一个消费者组里就可以了，这样消费者在同一个组中，那么 topic 中的一条消息只会向一个消费者组发送一次；</li>
<li><em>发布-订阅模式</em>：一个消息可被多个消费者消费，这种情况，我们只需要将各个消费者放在各自单独的组中，各个组均订阅了此消息 topic 就可以了。</li>
</ol>
<p>这里还有如下注意点：</p>
<ul>
<li>一个消费组消费一个 <strong>topic</strong> 的全量数据；</li>
<li>组内消费者消费一个或多个 <strong>partition</strong> 数据，如果一个组里的消费者数量少于订阅的 topic 的 partition 数量，那么组中必有一个消费者要消费多个 partion 数据；</li>
<li>一个组里的消费者应小于等于 <strong>topic</strong> 的 <strong>partition</strong> 数量，这是因为一个 partition 最多只能与一个 consumer 连接，那么如果 partition 数量大于 consumer 数量，则必定有 consumer 是空闲的，因此尽量避免这种情况；</li>
</ul>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="http://opentsdb.net/docs/build/html/index.html" target="_blank" rel="noopener">http://opentsdb.net/docs/build/html/index.html</a></li>
<li><a href="http://liubin.org/blog/2016/03/05/tsdb-opentsdb/" target="_blank" rel="noopener">http://liubin.org/blog/2016/03/05/tsdb-opentsdb/</a></li>
<li><a href="https://www.jianshu.com/p/0bafd0168647" target="_blank" rel="noopener">https://www.jianshu.com/p/0bafd0168647</a></li>
<li><a href="http://www.nosqlnotes.com/technotes/opentsdb-tabledesign/" target="_blank" rel="noopener">http://www.nosqlnotes.com/technotes/opentsdb-tabledesign/</a></li>
</ul>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>Message</tag>
      </tags>
  </entry>
  <entry>
    <title>LAMP 以及 Tomcat 服务器环境搭建</title>
    <url>/2017/02/24/lamp/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">开源一族，与众不同</p>

<p>最近频繁使用服务器环境，以前也搭建过，但那些命令以及配置都不能铭记于心，因此今天借此记录下，以便于以后参考。记录主要有：<strong>LAMP</strong> ( <em>Linux, Apache, Mysql, Php</em> ) 以及 <strong>Git</strong>, <strong>Java</strong>, <strong>Tomcat</strong>, <strong>Ftp</strong> 等安装命令及配置过程。</p>
<div align="center"><br><img src="http://img.godjiyi.cn/lamp.jpg" align="center"><br></div>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>作为程序员，对于服务器的部署还是有必要会的，因为这决定了自己独立的高度。目前而言，服务器操作系统性能最好的还是 Linux，不要说自己不会，没有不会的程序员，只有懒惰的程序员。</p>
<p>对于 <strong>Linux</strong> 系统的学习最容易上手的还是 <strong>Ubuntu</strong> 桌面版了，因为它有 Windows 版的界面，可以给新手一个过渡阶段，之后再上手到只有命令端的 <strong>Linux Server</strong> 版就容易多了。</p>
<p>这里给 <a href="http://www.kancloud.cn/explore" target="_blank" rel="noopener">看云</a> 上的两个学习文档：<a href="http://www.kancloud.cn/you23hai45/linux-space/108213" target="_blank" rel="noopener">Linux学习</a>; <a href="http://www.kancloud.cn/thinkphp/linux-command-line/39431" target="_blank" rel="noopener">The Linux Command Line 中文版</a></p>
<a id="more"></a>
<h2 id="LAMP-搭建"><a href="#LAMP-搭建" class="headerlink" title="LAMP 搭建"></a>LAMP 搭建</h2><hr>
<p><strong>Linux</strong> 系统环境选择的是 <em>Ubuntu 14.04</em>；</p>
<p>对于 <em>Ubuntu 16.04</em> 其内置的下载源和 14.04 的不一致，网上很多教程都不适用，建议大家选择 <em>Ubuntu 14.04</em> 测试。</p>
<h3 id="一、安装-MySQL"><a href="#一、安装-MySQL" class="headerlink" title="一、安装 MySQL"></a>一、安装 MySQL</h3><p>安装 <strong>mysql</strong> 服务器端:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server mysql-client</span><br></pre></td></tr></table></figure></div>
<p>检查 <strong>mysql</strong> 服务是否开启，看到 <code>LISTEN</code> 就代表开启了:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure></div>
<p>如果没开启，可用以下的命令 <strong>开启/停止/重启/查看状态</strong> :</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo service mysql start/stop/restart/status</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">sudo /etc/init.d/mysql start/stop/restart/status</span><br><span class="line"><span class="comment"># service 命令就是在 /etc/init.d 下搜寻命令执行的，两者效果一样的</span></span><br></pre></td></tr></table></figure></div>
<h3 id="二、安装-Apache"><a href="#二、安装-Apache" class="headerlink" title="二、安装 Apache"></a>二、安装 Apache</h3><p>安装 Apache，现在最新版本为第二版，因此通常用 Apache2</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br></pre></td></tr></table></figure></div>
<p><strong>启动/停止/重启/状态</strong> 命令:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo service apache2 start/stop/restart/status</span><br></pre></td></tr></table></figure></div>
<p>配置文件在 <code>/etc/apache2</code> :</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">apache2.conf			<span class="comment"># 主配置文件</span></span><br><span class="line">ports.conf;			<span class="comment"># 端口配置文件</span></span><br><span class="line">sites-available/		<span class="comment"># 存储多个站点的目录</span></span><br><span class="line">sites-enabled/ 		<span class="comment"># 存储已开启的站点的目录( 从 available 中选择的 )</span></span><br><span class="line">mods-available/ 		<span class="comment"># 存储多个模块的目录</span></span><br><span class="line">mods-enabled/ 		<span class="comment"># 存储已开启的模块的目录</span></span><br><span class="line">conf-available/ 		<span class="comment"># 存储多种配置的目录</span></span><br><span class="line">conf-enabled/ 		<span class="comment"># 存储已经开启的配置的目录</span></span><br><span class="line">magic;</span><br><span class="line">envvars;</span><br></pre></td></tr></table></figure></div>
<p>配置站点常常需要修改之处(不一定都需要修改，可按照自己的环境来配置操作)：</p>
<p>修改 <strong>apache2.conf</strong>, 以防出现权限不够：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/apache2</span><br><span class="line">sudo vi apache2.conf		</span><br><span class="line"><span class="comment"># 主要修改下面这些</span></span><br><span class="line">&lt;Directory /var/www/&gt;</span><br><span class="line">	Options Indexes FollowSymLinks</span><br><span class="line">	AllowOverride None 		<span class="comment"># 修改为 AllowOverride All</span></span><br><span class="line">	Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure></div>
<p>修改主项目地址：<code>/etc/apache2/sites-enable/000-default.conf</code> 如下:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/apache2/sites-enable</span><br><span class="line">sudo vi 000-default.conf</span><br><span class="line"><span class="comment"># 将DocumentRoot /var/www 修改为 DocumentRoot /var/www/laravel</span></span><br></pre></td></tr></table></figure></div>
<p>对于项目根目录权限问题:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux 的 apache 用户组是 www-data</span></span><br><span class="line"><span class="comment"># -R 代表递进目录</span></span><br><span class="line">sudo chown -R :www-data /var/www/laravel </span><br><span class="line"><span class="comment"># mac 下的 Apache 用户组是 _www</span></span><br><span class="line">sudo chown -R :_www /var/www/laravel</span><br><span class="line">sudo chmod -R 776 /var/www/laravel/storage</span><br><span class="line">sudo chmod -R 776 /var/www/laravel/vendor</span><br><span class="line">sudo chmod -R 776 /var/www/laravel/bootstrap</span><br></pre></td></tr></table></figure></div>
<p>配置 <strong>多个站点</strong>，通过不同端口访问:</p>
<p>假设 <code>/var/www</code>下放置了 <code>laravel</code> 和 <code>html</code>两个项目,</p>
<p>在 <code>sites-available</code> 目录下复制 <strong>000-default.conf</strong> :</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/apache2/sites-available</span><br><span class="line">sudo cp 000-default.conf htmltest.conf</span><br><span class="line">sudo vi htmltest.conf</span><br><span class="line"><span class="comment"># 主要编辑端口号和项目地址</span></span><br><span class="line"><span class="comment"># 端口：&lt;VirtualHost *:80&gt; 可改为 &lt;VirtualHost *:8090&gt;</span></span><br><span class="line"><span class="comment"># 项目地址：DocumentRoot /var/www/laravel 可改为 DocumentRoot /var/www/html</span></span><br></pre></td></tr></table></figure></div>
<p>在 <code>sites-enable</code> 目录下软连接到 <strong>sites-available/htmltest.conf</strong> :</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用刚刚配置的项目</span></span><br><span class="line"><span class="built_in">cd</span> /etc/apache2/sites-enable</span><br><span class="line">sudo ln -s ../sites-available/htmltest.conf ./htmltest.conf</span><br></pre></td></tr></table></figure></div>
<p>增加监听端口如下:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/apache2</span><br><span class="line">sudo vi ports.conf</span><br><span class="line"><span class="comment"># 添加如下</span></span><br><span class="line">Listen 8090</span><br></pre></td></tr></table></figure></div>
<p>重启服务器，访问，如果有权限问题按照上面权限方法设置:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo service apache2 restart</span><br><span class="line"><span class="comment"># 两个项目</span></span><br><span class="line"><span class="comment"># 第一个是默认配置的: http://ip</span></span><br><span class="line"><span class="comment"># 第二个是刚刚配置的: http://ip:8090</span></span><br></pre></td></tr></table></figure></div>
<h3 id="三、安装-php-以及相关模块"><a href="#三、安装-php-以及相关模块" class="headerlink" title="三、安装 php 以及相关模块"></a>三、安装 php 以及相关模块</h3><p>安装 <strong>php5</strong> ( Ubuntu 14.04 )</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install php5 libapache2-mod-php5</span><br></pre></td></tr></table></figure></div>
<p>安装 <strong>php7</strong> ( Ubuntu 16.04 )</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install php7.0 libapache2-mod-php7.0</span><br></pre></td></tr></table></figure></div>
<p>安装相关模块 ( 包括 php 与 mysql 等数据相关包)( Ubuntu 14.04 ):</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install php5-mysql php5-curl php5-gd php5-intl php-pear php5-imagick php5-imap php5-mcrypt php5-memcache php5-ming php5-ps php5-pspell php5-recode php5-snmp php5-sqlite php5-tidy php5-xmlrpc php5-xsl</span><br></pre></td></tr></table></figure></div>
<h3 id="四、Apache权限"><a href="#四、Apache权限" class="headerlink" title="四、Apache权限"></a>四、Apache权限</h3><p>对项目目录执行:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 /var/projectname</span><br></pre></td></tr></table></figure></div>
<h2 id="Tomcat以及其他软件配置安装"><a href="#Tomcat以及其他软件配置安装" class="headerlink" title="Tomcat以及其他软件配置安装"></a>Tomcat以及其他软件配置安装</h2><hr>
<h3 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h3><p>这方面也是很基础的安装配置，包括 jdk, tomcat 配置, git 设置</p>
<p>其他管理软件如 samba, ftp 远程连接软件</p>
<p><strong>[2017.5.3日更新]</strong> 我将用到的软件放在了 <code>gitosc</code> 上，因为 <code>gitosc</code> 支持二进制文件，因此可以当网盘用了.大家可以用 <code>git</code> 直接 clone 该项目，就无需再去寻找软件包了。项目地址：<a href="https://git.oschina.net/jiyiren/linuxfile" target="_blank" rel="noopener">https://git.oschina.net/jiyiren/linuxfile</a> </p>
<h3 id="二、JDK8-安装"><a href="#二、JDK8-安装" class="headerlink" title="二、JDK8 安装"></a>二、JDK8 安装</h3><p>官网：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">下载jdk8</a> 或者 git 项目地址：<a href="https://git.oschina.net/jiyiren/linuxfile" target="_blank" rel="noopener">https://git.oschina.net/jiyiren/linuxfile</a> </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载Linux版本到本地</span></span><br><span class="line">jdk-8u121-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></div>
<p>将 jdk 上传到服务器，这可以有多种方法，可以用 <strong>FileZilla</strong>，也可以用 FTP，或者找到一个链接地址，用 <code>wget</code> 在服务器上直接下载。我是使用 <strong>FileZilla</strong>上传的!</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设我们放在用户当前目录下</span></span><br><span class="line">~/jdk-8u121-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></div>
<p>解压到 <code>/opt</code> 目录下或者 <code>/usr/local</code>, 这里我解压到 <code>/opt</code> 下:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设 jdk-8u121-linux-x64.tar.gz 在用户~目录下</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">sudo tar -xzvf jdk-8u121-linux-x64.tar.gz -C /opt/</span><br><span class="line">	</span><br><span class="line"><span class="comment"># zip 格式的则用如下命令</span></span><br><span class="line">sudo unzip jdk.zip -d /opt/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改解压后的目录名称</span></span><br><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">mv jdk1.8.0_121 jdk8</span><br></pre></td></tr></table></figure></div>
<p>添加环境变量:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">vi .bashrc</span><br><span class="line"><span class="comment"># 添加下面</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/jdk8</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib:<span class="variable">$JRE_HOME</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">source</span> .bashrc	<span class="comment"># 环境变量生效</span></span><br><span class="line">java -version		<span class="comment"># 看到版本信息即可</span></span><br></pre></td></tr></table></figure></div>
<h3 id="三、Tomcat安装"><a href="#三、Tomcat安装" class="headerlink" title="三、Tomcat安装"></a>三、Tomcat安装</h3><p>下载 <strong>Tomcat</strong>, 这里可以像上面安装 jdk 一样，先去 <a href="http://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">官网</a>下载到本地再上传到服务器;当然也可以直接用前面提到的用 <strong>wget</strong> 方式下载。</p>
<p>大家在点击官网下载时会获得一个下载链接，这是只要在服务器上用 <strong>wget</strong> 下载就行了(注下载链接可能会失效的，因此建议通过 <code>git</code> 项目下载这些文件 <a href="https://git.oschina.net/jiyiren/linuxfile" target="_blank" rel="noopener">https://git.oschina.net/jiyiren/linuxfile</a> )：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.11/bin/apache-tomcat-8.5.11.tar.gz</span><br><span class="line"><span class="comment"># 如果提示没有wget,则按照提示安装wget即可</span></span><br></pre></td></tr></table></figure></div>
<p>添加环境变量:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压文件到/opt/</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">sudo tar -xzvf apache-tomcat-8.5.11.tar.gz -C /opt</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 修改名称，这个随便自己的，我感觉文件名太长了</span></span><br><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">mv apache-tomcat-8.5.11 tomcat8</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 添加环境变量</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">vi .bashrc</span><br><span class="line"><span class="comment"># 添加如下行</span></span><br><span class="line"><span class="built_in">export</span> PATH=/opt/tomcat8/bin:<span class="variable">$PATH</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># 使环境变量立即生效</span></span><br><span class="line"><span class="built_in">source</span> .bashrc</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 检测是否设置成功</span></span><br><span class="line"><span class="built_in">which</span> startup.sh</span><br><span class="line"><span class="comment"># 如果输出如下就可以了</span></span><br><span class="line">/opt/tomcat8/bin/startup.sh</span><br></pre></td></tr></table></figure></div>
<p><strong>开启/关闭</strong> tomcat 服务器</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启或关闭</span></span><br><span class="line">startup.sh/shutdown.sh</span><br><span class="line"><span class="comment"># 检查是否开启，用浏览器访问 ip:8080 出现 Tomcat 页面就可以了</span></span><br><span class="line"><span class="comment"># 如果发现 shutdown.sh 出错，说明 tomcat 没启动成功，需要查看 tomcat 进程，并结束</span></span><br><span class="line">ps -ef|grep tomcat</span><br><span class="line"><span class="built_in">kill</span> -9 [pid]</span><br></pre></td></tr></table></figure></div>
<p>配置项目根目录，<strong>Tomcat</strong> 项目目录默认在 <code>webapps</code> 目录下，多个项目只要放在里面即可，访问的时候：<em>ip:端口/projecName/</em> 即可访问项目根目录。( 默认端口是 <strong>8080</strong> )</p>
<p>但是如果想将我们的项目放在根目录呢？一种就是将 <em>webapps/ROOT</em> 目录覆盖，另外一种就是修改配置文件，这里介绍修改配置文件 <strong>server.xml</strong> 方法。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 到配置目录修改配置文件server.xml</span></span><br><span class="line"><span class="built_in">cd</span> /opt/tomcat8/conf</span><br><span class="line">vi server.xml</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 在含有 appBase="webapps" 的 &lt;host&gt;&lt;/host&gt; 之间添加如下</span></span><br><span class="line">&lt;Context path=<span class="string">""</span> docBase=<span class="string">"/opt/tomcat8/webapps/htmltest/"</span> debug=<span class="string">"0"</span>/&gt;</span><br><span class="line"><span class="comment"># 如上，根目录设置在 /opt/tomcat8/webapps/htmltest/</span></span><br></pre></td></tr></table></figure></div>
<h3 id="四、git-安装"><a href="#四、git-安装" class="headerlink" title="四、git 安装"></a>四、git 安装</h3><p>安装</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure></div>
<p>通常经过上面安装的 <code>git</code> 版本是 <em>1.9.1</em> 版本，现在已经到 <em>2.11</em> 了，旧版本有不支持的命令，因此要装比较新的版本</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先更新下源，不然会有不识别提示</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-add-repository ppa:git-core/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git</span><br><span class="line">git --version</span><br><span class="line"><span class="comment"># 此时将显示更高级的或者最新的版本</span></span><br></pre></td></tr></table></figure></div>
<h3 id="五、ftp安装"><a href="#五、ftp安装" class="headerlink" title="五、ftp安装"></a>五、ftp安装</h3><p>这里安装 vsftpd :</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装，并检测</span></span><br><span class="line">sudo apt-get install vsftpd</span><br><span class="line">vsftpd -version</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 新建一个文件夹用于FTP的工作目录</span></span><br><span class="line">mkdir /home/ftp</span><br></pre></td></tr></table></figure></div>
<p>新建 FTP 用户并设置密码以及工作目录:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo useradd -d /home/ftp -s /bin/bash jiyiren</span><br><span class="line"><span class="comment"># -d 代表 ftp 的主目录</span></span><br><span class="line"><span class="comment"># jiyiren为 你为该 ftp 创建的用户名</span></span><br></pre></td></tr></table></figure></div>
<p>为新用户设置密码:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">passwd jiyiren</span><br><span class="line"><span class="comment"># 可用cat etc/passwd 可以查看当前系统用户</span></span><br></pre></td></tr></table></figure></div>
<p>修改 vsftpd 配置文件:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/vsftpd.conf</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 修改如下两处</span></span><br><span class="line">seccomp_sandbox=NO</span><br><span class="line">local_enable=YES</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 并添加如下行到结尾</span></span><br><span class="line">userlist_deny=NO</span><br><span class="line">userlist_enable=YES </span><br><span class="line">userlist_file=/etc/allowed_users</span><br></pre></td></tr></table></figure></div>
<p>添加允许用户列表:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/allowed_users</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 添加以下用户名</span></span><br><span class="line">jiyiren</span><br><span class="line">root</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 另外可查看 /etc/ftpusers 是否有用户名，无则直接退出，这是禁止用户列表</span></span><br></pre></td></tr></table></figure></div>
<p><strong>开启/关闭/重启</strong> ftp 服务</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo service vsftpd start/stop/restart</span><br></pre></td></tr></table></figure></div>
<p>登录，Windows 可以用 <strong>WinSCP</strong> 软件或者前面提到的 <strong>FileZilla</strong> 软件，而 Linux 或者 Unix ( mac ) 可以使用如下命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">ftp jiyiren@ip</span><br><span class="line"><span class="comment"># 输入密码即可</span></span><br></pre></td></tr></table></figure></div>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.kancloud.cn/you23hai45/linux-space/108213" target="_blank" rel="noopener">Linux 学习</a></li>
<li><a href="http://www.kancloud.cn/thinkphp/linux-command-line/39431" target="_blank" rel="noopener">The Linux Command Line 中文版</a></li>
<li><a href="http://www.linuxidc.com/Linux/2016-01/127180.htm" target="_blank" rel="noopener">Ubuntu 下 LAMP 环境搭建</a></li>
<li><a href="http://www.linuxidc.com/Linux/2016-12/138563.htm" target="_blank" rel="noopener">Ubuntu 下搭建 FTP 服务器图解</a></li>
<li><a href="http://jingyan.baidu.com/article/67508eb4d6c4fd9ccb1ce470.html" target="_blank" rel="noopener">vsftpd 的安装和配置</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Linux</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenTSDB 存储结构</title>
    <url>/2018/07/03/opentsdb-store/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">时序处理数据库，更快的存储和聚合</p>

<p><strong>OpenTSDB</strong> 是为存储时序数据而设计的，它基于 <strong>HBase</strong> 存储数据，充分发挥了 <strong>HBase</strong> 的分布式列存储特性，支持数百万每秒的读写，支持千万数目的 <strong>Metric</strong>，它的特点就是容易扩展，具有灵活的 <em>Tag</em> 机制。其主要用途，就是做监控系统，譬如收集大规模集群（ 包括网络设备、操作系统、应用程序 ）的 <strong>监控数据</strong> 并进行存储和聚合查询，在目前的 <strong>IoT</strong> 方面具有很大的应用价值。</p>
<a id="more"></a>
<h2 id="Hbase-Schema"><a href="#Hbase-Schema" class="headerlink" title="Hbase Schema"></a>Hbase Schema</h2><p><strong>OpenTSDB</strong> 是基于 <strong>Hbase</strong> 存储系统的，主要利用了 Hbase <strong>数据自动排序</strong> 以及 <strong>可靠的分布式特性</strong>。 <strong>OpenTSDB</strong> 在安装启动时，默认在 <strong>Hbase</strong> 里面创建 <strong>四张</strong> 表。分别为：</p>
<ol>
<li><em>tsdb</em>: 存储数据点表，也就是存储实际的时序数据，绝大部分的数据是存在这个表中；</li>
<li><em>tsdb-uid</em>: 存储 <strong>name</strong> 和 <strong>uid</strong> 的映射关系，也就是给字符串的键、值映射成数值，通常包括 <strong>metric</strong>、<strong>tagk</strong>、<strong>tagv</strong> 等字符串映射。</li>
<li><em>tsdb-meta</em>: 元数据表，这个只有通过配置文件开启才会存储数据的，默认不开启。如果开启了存储的就是你传过来的<strong>完整的 json 格式数据</strong>，没有经过解析的，这就是元数据。</li>
<li><em>tsdb-tree</em>: 树形表，这个也是只有开启配置文件选项才能使用，开启后可以由自己创建和管理自己的树形 <strong>metric</strong> 结构，需要自己设计管理的。</li>
</ol>
<p>下面主要说明下 <em>tsdb</em> 和 <em>tsdb-uid</em> 的表结构。</p>
<h2 id="UID-Table-Schema"><a href="#UID-Table-Schema" class="headerlink" title="UID Table Schema"></a>UID Table Schema</h2><p>这里我们主要分析下 OpenTSDB 存储 <strong>UID</strong> 的表 – <strong>tsdb-uid</strong>。</p>
<p>首先，看下 <em>tsdb-uid</em> 的表结构。其存储的是字符串到 <strong>UID</strong> 的映射关系。</p>
<p>我们可以通过 <code>hbase shell</code> 通过 <strong>Hbase</strong> 访问数据库入口查看小 <em>tsdb-uid</em> 的表结构：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">list <span class="string">'tsdb-uid'</span></span><br><span class="line"><span class="comment"># == 结果如下 ==</span></span><br><span class="line">Table tsdb-uid is ENABLED                                                                                                                                     </span><br><span class="line">tsdb-uid                                                                                                                                                      </span><br><span class="line">COLUMN FAMILIES DESCRIPTION                                                                                                                                   </span><br><span class="line">&#123;NAME =&gt; <span class="string">'id'</span>, BLOOMFILTER =&gt; <span class="string">'ROW'</span>, VERSIONS =&gt; <span class="string">'1'</span>,... &#125;                                               </span><br><span class="line">&#123;NAME =&gt; <span class="string">'name'</span>, BLOOMFILTER =&gt; <span class="string">'ROW'</span>, VERSIONS =&gt; <span class="string">'1'</span>,... &#125;                                             </span><br><span class="line">2 row(s) <span class="keyword">in</span> 0.0360 seconds</span><br></pre></td></tr></table></figure></div>
<p>上面结果我只列出了少量信息，主要看 <em>NAME</em> 就可以了，表示该表的 <strong>Column Family</strong>, 分别为 <em>name</em> 列族和 <em>id</em> 列族。那具体怎么将字符串映射为 <strong>UID</strong> ? 这里就需要通过实际的例子来说明。</p>
<p>我们先上传一个数据，格式内容如下，可以通过 <strong>Postman</strong> 进行上传测试，<strong>OpenTSDB</strong> 默认上传地址为 <code>http://ip:4242/api/put?details</code>，后缀 <em>details</em> 是为了查看上传反馈。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"metric"</span>: <span class="string">"sys.test.metric"</span>,</span><br><span class="line">        <span class="attr">"timestamp"</span>: <span class="number">1528784369</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="attr">"tags"</span>: &#123;</span><br><span class="line">           <span class="attr">"hostname"</span>: <span class="string">"jiyiren"</span>,</span><br><span class="line">           <span class="attr">"area"</span>: <span class="string">"shanghai"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>
<p>上传成功后返回：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"success"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"errors"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>我们先看下我们上传的数据格式，需要进行映射的字符串是对应 <code>metric</code>, <code>tagkey</code>, <code>tagvalue</code> 的，这里 <code>tag</code> 有两组，所以要映射的有 5 个字符串，分别为： <em>sys.test.metric</em>, <em>hostname</em>, <em>jiyiren</em>, <em>area</em>, <em>shanghai</em>.</p>
<p>那我们就再用 <strong>Hbase Shell</strong> 查看表内容：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">scan <span class="string">'tsdb-uid'</span></span><br><span class="line"><span class="comment"># === 结果如下 ===</span></span><br><span class="line">ROW                                      COLUMN+CELL </span><br><span class="line">\x00\x00\x01  column=name:metrics, timestamp=1528517476774, value=sys.test.metric</span><br><span class="line">\x00\x00\x01  column=name:tagk, timestamp=1528517476790, value=area </span><br><span class="line">\x00\x00\x01  column=name:tagv, timestamp=1528517476803, value=shanghai</span><br><span class="line">\x00\x00\x02  column=name:tagk, timestamp=1528517476816, value=hostname                                              </span><br><span class="line">\x00\x00\x02  column=name:tagv, timestamp=1528517476830, value=jiyiren </span><br><span class="line">area      column=id:tagk, timestamp=1528517476793, value=\x00\x00\x01</span><br><span class="line">hostname  column=id:tagk, timestamp=1528517476819, value=\x00\x00\x02</span><br><span class="line">jiyiren   column=id:tagv, timestamp=1528517476832, value=\x00\x00\x02</span><br><span class="line">shanghai  column=id:tagv, timestamp=1528517476806, value=\x00\x00\x01</span><br><span class="line">sys.test.metric column=id:metrics, timestamp=1528517476778, value=\x00\x00\x01</span><br></pre></td></tr></table></figure></div>
<p>从中我们可以看到，数据总是成对出现的，包括 <strong>UID 映射字符串</strong> 和 <strong>字符串映射 UID</strong>。上面 5 组是 <strong>UID</strong> 映射成字符串，下面 5 组是字符串映射为 <strong>UID</strong>. 前面已经看过 <strong>tsdb-uid</strong> 表有两个列族，而其中的 <code>name</code> 列族对应的就是 <strong>UID</strong> 映射成字符串，而 <code>id</code> 列族对应字符串映射为 <strong>UID</strong>, 这正是这两个列族的作用，这样对于正反查找速度都是极快的。</p>
<p>此外，对于 <strong>UID 映射字符串</strong>的，每行数据，也就是 <code>rowkey</code> 相同的，至少包含三个列，分别是 <code>metrics</code>, <code>tagk</code>, <code>tagv</code>. 我们可以通过前三行结果看出。</p>
<p>到这里我们知道了 <strong>UID</strong> 与字符串间是怎么映射以便于查询的，但是 <strong>UID</strong> 到底是怎么生成的呢？</p>
<p>实际上大家在前面操作 <code>scan &#39;tsdb-uid&#39;</code> 的时候，结果会列出额外三行以 <code>\x00</code> 开头的数据：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">ROW                                      COLUMN+CELL </span><br><span class="line">\x00    column=id:metrics, timestamp=1528517476737, value=\x00\x00\x00\x00\x00\x00\x00\x01                                  </span><br><span class="line">\x00    column=id:tagk, timestamp=1528517476811, value=\x00\x00\x00\x00\x00\x00\x00\x02                                      </span><br><span class="line">\x00    column=id:tagv, timestamp=1528517476825, value=\x00\x00\x00\x00\x00\x00\x00\x02</span><br></pre></td></tr></table></figure></div>
<p>实际上 <strong>UID</strong> 是用 <strong>3 bytes</strong> 表示的非负整型数，并且是自增的，而自增的就要依赖于上一次插入的最新 <code>ID</code> 值，这三行就是分别保存 <em>metrics</em>, <em>tagk</em>, <em>tagv</em> 插入的最新数据的 <strong>UID</strong>，这样下次插入新的数据只要在对应的值上加 1 就能得到其对应的 <strong>UID</strong> 了。</p>
<h2 id="Data-Table-Schema"><a href="#Data-Table-Schema" class="headerlink" title="Data Table Schema"></a>Data Table Schema</h2><p>我们再看看 OpenTSDB 的实际存储时序数据的表 – <strong>tsdb</strong>。</p>
<p>既然 <strong>UID</strong> 与字符串的映射关系搞定了，那么真实的时序数据存储就好理解了。<em>tsdb</em> 保存了所有的时序数据，其 <code>rowkey</code> 就是由各个字段对应的 <strong>UID</strong> 组成的。</p>
<p>先查看下 <em>tsdb</em> 数据库结果：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">scan <span class="string">'tsdb'</span></span><br><span class="line"><span class="comment"># == 结果如下 ==</span></span><br><span class="line">ROW                COLUMN+CELL </span><br><span class="line">\x00\x00\x01[\x1Fa`\x00\x00\x01\x00\x00\x01\x00\x00\x02\x00\x00\x02		 column=t:I\x00, timestamp=1528521000278, value=\x0A</span><br></pre></td></tr></table></figure></div>
<p>结果值太长了，可以分开看，先看列族里的数据【18.7.10 更正为】:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">column=t:I\x00, timestamp=1528521000278, value=\x0A</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>value=\x0A</code> 而 <code>0X0A</code> 化为十进制就是 <strong>10</strong>, 正好是我们前面上传的 <code>metric</code> 的值。</p>
<p>再看看 <strong>rowkey</strong>：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">\x00\x00\x01[\x1Fa`\x00\x00\x01\x00\x00\x01\x00\x00\x02\x00\x00\x02</span><br></pre></td></tr></table></figure></div>
<p><code>rowkey</code> 是 <code>OpenTSDB</code> 设计的独特之处，其构成规则为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">[salt]&lt;metric_uid&gt;&lt;timestamp&gt;&lt;tagk1&gt;&lt;tagv1&gt;[...&lt;tagkN&gt;&lt;tagvN&gt;]</span><br></pre></td></tr></table></figure></div>
<p><code>salt</code> 是为了更好的分布式，</p>
<p>我们的上面添加的 <code>metric</code> 为，其中 <code>tagk</code> 会自动按字母排序，所以 <em>area</em> 排在前面：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line"># 字符串对应</span><br><span class="line">sys.test.metric 1528784369 area shanghai hostname jiyiren</span><br><span class="line"># UID 对应 ( timestamp 先不变 )</span><br><span class="line">000001 1528784369 000001 000001 000002 000002</span><br></pre></td></tr></table></figure></div>
<p>除了 <em>timestamp</em> 和上面结果完全对应，而 <em>timestamp</em> 则是按小时存储的，也就是取 <strong>3600</strong> 的整数倍的 <em>timestamp</em> 作为当前时间戳。计算方法 <em>timestamp - timestamp % 3600</em>.</p>
<p>这样，我们应该对 <strong>OpenTSDB</strong> 的 <strong>UID</strong> 以及 <strong>Rowkey</strong> 的生成和存储结构都基本了解了。</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="http://opentsdb.net/docs/build/html/index.html" target="_blank" rel="noopener">http://opentsdb.net/docs/build/html/index.html</a></li>
<li><a href="http://liubin.org/blog/2016/03/05/tsdb-opentsdb/" target="_blank" rel="noopener">http://liubin.org/blog/2016/03/05/tsdb-opentsdb/</a></li>
<li><a href="https://www.jianshu.com/p/0bafd0168647" target="_blank" rel="noopener">https://www.jianshu.com/p/0bafd0168647</a></li>
<li><a href="http://www.nosqlnotes.com/technotes/opentsdb-tabledesign/" target="_blank" rel="noopener">http://www.nosqlnotes.com/technotes/opentsdb-tabledesign/</a></li>
</ul>
<p>img.godjiyi.cn</p>
]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>Metric</tag>
        <tag>OpenTSDB</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2017/05/08/regex/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">你有你的规则，我有我的正则</p>

<p>开发中经常用到正则表达式，但总是靠搜索，有的结果过时或者不正确，导致浪费很多时间。与其将时间浪费在搜索上倒不如自己好好地掌握它。</p>
<h2 id="正则规则"><a href="#正则规则" class="headerlink" title="正则规则"></a>正则规则</h2><hr>
<p>分四大类来说明: <strong>常用符号说明</strong>、<strong>符号数目匹配</strong>、<strong>逻辑语句符号匹配</strong>、<strong>目标匹配符号</strong>。</p>
<h3 id="一、常用符号说明"><a href="#一、常用符号说明" class="headerlink" title="一、常用符号说明"></a>一、常用符号说明</h3><ol>
<li><code>^</code>: <strong>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配。</strong></li>
<li><code>$</code>: <strong>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\n”或”\r”之前的位置匹配。</strong></li>
<li><code>\</code>: <strong>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符</strong></li>
</ol>
<a id="more"></a>
<h3 id="二、符号数目匹配"><a href="#二、符号数目匹配" class="headerlink" title="二、符号数目匹配"></a>二、符号数目匹配</h3><ol>
<li><code>*</code>: <em>零次或多次</em> 匹配前面的字符或子表达式。例如，”zo*“ 匹配”z”和”zoo”。* 等效于<code>{0,}</code>。</li>
<li><code>+</code>: <em>一次或多次</em> 匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 <code>{1,}</code>。</li>
<li><code>?</code>: <em>零次或一次</em> 匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 <code>{0,1}</code>。</li>
<li><code>{n}</code>: <strong>n 是非负整数。正好匹配 n 次。例如，”o{2}”表示此匹配两个o</strong></li>
<li><code>{n,}</code>: <strong>n 是非负整数。至少匹配 n 次。</strong></li>
<li><code>{n,m}</code>: <strong>n 和 m 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。</strong></li>
</ol>
<h3 id="三、逻辑语句符号匹配"><a href="#三、逻辑语句符号匹配" class="headerlink" title="三、逻辑语句符号匹配"></a>三、逻辑语句符号匹配</h3><ol>
<li><code>x|y</code>: <strong>匹配 x 或 y。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。</strong></li>
<li><p><code>()</code>: <strong>括号</strong></p>
<ul>
<li><code>(pattern)</code>: 匹配 pattern 并捕获该匹配的子表达式</li>
<li><code>(?:pattern)</code>: 匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。例如，<code>industr(?:y|ies)</code> 是比 <code>industry|industries</code> 更经济的表达式。</li>
<li><code>(?=pattern)</code>: <a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">?=pattern</a></li>
<li><code>(?!pattern)</code>: <a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">?!pattern</a></li>
</ul>
</li>
</ol>
<h3 id="四、目标匹配符号"><a href="#四、目标匹配符号" class="headerlink" title="四、目标匹配符号"></a>四、目标匹配符号</h3><ol>
<li><code>[xyz]</code>: <strong>字符集。匹配包含的任一字符。例如，”[abc]”代表当前位只能是abc三个字符中的一个</strong></li>
<li><code>[^xyz]</code>: <strong>反向字符集。匹配未包含的任何字符。例如，”<code>[^abc]</code>“ 则当前位不能是abc中的任意一个。</strong></li>
<li><p><code>[a-z]</code>: <strong>字符范围。匹配指定范围内的任何字符。如：</strong></p>
<ul>
<li><code>[a-z]</code>: 当前位匹配从a到z字符</li>
<li><code>[A-Z]</code>: 当前位匹配从A到Z字符</li>
<li><code>[0-9]</code>: 当前位匹配从0到9字符</li>
<li><code>[a-zA-Z0-9]</code>: 当前位匹配从a到z，从A到Z以及从0-9的字符</li>
<li><code>[a-zA-Z0-9_]</code>: 当前位匹配从a到z，从A到Z以及从0-9的字符和<em>_</em>字符</li>
<li><code>[a-zA-Z0-9_-]</code>: 当前位匹配从a到z，从A到Z以及从0-9的字符和<em>_</em>与<em>-</em>字符</li>
</ul>
</li>
<li><p><code>[^a-z]</code>: <strong>反向范围字符。匹配不在指定的范围内的任何字符.</strong></p>
</li>
<li><code>\d</code>: <strong>匹配数字，与<code>[0-9]</code>等效.</strong></li>
<li><code>\D</code>: <strong>匹配非数字字符，与<code>[^0-9]</code>等效.</strong></li>
<li><code>\w</code>: <strong>匹配任何字类字符，包括下划线。与”<code>[A-Za-z0-9_]</code>“等效.</strong></li>
<li><code>\W</code>: <strong>与任何非单词字符匹配。与”<code>[^A-Za-z0-9_]</code>“等效。</strong></li>
<li><code>.</code>: <strong>匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</strong></li>
<li><code>\b</code>: <strong>匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。多用于java中的正则查找与替换</strong>。</li>
<li><code>\B</code>: <strong>非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</strong></li>
<li><code>\s</code>: <strong>匹配任何空白字符，包括空格、制表符、换页符等。与 <code>[\f\n\r\t\v]</code> 等效。</strong></li>
<li><code>\S</code>: <strong>匹配任何非空白字符。与 <code>[^\f\n\r\t\v]</code>等效。</strong></li>
<li><p>各种空白符：</p>
<ul>
<li><code>\f</code>: 换页符匹配。等效于 \x0c 和 \cL。</li>
<li><code>\n</code>: 换行符匹配。等效于 \x0a 和 \cJ。</li>
<li><code>\r</code>: 匹配一个回车符。等效于 \x0d 和 \cM。</li>
<li><code>\t</code>: 制表符匹配。与 \x09 和 \cI 等效。</li>
<li><code>\v</code>: 垂直制表符匹配。与 \x0b 和 \cK 等效。</li>
</ul>
</li>
<li><p><code>\xn</code>: <strong>匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是<em>两位</em>数长。例如，”\x41”匹配”A”。允许在正则表达式中使用 ASCII 代码。</strong></p>
</li>
<li><code>\un</code>: <strong>匹配 n，其中 n 是以<em>四位</em>十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。附：<a href="http://jiyiren.github.io/2016/03/22/Java_encode/" target="_blank" rel="noopener">Unicode编码说明</a>,<a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">汉字Unicode编码表</a></strong> </li>
</ol>
<h2 id="常见正则"><a href="#常见正则" class="headerlink" title="常见正则"></a>常见正则</h2><hr>
<p>下面分别对常见的邮箱和手机号举例。</p>
<h3 id="邮箱："><a href="#邮箱：" class="headerlink" title="邮箱："></a>邮箱：</h3><p>常见邮箱形式：</p>
<ol>
<li><a href="mailto:`zhangshan@163.com" target="_blank" rel="noopener">`zhangshan@163.com</a>`</li>
<li><a href="mailto:`abc@sina.com.cn" target="_blank" rel="noopener">`abc@sina.com.cn</a>`</li>
<li><a href="mailto:`zhangshna.Mr@163.com" target="_blank" rel="noopener">`zhangshna.Mr@163.com</a>`</li>
<li><a href="mailto:`abc_Wang.dd@sian.com" target="_blank" rel="noopener">`abc_Wang.dd@sian.com</a>`</li>
<li><a href="mailto:`abc_Wang.dd.cc@sian.com" target="_blank" rel="noopener">`abc_Wang.dd.cc@sian.com</a>`</li>
</ol>
<p>网络上正则，仅仅能匹配 1，2 两种格式:</p>
<p><code>^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$</code></p>
<p>满足需求正则:</p>
<ol>
<li>匹配全部：<code>^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$</code></li>
<li>等价匹配：<code>^[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$</code></li>
<li>或者：<code>^(\w)+(\.\w+)*@(\w)+((\.\w{2,3}){1,3})$</code></li>
<li>注意java代码里需要将所有 \ 转义，要在所有 \ 前多加一个 \</li>
</ol>
<p>java 代码:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">	String regex = <span class="string">"^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w&#123;2,3&#125;)&#123;1,3&#125;)$"</span>;</span><br><span class="line">	<span class="keyword">return</span> email.matches(regex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="手机号码"><a href="#手机号码" class="headerlink" title="手机号码:"></a>手机号码:</h3><p>手机基本格式如下：</p>
<ol>
<li>共11位：</li>
<li><strong>13(0-9)</strong>:13开头手机号第三位0-9全可以</li>
<li><strong>14(5,7)</strong>:14开头的第三位只有5(联通)，7(移动)</li>
<li><strong>15(-4)</strong>:15开头的第三位除了4，其他都有，因为(154有谐音“要我死”)</li>
<li><strong>17(3,5,6,7,8)</strong>:17开头的三位有3,5,6,7,8;其中3,7为电信，5,6为联通,8为移动。</li>
<li><strong>18(0-9)</strong>:18开头的第三位0-9均可以</li>
<li><p>而170和171的为虚拟运营商:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">1700/1701/1702(电信)</span><br><span class="line">1703/1705/1706(移动)</span><br><span class="line">1704/1707/1708/1709(联通)</span><br><span class="line">171（联通)</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>虚拟商除外，匹配前三个位置数字正则：</p>
<ol>
<li>1与5可以一起写: <strong>1[3,8][0-9]</strong></li>
<li>第二种: <strong>14[5,7]</strong></li>
<li>第三种: <strong>15[^4]</strong></li>
<li>第四种: <strong>17[3,5-8]</strong></li>
<li>合并为: <code>^((1[3,8][0-9])|(14[5,7])|(15[^4])|(17[3,5-8]))\d{8}$</code></li>
<li>注意：\d代表数字，如果要写入 java 代码，则需要多加一条 \ 来转义。如果不想写转义因为\d等价于[0-9]所以也可以换为：<code>^((1[3,8][0-9])|(14[5,7])|(15[^4])|(17[3,5-8]))[0-9]{8}$</code></li>
</ol>
<p>Java 代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isChinaPhoneLegal</span><span class="params">(String str)</span> <span class="keyword">throws</span> PatternSyntaxException </span>&#123;  </span><br><span class="line">	String regExp = <span class="string">"^((1[3,8][0-9])|(14[5,7])|(15[^4])|(17[3,5-8]))\\d&#123;8&#125;$"</span>; </span><br><span class="line">	<span class="comment">//String regExp = "^((1[3,8][0-9])|(14[5,7])|(15[^4])|(17[3,5-8]))[0-9]&#123;8&#125;$";  </span></span><br><span class="line">	Pattern p = Pattern.compile(regExp);  </span><br><span class="line">	Matcher m = p.matcher(str);  </span><br><span class="line">	<span class="keyword">return</span> m.matches();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="占用端口进程"><a href="#占用端口进程" class="headerlink" title="占用端口进程"></a>占用端口进程</h3><p>我们用 Linux 命令获取占用 22 端口信息如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">[root@vm]<span class="comment"># netstat -tnlp | grep ':22 '</span></span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      21392/sshd          </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      21392/sshd</span><br></pre></td></tr></table></figure></div>
<p>只需要用 Python 中 commands 包执行对应命令，取得第一行结果即可得到字符串，我们直接使用该字符用正则提出进程名：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line">tcp_str = <span class="string">"tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      21392/sshd"</span></span><br><span class="line">reg_p = re.compile(<span class="string">r'.+ (\d+)/(\w+)'</span>)</span><br><span class="line">m = reg_p.match(tcp_str)</span><br><span class="line">ps_str = m.group(<span class="number">2</span>) <span class="comment"># 0 为原字符串，1为进程ID，2为进程名，这里为 sshd</span></span><br></pre></td></tr></table></figure></div>
<h3 id="获取磁盘挂载信息"><a href="#获取磁盘挂载信息" class="headerlink" title="获取磁盘挂载信息"></a>获取磁盘挂载信息</h3><h4 id="fdisk-命令"><a href="#fdisk-命令" class="headerlink" title="fdisk 命令"></a>fdisk 命令</h4><p>获取插入主机的所有磁盘 <code>fdisk</code> 命令:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">[root@vm]<span class="comment"># fdisk -l</span></span><br><span class="line"></span><br><span class="line">Disk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x0008b9e9</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vda1   *        2048     1026047      512000   83  Linux</span><br><span class="line">/dev/vda2         1026048    83886079    41430016   8e  Linux LVM</span><br><span class="line"></span><br><span class="line">Disk /dev/vdb: 107.4 GB, 107374182400 bytes, 209715200 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/mapper/centos-root: 40.2 GB, 40227569664 bytes, 78569472 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure></div>
<p>我们只需要 <code>/dev/vdx</code> 这样的信息，因此需要过滤：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">[root@vm]<span class="comment"># fdisk -l | egrep '^Disk /dev/[a-z]d[a-z]' | awk -F: '&#123;print $1&#125;' | awk '&#123;print $2&#125;'</span></span><br><span class="line">/dev/vda</span><br><span class="line">/dev/vdb</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>egrep</code> 是选取符合的行如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">[root@vm]<span class="comment"># fdisk -l | egrep '^Disk /dev/[a-z]d[a-z]'</span></span><br><span class="line">Disk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectors</span><br><span class="line">Disk /dev/vdb: 107.4 GB, 107374182400 bytes, 209715200 sectors</span><br></pre></td></tr></table></figure></div>
<p>后面两个 <code>awk</code> 则不断 <strong>split</strong> 字符串选取出最终的字符。</p>
<h4 id="df-命令"><a href="#df-命令" class="headerlink" title="df 命令"></a>df 命令</h4><p>上面的 <code>fdisk</code> 是获取所有的磁盘信息，包括已经挂载以及未挂载的磁盘，而 <code>df</code> 则获取仅仅挂载的信息，这样对于企业中的监控获取未挂载的磁盘，则只需用 <code>fdisk</code> 结果减 <code>df</code> 的结果，这里只介绍用 <code>df</code> 获取磁盘信息：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">[root@vm]<span class="comment"># df -h</span></span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root   38G  6.5G   32G  18% /</span><br><span class="line">devtmpfs                 3.9G     0  3.9G   0% /dev</span><br><span class="line">tmpfs                    3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs                    3.9G  401M  3.5G  11% /run</span><br><span class="line">tmpfs                    3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1                497M  150M  348M  31% /boot</span><br><span class="line">/dev/vdb                  99G   61M   94G   1% /data</span><br><span class="line">tmpfs                    783M     0  783M   0% /run/user/0</span><br></pre></td></tr></table></figure></div>
<p>我们也只需要 <code>/dev/vdx</code> 这样的信息：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">[root@vm]<span class="comment"># df -Th | /usr/bin/egrep '^/dev/[a-z]d[a-z]\d*' | awk '&#123;print $1&#125;'</span></span><br><span class="line">/dev/vda1</span><br><span class="line">/dev/vdb</span><br></pre></td></tr></table></figure></div>
<h4 id="proc-partitions-文件"><a href="#proc-partitions-文件" class="headerlink" title="/proc/partitions 文件"></a>/proc/partitions 文件</h4><p>这个文件也记录了 Centos 系统的磁盘挂载信息，与 fdisk 命令的结果一致，但是用文件搜索方式比通过 commands 包调用 fdisk 命令效率更高，因此，推荐用此方式来查系统挂载信息：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">[root@vm]<span class="comment"># cat /proc/partitions | egrep ' [a-z]d[a-z]+$' | awk '&#123;print $4&#125;'</span></span><br><span class="line">vda</span><br><span class="line">vdb</span><br></pre></td></tr></table></figure></div>
<h4 id="proc-mounts-文件"><a href="#proc-mounts-文件" class="headerlink" title="/proc/mounts 文件"></a>/proc/mounts 文件</h4><p>这个文件则是与 <code>df</code> 命令相似，只记录已经挂载的磁盘信息，并且效率高于 <code>df</code> 命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">[root@vm]<span class="comment"># cat /proc/mounts | egrep '^/dev/[a-z]d[a-z]+\d*'</span></span><br><span class="line">/dev/vda1 /boot xfs rw,relatime,attr2,inode64,noquota 0 0</span><br><span class="line">/dev/vdb /data ext4 rw,relatime,data=ordered 0 0</span><br></pre></td></tr></table></figure></div>
<p>这个先查询出行，再用 <code>awk</code> 对行进行截取，这个我就不写了，自己大家可以 <code>awk</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">java正则</a></li>
<li><a href="http://www.cnblogs.com/liaojie970/p/5714050.html" target="_blank" rel="noopener">回车与换行</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_4c925dca01009h1a.html" target="_blank" rel="noopener">js正则</a></li>
<li><a href="http://www.cnblogs.com/hsqdboke/p/4944823.html" target="_blank" rel="noopener">邮箱正则</a></li>
</ul>
]]></content>
      <categories>
        <category>Regex</category>
      </categories>
      <tags>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 界面美化</title>
    <url>/2017/08/06/ubuntu-beauty/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">如果美不是与生俱来的，于是就有了美容医院</p>

<p>最近重新把老旧的台式机拿来耍，重新安装了 <strong>Ubuntu 16.04</strong>,但感觉自带的桌面效果不是很好，于是就查找网上的优化博客按套路来整合，这里记录下自己的实现过程。</p>
<p>先看下效果</p>
<p><img src="http://img.godjiyi.cn/ubuntu-1.png" alt="desktop"></p>
<a id="more"></a>
<p><img src="http://img.godjiyi.cn/ubuntu-5.png" alt="workspace"></p>
<h2 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h2><p>主要对系统默认的设置进行一些配置优化,我推荐系统语言为英语，但是可以安装中文输入法。</p>
<h3 id="一、选择软件源"><a href="#一、选择软件源" class="headerlink" title="一、选择软件源"></a>一、选择软件源</h3><p><strong>System Setting(系统设置)–&gt;Software &amp; Updates(软件更新)–&gt;Ubuntu Software(ubuntu软件)–&gt;Download from(下载源)</strong></p>
<p><img src="http://img.godjiyi.cn/ubuntu-06.jpg" alt="源设置"></p>
<ul>
<li><em>上图的 3</em>: 系统会根据所有服务器的延迟自动选择最快的服务器</li>
<li><em>上图的 4</em>: 为中国区的一些服务器，大家可以根据自身喜好选择自己喜欢的服务器镜像</li>
</ul>
<p>设置好源后最好进行一次源更新：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update <span class="comment">#更新源</span></span><br></pre></td></tr></table></figure></div>
<h3 id="二、删除软件"><a href="#二、删除软件" class="headerlink" title="二、删除软件"></a>二、删除软件</h3><p>这个根据自身需要选择进行删除，而不要一味地执行这些命令。</p>
<p><strong>卸载LibreOffice</strong>:</p>
<p>我建议还是留着，因为即使是国内的 <strong>wps</strong> 在 <strong>Linux</strong> 上的支持也有很多 <strong>Bug</strong> 的，而这套软件则是专门配到 <strong>Linux</strong> 的，所以我建议留着。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove libreoffice-common</span><br></pre></td></tr></table></figure></div>
<p>如果大家没注意删除了该软件，也可以通过 <strong>Ubuntu</strong> 的软件中心搜索 <strong>LibreOffice</strong> 进行重新下载。</p>
<p><strong>删除 Amazon</strong>:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove unity-webapps-common</span><br></pre></td></tr></table></figure></div>
<p><strong>删除不常用软件 ( 源自网络 )</strong>:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot </span><br><span class="line">sudo apt-get remove gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku  landscape-client-ui-install  </span><br><span class="line">sudo apt-get remove onboard deja-dup</span><br></pre></td></tr></table></figure></div>
<p><strong>更新源与软件</strong>:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update <span class="comment">#更新源</span></span><br><span class="line">sudo apt-get upgrade <span class="comment">#更新所有软件版本到源版本</span></span><br></pre></td></tr></table></figure></div>
<h3 id="三、安装中文输入法"><a href="#三、安装中文输入法" class="headerlink" title="三、安装中文输入法"></a>三、安装中文输入法</h3><p><strong>System Setting(系统设置) –&gt; Language Support(语言支持) –&gt; Language(语言版块) –&gt; Install/Remove Languages(安装添加语言包) –&gt; Chinese(simplified)[中文(简体中文)] –&gt; Apply(应用)</strong></p>
<h4 id="添加中文语言包"><a href="#添加中文语言包" class="headerlink" title="添加中文语言包"></a>添加中文语言包</h4><p><img src="http://img.godjiyi.cn/ubuntu-07.jpg" alt="添加中文语言包"></p>
<h4 id="Ibus框架输入法"><a href="#Ibus框架输入法" class="headerlink" title="Ibus框架输入法"></a>Ibus框架输入法</h4><p>安装 <strong>ibush</strong> 框架：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ibus ibus-clutter ibus-gtk ibus-gtk3 ibus-qt4</span><br></pre></td></tr></table></figure></div>
<p>启动 <strong>ibus</strong> 框架：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo im-switch -s ibus <span class="comment">#早期版本</span></span><br><span class="line">sudo im-config -s ibus <span class="comment">#较新版本</span></span><br></pre></td></tr></table></figure></div>
<p>重启或者注销，以使之生效</p>
<p>安装拼音引擎( 下面可任选 )：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ibus-sunpinyin <span class="comment">#sun拼音</span></span><br><span class="line">sudo apt-get install ibus-pinyin <span class="comment">#简单拼音</span></span><br><span class="line">sudo apt-get install ibus-googlepinyin <span class="comment">#谷歌拼音</span></span><br><span class="line">sudo apt-get install ibus-table-wubi <span class="comment">#五笔输入引擎</span></span><br></pre></td></tr></table></figure></div>
<p>设置ibus框架：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">ibus-setup <span class="comment">#调出ibus设置界面</span></span><br></pre></td></tr></table></figure></div>
<p><img src="http://img.godjiyi.cn/ibus-set.jpg" alt="ibus设置界面"></p>
<p>配置系统输入法：</p>
<p><em>System Setting(系统设置) –&gt; Text Entry(输入法)</em></p>
<p><img src="http://img.godjiyi.cn/text-entry.jpg" alt="Text Entry设置"></p>
<h4 id="Fcitx-框架输入法"><a href="#Fcitx-框架输入法" class="headerlink" title="Fcitx 框架输入法"></a>Fcitx 框架输入法</h4><p>安装 <strong>Fcitx</strong> 框架：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fcitx</span><br></pre></td></tr></table></figure></div>
<p>安装 <strong>Fcitx</strong> 的配置工具：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fcitx-config-gtk</span><br></pre></td></tr></table></figure></div>
<p>安装输入法引擎：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fcitx-sunpinyin <span class="comment">#sun拼音</span></span><br><span class="line">sudo apt-get install fcitx-pinyin    <span class="comment">#简单拼音</span></span><br><span class="line">sudo apt-get install fcitx-googlepinyin <span class="comment">#谷歌拼音</span></span><br><span class="line">sudo apt-get install fcitx-table-wbpy  <span class="comment">#五笔输入</span></span><br></pre></td></tr></table></figure></div>
<p>设置系统输入法框架：</p>
<p><img src="http://img.godjiyi.cn/ubuntu-08.jpg" alt="fcitx框架"></p>
<p>重启或者注销，以使之生效</p>
<p>配置系统输入法：</p>
<p><em>System Setting(系统设置) –&gt; Text Entry(输入法)</em></p>
<p><img src="http://img.godjiyi.cn/ubuntu-09.jpg" alt="选择源"><br><img src="http://img.godjiyi.cn/ubuntu-10.jpg" alt="添加输入法"></p>
<p>添加搜狗输入法：</p>
<p>下载地址:<a href="http://pinyin.sogou.com/linux/" target="_blank" rel="noopener">http://pinyin.sogou.com/linux/</a></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i sogoupinyin_2.1.0.0086_amd64.deb <span class="comment">#后面名称替换为自己</span></span><br></pre></td></tr></table></figure></div>
<h2 id="系统美化"><a href="#系统美化" class="headerlink" title="系统美化"></a>系统美化</h2><p>主要安装主题、字体、图标、软件来进行风格的设置，整体软件的配置也会增加系统的美观性</p>
<p><img src="http://img.godjiyi.cn/ubuntu-1.png" alt="desktop"></p>
<h3 id="一、主题工具"><a href="#一、主题工具" class="headerlink" title="一、主题工具"></a>一、主题工具</h3><h4 id="unity-tweak-tool"><a href="#unity-tweak-tool" class="headerlink" title="unity-tweak-tool"></a>unity-tweak-tool</h4><p>github地址:<a href="https://github.com/freyja-dev/unity-tweak-tool" target="_blank" rel="noopener">https://github.com/freyja-dev/unity-tweak-tool</a></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install unity-tweak-tool</span><br></pre></td></tr></table></figure></div>
<p>安装后在搜索中搜索unity-tweak-tool,点击打开，界面如下:</p>
<p><img src="http://img.godjiyi.cn/ubuntu-11.jpg" alt="unity-tweak-tool"></p>
<h4 id="Flatabulous-主题安装"><a href="#Flatabulous-主题安装" class="headerlink" title="Flatabulous 主题安装"></a>Flatabulous 主题安装</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:noobslab/themes</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install flatabulous-theme</span><br></pre></td></tr></table></figure></div>
<h4 id="ultra-flat-icons-图标安装"><a href="#ultra-flat-icons-图标安装" class="headerlink" title="ultra-flat-icons 图标安装"></a>ultra-flat-icons 图标安装</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:noobslab/icons</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ultra-flat-icons</span><br></pre></td></tr></table></figure></div>
<h4 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h4><p>打开 <strong>unity-tweak-tool</strong>, 选择 <strong>Appearance</strong> ( 外观 ) 下的 <strong>Theme</strong> ( 主题 ):</p>
<p><img src="http://img.godjiyi.cn/ubuntu-14.jpg" alt></p>
<p>主题选择:</p>
<p><img src="http://img.godjiyi.cn/ubuntu-12.jpg" alt="Flatabulous主题"></p>
<p>图标选择:</p>
<p><img src="http://img.godjiyi.cn/ubuntu-13.jpg" alt="ultra-flat"></p>
<h4 id="爱壁纸"><a href="#爱壁纸" class="headerlink" title="爱壁纸"></a>爱壁纸</h4><p>官网地址:<a href="http://www.lovebizhi.com/linux.html" target="_blank" rel="noopener">http://www.lovebizhi.com/linux.html</a></p>
<p>推荐下载 deb 版的软件包，因为我们可以安装一个便捷的 deb 安装管理器 – <strong>GDebi 安装器</strong></p>
<p>大家可以在ubuntu软件中心下载也可以用以下命令安装:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gdebi</span><br></pre></td></tr></table></figure></div>
<p>这样在右击deb包的时候，选择 <em>Open With–GDebi Package Installer</em>, 就可以直接帮你安装deb包的软件了。    </p>
<p>当然你可以不用此工具，直接用命令安装也可以的:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i LoveWallpaper4Linux.deb</span><br></pre></td></tr></table></figure></div>
<p>安装好后，在搜索中搜索 <strong>Love</strong>，打开爱壁纸界面:</p>
<p><img src="http://img.godjiyi.cn/ubuntu-15.jpg" alt="爱壁纸"></p>
<h3 id="二、开发工具"><a href="#二、开发工具" class="headerlink" title="二、开发工具"></a>二、开发工具</h3><p><strong>git</strong> 工具：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></div>
<p><strong>vim</strong> 工具：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure></div>
<p><strong>sublime3</strong>:</p>
<p>安装:<a href="http://www.sublimetext.com/docs/3/linux_repositories.html" target="_blank" rel="noopener">官方说明</a></p>
<p><strong>zsh+oh-my-zsh</strong>:</p>
<p>项目地址:<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a></p>
<p>安装 <strong>zsh</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install zsh</span><br></pre></td></tr></table></figure></div>
<p>修改系统默认为 <strong>zsh</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>若提示 <code>chsh: PAM: Authentication failure</code>, 请看 <a href="http://blog.csdn.net/shengzhu1/article/details/54590158" target="_blank" rel="noopener">这里</a></p>
</blockquote>
<p>安装 <strong>oh-my-zsh</strong>:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>"</span></span><br></pre></td></tr></table></figure></div>
<p>重新登录的默认 <strong>zsh</strong> 就交给 <strong>oh-my-zsh</strong> 管理了，我们用 <strong>oh-my-zsh</strong> 主要是使用其主题，因此我们可以修改配置文件 <code>~/.zshrc</code></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="comment">#将ZSH_THEME="robbyrussell",修改为如下:</span></span><br><span class="line">ZSH_THEME=<span class="string">"ys"</span></span><br></pre></td></tr></table></figure></div>
<p>最终效果：</p>
<p><img src="http://img.godjiyi.cn/ubuntu-3.png" alt="program"></p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><h3 id="桌面"><a href="#桌面" class="headerlink" title="桌面"></a>桌面</h3><p><img src="http://img.godjiyi.cn/ubuntu-1.png" alt="desktop"></p>
<h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p><img src="http://img.godjiyi.cn/ubuntu-2.png" alt="command"></p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p><img src="http://img.godjiyi.cn/ubuntu-3.png" alt="program"></p>
<h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p><img src="http://img.godjiyi.cn/ubuntu-4.png" alt="window"></p>
<h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><p><img src="http://img.godjiyi.cn/ubuntu-5.png" alt="workspace"></p>
<h2 id="丰富的其他应用"><a href="#丰富的其他应用" class="headerlink" title="丰富的其他应用"></a>丰富的其他应用</h2><p>(1). 网易云音乐</p>
<p>下载地址:<a href="http://music.163.com/#/download" target="_blank" rel="noopener">http://music.163.com/#/download</a></p>
<p>(2). WPS文档工具</p>
<p>下载地址:<a href="http://community.wps.cn/download/" target="_blank" rel="noopener">http://community.wps.cn/download/</a></p>
<p>(3). Xmind</p>
<p>下载地址:<a href="http://www.xmindchina.net/xiazai.html" target="_blank" rel="noopener">http://www.xmindchina.net/xiazai.html</a></p>
<p>(4). 搜狗输入法</p>
<p>下载地址:<a href="http://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="noopener">http://pinyin.sogou.com/linux/?r=pinyin</a></p>
<p>(5). 爱壁纸</p>
<p>下载地址:<a href="http://www.lovebizhi.com/linux.html" target="_blank" rel="noopener">http://www.lovebizhi.com/linux.html</a></p>
<p>(6). 有道词典</p>
<p>下载地址:<a href="http://cidian.youdao.com/index-linux.html" target="_blank" rel="noopener">http://cidian.youdao.com/index-linux.html</a></p>
<p>(7). 为知笔记</p>
<p>下载地址:<a href="http://www.wiz.cn/wiznote-linux.html" target="_blank" rel="noopener">http://www.wiz.cn/wiznote-linux.html</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://jingyan.baidu.com/article/86f4a73e8f534637d752695e.html" target="_blank" rel="noopener">Ubuntu16.04下安装中文输入法</a></li>
<li><a href="http://blog.csdn.net/u013894834/article/details/60357071" target="_blank" rel="noopener">Ubuntu16.04安装搜狗输入法</a></li>
<li><a href="http://blog.csdn.net/wangweiqiang1325/article/details/53447123" target="_blank" rel="noopener">Ubuntu 16.04下的美化配置过程</a></li>
<li><a href="http://blog.csdn.net/terence1212/article/details/52270210" target="_blank" rel="noopener">ubuntu16.04主题美化和软件推荐</a></li>
<li><a href="https://www.zhihu.com/question/19811112?sort=created" target="_blank" rel="noopener">在Ubuntu上有什么必装的实用软件</a></li>
<li><a href="http://blog.csdn.net/shengzhu1/article/details/54590158" target="_blank" rel="noopener"> Ubuntu16.04LTS安装zsh+oh-my-zsh</a></li>
</ul>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 日志工具介绍</title>
    <url>/2018/06/16/java-log/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">容易被忽略的数据生产源</p>

<p>目前，随着大数据方向的推进，越来越多的数据被应用于数据分析和挖掘，而其中一大部分就是项目中的 <strong>日志数据</strong>。而 <strong>Java</strong> 项目中有很多的日志输出包，不同项目使用不同的日志工具会造成数据结构的不一致，这样就为 <strong>数据分析</strong> 增添了一定的麻烦，今天记录下对各中日志工具的说明。</p>
<h2 id="日志组件历史"><a href="#日志组件历史" class="headerlink" title="日志组件历史"></a>日志组件历史</h2><hr>
<h3 id="JUL"><a href="#JUL" class="headerlink" title="JUL"></a>JUL</h3><p>这个是 <strong>java.util.logging</strong> 的缩写，也就是 Java 本身 JDK 自带的日志工具，但是通常它的功能有限，因此，项目中的日志输出都是采用特有的日志工具进行记录。而日志工具中得到广泛使用的就是 <strong>log4j</strong>.</p>
<h3 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h3><p><strong>Java</strong> 界里有许多实现日志功能的工具，最早得到广泛使用的是 <strong>log4j</strong>, 许多应用程序的日志部分都交给了 <strong>log4j</strong>, 不过作为组件开发者，他们希望自己的组件不要紧紧依赖某一个工具，毕竟在同一个时候还有很多其他很多日志工具，假如一个应用程序用到了两个组件，恰好两个组件使用不同的日志工具，那么应用程序就会有两份日志输出了。</p>
<a id="more"></a>
<h3 id="JCL"><a href="#JCL" class="headerlink" title="JCL"></a>JCL</h3><p>为了解决这个问题，<strong>Apache Commons Logging</strong> （ 之前叫 <em>Jakarta Commons Logging</em>, 所以缩写为 <em>JCL</em> ）粉墨登场，<em>JCL</em> 只提供 <strong>log</strong> 接口，具体的实现则在运行时 <strong>动态寻找</strong>。这样一来组件开发者只需要针对 <em>JCL</em> 接口开发，而调用组件的应用程序则可以在运行时搭配自己喜好的日志实践工具。</p>
<p>所以即使到现在你仍会看到很多程序应用 <strong>JCL + log4j</strong> 这种搭配，不过当程序规模越来越庞大时，<em>JCL</em> 的 <strong>动态绑定</strong> 并不是总能成功，具体原因大家可以 Google 一下，这里就不再赘述了。解决方法之一就是在程序部署时 <strong>静态绑定</strong> 指定的日志工具，这就是 SLF4J 产生的原因。</p>
<h3 id="SLF4j"><a href="#SLF4j" class="headerlink" title="SLF4j"></a>SLF4j</h3><p>跟 <em>JCL</em> 一样，<strong>SLF4J</strong> 也是只提供 log 接口，具体的实现是在打包应用程序时所放入的绑定器（ 名字为 <code>slf4j-XXX-version.jar</code> ）来决定，<code>XXX</code> 可以是 <em>log4j12</em>,  <em>jdk14</em>, <em>jcl</em>, <em>nop</em> 等，他们实现了跟具体日志工具（ 比如 <em>log4j</em> ）的绑定及代理工作。举个例子：如果一个程序希望用 <em>log4j</em> 日志工具，那么程序只需针对 <strong>slf4j-api</strong> 接口编程，然后在打包时再放入 <strong>slf4j-log4j12-version.jar</strong> 和 <strong>log4j.jar</strong> 就可以了。</p>
<p>现在还有一个问题，假如你正在开发应用程序所调用的组件当中已经使用了 <em>JCL</em> 的，还有一些组建可能直接调用了 <em>java.util.logging</em>，这时你需要一个桥接器（ 名字为 <strong>XXX-over-slf4j.jar</strong> ）把他们的日志输出重定向到 <strong>SLF4J</strong>, 所谓的桥接器就是一个假的日志实现工具，比如当你把 <strong>jcl-over-slf4j.jar</strong> 放到 <strong>CLASS_PATH</strong> 时，即使某个组件原本是通过 <em>JCL</em> 输出日志的，现在却会被 <strong>jcl-over-slf4j</strong> <em>“骗到”</em> <strong>SLF4J</strong> 里，然后 <strong>SLF4J</strong> 又会根据绑定器把日志交给具体的日志实现工具。过程如下。</p>
<p>这时，你可能会发现一个有趣的问题，假如在 <strong>CLASS_PATH</strong> 里同时放置 <strong>log4j-over-slf4j.jar</strong> 和 <strong>slf4j-log4j12-version.jar</strong> 会发生什么情况呢？没错，日志会被踢来踢去，最终进入死循环。</p>
<h2 id="日志搭配组合"><a href="#日志搭配组合" class="headerlink" title="日志搭配组合"></a>日志搭配组合</h2><hr>
<p>日志工具那么多，有门面也有具体实现，那到底如何进行搭配呢？这里主要给出目前最流行的两种搭配：</p>
<h3 id="JCL-Log4j-搭配"><a href="#JCL-Log4j-搭配" class="headerlink" title="JCL + Log4j 搭配"></a>JCL + Log4j 搭配</h3><p>这种方式是采用 <strong>JCL</strong> 作为日志门面抽象接口，具体日志输出使用 <strong>Log4j</strong>. 具体用到的 Jar 包和资源文件如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">1. commons-logging-1.1.jar		// JCL 日志门面</span><br><span class="line">2. log4j-1.2.15.jar				// Log4j 具体日志输出</span><br><span class="line">3. log4j.properties				// Log4j 的日志配置文件</span><br></pre></td></tr></table></figure></div>
<p>对于 <em>Log4j.properties</em> 如何配置，下面会讲到，这里给出常用日志定义代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意导入的包</span></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Log logger = LogFactory.getLog(A.class);</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		logger.debug(<span class="string">"This is debug"</span>);</span><br><span class="line">	 	logger.info(<span class="string">"This is info"</span>);</span><br><span class="line">		logger.warn(<span class="string">"This is warn"</span>);</span><br><span class="line">		logger.eror(<span class="string">"This is error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="SLF4j-Log4j-搭配"><a href="#SLF4j-Log4j-搭配" class="headerlink" title="SLF4j + Log4j 搭配"></a>SLF4j + Log4j 搭配</h3><p>这种方式采用 SLF4j 作为日志门面抽象接口，具体日志输出仍然使用 <strong>Log4j</strong>. 具体用到的 Jar 包和资源文件如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">1. slf4j-api-1.5.11.jar</span><br><span class="line">2. slf4j-log4j12-1.5.11.jar	// slf4j 桥接给 log4j</span><br><span class="line">3. log4j-1.2.15.jar</span><br><span class="line">4. log4j.properties</span><br></pre></td></tr></table></figure></div>
<p>我们可以看到除了各自的 API jar 包 还有一个 <strong>slf4j-log4j12-1.5.11.jar</strong>, 这个就是输出流重定向的意思，将 <strong>slf4j</strong> 接口输出转到具体的 <strong>log4j</strong> 实现。而假如你目前项目中已经用 <strong>JUL</strong> 实现日志输出了，你想用此种配置方式怎么办？那就再加一个 jar 包：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">jul-to-slf4j-1.7.25.jar</span><br></pre></td></tr></table></figure></div>
<p>或者你已经使用了 <strong>JCL</strong> 日志门面接口，那如何转，只要加下面的 jar 包：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">jcl-over-slf4j-1.7.25.jar</span><br></pre></td></tr></table></figure></div>
<p>从中我们可以看出，<strong>slf4j</strong> 接口使用还是很广泛的，不管是入口还是出口都有各种对应的 jar 包可供使用的，那它可定制化以及适应性是非常广泛的，因此我推荐大家以后尽量使用 <strong>SLF4j</strong> 这个日志门面作为通用日志输出接口。</p>
<p>使用 <strong>SLF4j</strong> 的日志代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意导入的包和上面的 JCL 不一样的，不要混淆了</span></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;  </span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Logger logger= LoggerFactory.getLogger(A.class);</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	logger.debug(<span class="string">"This is debug"</span>);</span><br><span class="line"> 	logger.info(<span class="string">"This is info"</span>);</span><br><span class="line">	logger.warn(<span class="string">"This is warn"</span>);</span><br><span class="line">	logger.eror(<span class="string">"This is error: &#123;&#125;"</span>,<span class="string">"error stack string"</span>);</span><br><span class="line">	<span class="comment">// error 的输出中 &#123;&#125; 是占位符，可以有多个，对应的后面字符串参数也应该多个</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里我们发现一个不同点，就是 <strong>SLF4j</strong> 可以用 <code>{}</code> 作为占位符，进行日志字符串的拼接操作，那这个有什么好处呢？这里也说明下：</p>
<p>首先看不用占位符是怎么使用多字符串拼接的：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">logger.debug(<span class="string">"This is debug: "</span> + <span class="string">"debug stack string"</span>);</span><br></pre></td></tr></table></figure></div>
<p>如上所示，完成了一个 <strong>debug</strong> 日志输出，很多人都是这样实现的，但是大家知道，我们上线的应用不能将 <strong>debug</strong> 日志输出的，因为 <strong>debug</strong> 只能在开发调试阶段使用。因此，我们需要配置我们的日志工具，使其只能输出 <em>info, warn, error</em> 的日志信息。那么，<code>logger.debug</code> 这句话内部就会自动判断是否要进行输出，当在内部判断后确实不需要输出！</p>
<p>但是，我们发现一个问题，就是参数字符串拼接都是要先执行的，也就是不管你内部要不要输出，字符串都是要先拼接好才能进入 <strong>logger</strong> 内部判断的。如果日志记录很少有加的字符串还没多少性能问题，但如果有很多字符串拼接操作，并且拼接很多个字符串，<strong>那么会白白地浪费这些字符串拼接过程的性能</strong>。因此，正确的做法是：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled())&#123;</span><br><span class="line">	logger.debug(<span class="string">"This is debug: "</span> + <span class="string">"debug stack string"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>但是没次输出都要先进行判断是不是太过于重复了，因此，带占位符的字符串拼接操作就诞生了：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">logger.debug(<span class="string">"This is debug: &#123;&#125;"</span> , <span class="string">"debug stack string"</span>);</span><br></pre></td></tr></table></figure></div>
<p>这种方式多个字符串当做参数传入，不会先进行拼接再传入，而是在内部判断后再进行拼接操作，因此这也是 <strong>SLF4j</strong> 日志工具的一大优势。那下面就主要讲下 <strong>SLF4j</strong> 的配置参数。</p>
<h2 id="SLF4j-配置"><a href="#SLF4j-配置" class="headerlink" title="SLF4j 配置"></a>SLF4j 配置</h2><hr>
<p><strong>SLF4j</strong> 由于其适配广泛，通用性强，因此很多开源项目中都是使用它作为自己的日志记录接口，就如 <em>Hadoop</em> 系列生态。我们在开发 <em>Hadoop</em> 生态应用的时候，常常会在调试的时候打印出：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">log4j:WARN No appenders could be found for logger (org.apache.hadoop.util.Shell).  </span><br><span class="line">log4j:WARN Please initialize the log4j system properly.  </span><br><span class="line">log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</span><br></pre></td></tr></table></figure></div>
<p>这个就是因为没有配置 <strong>log4j.properties</strong> 所导致的。那通常的解决方法就是在项目路径里新建一个 <strong>log4j.properties</strong>, 然后填下面信息就可以了：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger=INFO, stdout, logfile</span><br><span class="line"></span><br><span class="line"># 标准输出流：输出到终端</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.Encoding=UTF-8</span><br><span class="line">log4j.appender.stdout.Threshold=DEBUG</span><br><span class="line">log4j.appender.stdout.ImmediateFlush=true</span><br><span class="line">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=[%p] %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c] %m%n</span><br><span class="line"></span><br><span class="line"># 文件输出流：输出到日志文件</span><br><span class="line">log4j.appender.logfile=org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.logfile.Threshold=INFO</span><br><span class="line">log4j.appender.logfile.Encoding=UTF-8</span><br><span class="line">log4j.appender.logfile.File=$&#123;user.dir&#125;/logs/mylog.log</span><br><span class="line">log4j.appender.logfile.Append=true</span><br><span class="line">log4j.appender.logfile.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.logfile.layout.ConversionPattern=[%p] %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c] %m%n</span><br></pre></td></tr></table></figure></div>
<p>那这些配置信息到底是什么意思？下面详细讲下。</p>
<h3 id="配置-RootLogger"><a href="#配置-RootLogger" class="headerlink" title="配置 RootLogger"></a>配置 RootLogger</h3><p>首先看第 <strong>1</strong> 行，也就是 <code>log4j.rootLogger</code> 的配置，其语法为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger = [ level ] , appenderName1, appenderName2, ...</span><br></pre></td></tr></table></figure></div>
<p>(1). <em>level</em> : 是日志记录的优先级，分为 <strong>OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL</strong> 或者您定义的级别。<em>Log4j</em> 建议只使用四个级别，优先级从高到低分别是 <strong>ERROR、WARN、INFO、DEBUG</strong>. 如果设置为 <strong>INFO</strong> 则，<strong>ERROR</strong>, <strong>WARN</strong>, <strong>INFO</strong> 都会输出，而 <strong>DEBUG</strong> 不会输出。</p>
<p>(2). <em>appenderName</em> : 是日志输出的目的地，名字是 <strong>自定义</strong>，也可以写多个；上面的配置 <em>stdout</em> 就是一个 <em>appenderName</em> 名字，当然你也可以叫其他名字的。当然你这里定义了这个名字，那么下面就要配置这个名字对应的输出地的相关信息，那下面配置的信息就得和这里设置的一致。下面会讲到。</p>
<h3 id="配置信息输出目的地"><a href="#配置信息输出目的地" class="headerlink" title="配置信息输出目的地"></a>配置信息输出目的地</h3><p>上面代码的第 <strong>4-7</strong> 和 <strong>12-16</strong> 行都是配置日志输出目的地的，目的地有多种类型：</p>
<p><em>(1)</em>. <strong>org.apache.log4j.ConsoleAppender（控制台）</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">Threshold=WARN			// 指定日志消息的输出最低层次。</span><br><span class="line">ImmediateFlush=true		// 默认值是true,意谓着所有的消息都会被立即输出。</span><br><span class="line">Target=System.err		// 默认情况下是：System.out,指定输出控制台</span><br></pre></td></tr></table></figure></div>
<p><em>(2)</em>. <strong>org.apache.log4j.FileAppender（文件）</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">Threshold=WARN	// 指定日志消息的输出最低层次。</span><br><span class="line">ImmediateFlush=true		// 默认值是true,意谓着所有的消息都会被立即输出。</span><br><span class="line">File=mylog.txt		// 指定消息输出到mylog.txt文件。</span><br><span class="line">Append=false		// 默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。</span><br></pre></td></tr></table></figure></div>
<p><em>(3)</em>. <strong>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">Threshold=WARN 		// 指定日志消息的输出最低层次。</span><br><span class="line">ImmediateFlush=true	// 默认值是true,意谓着所有的消息都会被立即输出。</span><br><span class="line">File=mylog.txt		// 指定消息输出到mylog.txt文件。</span><br><span class="line">Append=false			// 默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。</span><br><span class="line">DatePattern=&apos;&apos;.&apos;&apos;yyyy-ww	//每周滚动一次文件，即每周产生一个新的文件。当然也可以指定按月、周、天、时和分。即对应的格式如下：</span><br><span class="line">	1)&apos;&apos;.&apos;&apos;yyyy-MM: 每月</span><br><span class="line">	2)&apos;&apos;.&apos;&apos;yyyy-ww: 每周  </span><br><span class="line">	3)&apos;&apos;.&apos;&apos;yyyy-MM-dd: 每天</span><br><span class="line">	4)&apos;&apos;.&apos;&apos;yyyy-MM-dd-a: 每天两次</span><br><span class="line">	5)&apos;&apos;.&apos;&apos;yyyy-MM-dd-HH: 每小时</span><br><span class="line">	6)&apos;&apos;.&apos;&apos;yyyy-MM-dd-HH-mm: 每分钟</span><br></pre></td></tr></table></figure></div>
<p><em>(4)</em>. <strong>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">Threshold=WARN		// 指定日志消息的输出最低层次。</span><br><span class="line">ImmediateFlush=true	// 默认值是true,意谓着所有的消息都会被立即输出。</span><br><span class="line">File=mylog.txt		// 指定消息输出到mylog.txt文件。</span><br><span class="line">Append=false		// 默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。</span><br><span class="line">MaxFileSize=100KB	// 后缀可以是KB, MB 或者是 GB. 在日志文件到达该大小时，将会自动滚动，即将原来的内容移到mylog.log.1文件。</span><br><span class="line">MaxBackupIndex=2		// 指定可以产生的滚动文件的最大数。</span><br></pre></td></tr></table></figure></div>
<p><em>(5)</em>. <strong>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</strong></p>
<p>这个用得相对较少，这里就不介绍了。</p>
<h3 id="日志信息的输出格式"><a href="#日志信息的输出格式" class="headerlink" title="日志信息的输出格式"></a>日志信息的输出格式</h3><p>上面代码的第 <strong>8-9</strong> 和 <strong>17-18</strong> 行都是配置日志输出格式的，也有多种类型：</p>
<p><em>(1)</em>. <strong>org.apache.log4j.HTMLLayout（以HTML表格形式布局）</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">LocationInfo=true	// 默认值是 false, 输出 java 文件名称和行号</span><br><span class="line">Title=my app file	// 默认值是 Log4J Log Messages.</span><br></pre></td></tr></table></figure></div>
<p><em>(2)</em>. <strong>org.apache.log4j.PatternLayout（可以灵活地指定布局模式）</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">ConversionPattern=%m%n		// 指定怎样格式化指定的消息。</span><br><span class="line">ConversionPattern=%-4r %-5p %d&#123;yyyy-MM-dd HH:mm:ssS&#125; %c %m%n	// 这个模式下面会详细介绍</span><br></pre></td></tr></table></figure></div>
<p><em>(3)</em>. <strong>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">LocationInfo=true:默认值是false,输出java文件和行号</span><br></pre></td></tr></table></figure></div>
<p><em>(4)</em>. <strong>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</strong></p>
<p>对于 <strong>PatternLayout</strong> 模式下：</p>
<p><strong>ConversionPattern=%-4r %-5p %d{yyyy-MM-dd HH:mm:ssS} %c %m%n</strong></p>
<p>这里需要说明的就是日志信息格式中几个符号所代表的含义：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">－x号: x信息输出时左对齐；</span><br><span class="line">%p: 输出日志信息优先级，即 DEBUG，INFO，WARN，ERROR，FATAL, </span><br><span class="line">%d: 输出日志时间点的日期或时间，默认格式为 ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss,SSS&#125;，输出类似：2002年10月18日 22：10：28，921 </span><br><span class="line">%r: 输出自应用启动到输出该log信息耗费的毫秒数</span><br><span class="line">%c: 输出日志信息所属的类目，通常就是所在类的全名</span><br><span class="line">%t: 输出产生该日志事件的线程名</span><br><span class="line">%l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) </span><br><span class="line">%x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。</span><br><span class="line">%%: 输出一个&quot;%&quot;字符</span><br><span class="line">%F: 输出日志消息产生时所在的文件名称</span><br><span class="line">%L: 输出代码中的行号</span><br><span class="line">%m: 输出代码中指定的消息,产生的日志具体信息</span><br><span class="line">%n: 输出一个回车换行符，Windows平台为&quot;\r\n&quot;，Unix平台为&quot;\n&quot;输出日志信息换行</span><br><span class="line">  可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。如：</span><br><span class="line"> 	1)%20c：指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，默认的情况下右对齐。</span><br><span class="line"> 	2)%-20c:指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，&quot;-&quot;号指定左对齐。</span><br><span class="line">  	3)%.30c:指定输出category的名称，最大的宽度是30，如果category的名称大于30的话，就会将左边多出的字符截掉，但小于30的话也不会有空格。</span><br><span class="line">  	4)%20.30c:如果category的名称小于20就补空格，并且右对齐，如果其名称长于30字符，就从左边交远销出的字符截掉</span><br></pre></td></tr></table></figure></div>
<p>下面给出一个完整的配置说明：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line"># 这里里配置了DEBUG等级，则可显示DEBUG以上的所有信息；</span><br><span class="line"># 配置的输出地有两个apconsole,apfile, 与下面的 后面的log4j.appender.apconsole 最后一个单词相同</span><br><span class="line">log4j.rootLogger = DEBUG, apconsole, apfile</span><br><span class="line"></span><br><span class="line"># ========================= apconsole ===========================</span><br><span class="line"></span><br><span class="line"># apconsole 目的地配置为：ConsoleAppender（控制台）</span><br><span class="line">log4j.appender.apconsole = org.apache.log4j.ConsoleAppender</span><br><span class="line"># apconsole 输出日志编码 UTF-8</span><br><span class="line">log4j.appender.apconsole.Encoding=UTF-8</span><br><span class="line"># apconsole 的 Threshold: 指定日志消息的输出最低层次为 DEBUG</span><br><span class="line">log4j.appender.apconsole.Threshold=DEBUG</span><br><span class="line"># apconsole 的 ImmediateFlush=true，默认值是true,意谓着所有的消息都会被立即输出</span><br><span class="line">log4j.appender.apconsole.ImmediateFlush=true</span><br><span class="line"># apconsole 的 Target=System.out：默认情况就是是：System.out, 指定输出控制台</span><br><span class="line"># log4j.appender.apconsole.Target=System.out</span><br><span class="line"># apconsole 的信息输出格式为：PatternLayout（可以灵活地指定布局模式）</span><br><span class="line">log4j.appender.apconsole.layout = org.apache.log4j.PatternLayout</span><br><span class="line"># apconsole 的输出格式 ConversionPattern 此处输出为：日志优先级 日志时间 日志所属类全名 日志具体信息 回车</span><br><span class="line">log4j.appender.apconsole.layout.ConversionPattern=[%p] %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c] %m%n</span><br><span class="line"></span><br><span class="line"># ========================== apfile =============================</span><br><span class="line"></span><br><span class="line"># apfile 目的地配置为：DailyRollingFileAppender（每天生成一个文件）</span><br><span class="line">log4j.appender.apfile = org.apache.log4j.DailyRollingFileAppender</span><br><span class="line"># apfile 输出日志文件格式为 UTF-8</span><br><span class="line">log4j.appender.apfile.Encoding=UTF-8</span><br><span class="line"># apfile 输出日志文件地址为 tomcat 主目录的 logs 下的 log.txt</span><br><span class="line">log4j.appender.apfile.File=$&#123;catalina.home&#125;/logs/log.txt</span><br><span class="line"># apfile 将消息增加到指定文件中, false 则是覆盖原文件内容</span><br><span class="line">log4j.appender.apfile.Append=true</span><br><span class="line"># apfile 每天产生一个日志文件, 名称为 年月日</span><br><span class="line">log4j.appender.apfile.DatePattern=&apos;.&apos;yyyyMMdd</span><br><span class="line"># apfile 采用灵活指定输出布局模式</span><br><span class="line">log4j.appender.apfile.layout = org.apache.log4j.PatternLayout</span><br><span class="line"># apfile 使用 ConversionPattern 此处输出为：日志优先级 日志时间 日志所属类全名 日志具体信息 回车</span><br><span class="line">log4j.appender.apfile.layout.ConversionPattern=[%p] %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c] %m%n</span><br></pre></td></tr></table></figure></div>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.csdn.net/yycdaizi/article/details/8276265#" target="_blank" rel="noopener"><strong>[CSDN]</strong> Java 日志组件介绍 ( common-logging, log4j, slf4j, logback)</a></li>
<li><a href="http://www.cnblogs.com/zhuawang/p/3999132.html" target="_blank" rel="noopener"><strong>[CNBlog]</strong> log4j 与 commons-logging, slf4j 的关系</a></li>
<li><a href="http://www.cnblogs.com/zhuawang/p/3999035.html" target="_blank" rel="noopener"><strong>[CNBlog]</strong> log4j 的配置信息</a></li>
<li><a href="http://blog.csdn.net/geekun/article/details/51398621" target="_blank" rel="noopener"><strong>[CSDN]</strong> Java 使用 Log 日志系统（ common-logging 和 log4j ）</a></li>
</ul>
]]></content>
      <categories>
        <category>Logger</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Logger</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 优雅地退出程序</title>
    <url>/2018/06/18/jvm-exit/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">show me code? No, show me elegant code!</p>

<p>很多情况下，我们的程序需要在操作系统 <strong>后台</strong> 一直运行，这在程序代码里的实现就是用死循环 ( <code>while (true)</code> ) 来实现的。但是，这样会出现一个问题，就是我们想要关闭程序怎么办？如果用暴力结束进程方式，那程序的内存中若还有未输出的数据，这部分数据将会遗失。因此，我们要对程序实现 <em>退出收尾</em> 操作，这就需要我们完善我们的程序，实现 <strong>“优雅”</strong> 地退出。</p>
<h2 id="后台进程"><a href="#后台进程" class="headerlink" title="后台进程"></a>后台进程</h2><p>首先，我们需要知道什么是后台进程。众所周知，我们与服务器进行交互都需要通过终端进行实现，而在终端上执行的程序都会默认将输出打印在终端界面里，而这中方式就 <strong>交互式进程</strong>，并且当前终端只能运行一个交互进程的，所以如果我们想在一个终端里运行多个任务，我们就需要将某些进程丢到 <strong>后台</strong> ，而这些进程不影响当前终端的交互执行，就被称为 <strong>“后台进程”</strong>。</p>
<p>所有的 <strong>交互式进程</strong> 都是可以转为 <strong>后台进程</strong> 的，因为进程的操作任务是一定的，只不过是它们的显示方式不同罢了，通常我们在一个终端里在任务后面加上 <em>&amp;</em> 操作符就可以让交互式进程变为后台执行进程了。如：</p>
<a id="more"></a>
<p><strong>前台进程</strong>：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/jiyiren/linuxfile</span><br></pre></td></tr></table></figure></div>
<p>如果按 <code>ctrl + c</code> 将会结束 <em>clone</em> 操作。</p>
<p>转为 <strong>后台进程</strong>：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/jiyiren/linuxfile &amp;</span><br><span class="line">[1] 70235</span><br></pre></td></tr></table></figure></div>
<p>我们可以看到此时该命令输出一个编号 <em>70235</em>，这个就是后台 <em>job</em> 的 ID，此时你按 <em>ctrl + c</em> 并不会结束改任务。如果要 <strong>查看 job 列表</strong>，可以使用 <code>jobs -l</code>, 如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">jobs</span> -l</span><br><span class="line">[1]+ 70235 运行中               git <span class="built_in">clone</span> https://gitee.com/jiyiren/linuxfile &amp;</span><br></pre></td></tr></table></figure></div>
<p>可以看到该任务在运行中，此时若想将该任务再 <strong>调到前台</strong>，可以使用 <code>fg % jobid</code> ( 注意百分号前后都有空格 ), 如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fg</span> % 70235</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/jiyiren/linuxfile</span><br><span class="line">remote: Total 15 (delta 3), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (15/15), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure></div>
<p>此时，显示的就是正在进程的任务，如果此时按 <code>ctrl + c</code> 则将取消 <em>clone</em> 操作。</p>
<p>上面是基本的 Linux 前后台任务转换命令，我们可以看到我们结束进程都是将任务调到前台，然后用 <code>ctrl + c</code>, 来结束进程的。然而，将任务从后台调到前台的方式只能在同一个终端里操作的，如果用户在将任务掉入后台后关闭了终端窗口，那么该任务是永远无法通过 <code>fg % jobid</code> 调到前台了。这时如果要结束该进程怎么办？</p>
<h2 id="KILL-命令"><a href="#KILL-命令" class="headerlink" title="KILL 命令"></a>KILL 命令</h2><hr>
<p>还好我们有终极杀器 – <code>kill</code> 命令，但 <code>kill</code> 命令操作的是 <strong>进程 ID</strong> 而非 <strong>job ID</strong>。也就是说 <strong>job ID</strong> 只能是同一个终端下的操作，相当于终端局域性的，而脱离了该终端后，该局域的 <strong>job ID</strong> 就不再有效。而 <strong>进程 ID</strong> 则是全局性的，任意终端都可以操作的，并且局域的 <strong>job ID</strong> 都会有与之对应的全局 <strong>进程 ID</strong> 的，因此如果关闭了那个 <strong>job ID</strong> 所在的终端，我们可以通过 <code>kill</code> <strong>job ID 对应的进程 ID</strong> 来结束此任务进程。</p>
<p>在我们平常的开发中，我们不可能一直维持着一个服务器的终端的，因此通过 <code>ctrl + c</code> 的方式结束 <strong>job ID</strong> 的方式对正式部署应用很不适合的，它只能适合个人的简单测试，因此 <code>kill</code> 命令方式才是 <em>统一而确实有效</em> 结束进程的方式。</p>
<p>假如，我们上面执行下面命令之后，就关闭掉了终端 ( 也不用管 <em>job ID</em> 了 )：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/jiyiren/linuxfile &amp;</span><br></pre></td></tr></table></figure></div>
<p>我们可以先通过 <code>ps</code> 命令来拿到我们的 <strong>进程 ID</strong>：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">ps -aux | grep linuxfile | grep -v grep</span><br><span class="line">jiyi  70376  0.0  0.0 116676  1536 pts/1    S    01:06   0:00 git <span class="built_in">clone</span> https://gitee.com/jiyiren/linuxfile</span><br><span class="line">jiyi  70377  5.7  0.4 174908  7952 pts/1    S    01:06   0:01 git-remote-https origin https://gitee.com/jiyiren/linuxfile</span><br><span class="line">jiyi  70379  3.3  0.0 124632  1136 pts/1    Sl   01:06   0:00 git fetch-pack --stateless-rpc --stdin --lock-pack --thin https://gitee.com/jiyiren/linuxfile/</span><br></pre></td></tr></table></figure></div>
<p>上面第一个 <code>grep</code> 后面就是自己要搜索的进程中包含的 <strong>关键词</strong>，这个自己根据自己的命令选择命令中的关键词，这样便于更好地过滤。第二个 <code>grep</code> 则是去除本身这个查找命令的意思。</p>
<p>我们从上面命令结果可以看到有三个进程与此任务对应，其中第二列是 <strong>进程的 ID</strong>, 我们可以用下面命令杀死该任务的所有进程：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 70376 70377 70379</span><br></pre></td></tr></table></figure></div>
<p>这样在终端里通过 <code>jobs -l</code> 可以看到已经没有任务在运行了。</p>
<h2 id="KILL-信号"><a href="#KILL-信号" class="headerlink" title="KILL 信号"></a>KILL 信号</h2><hr>
<p>通过上面的叙述，我们知道 <code>kill</code> 命令的作用。那么，上面的结束进程的命令 <code>kill -9</code> 的 <em>9</em> 是什么意思呢？实际上 <code>kill -9</code> 是 <code>kill -s 9</code> 的缩写，<code>-s</code> 后面接信号名称或者信号序号。而 <em>9</em> 代表的信号名为 <strong>SIGKILL</strong>, 也就是说 <code>kill -9</code> 也可以写成 <code>kill -s SIGKILL</code>. 此外，如果用信号名，字符的大小写是不敏感的，因此大家也可以写成 <code>kill -s sigkill</code>. 最后，由于所有的信号名都是以 <strong>SIG</strong> 打头的，因此，通常在我们自己写的程序中都是去掉 <strong>SIG</strong> 作为信号名的，因此，此命令还可以写成 <code>kill -s kill</code>. 这里我整理出 信号 <strong>9</strong> 所有相同功能的命令操作：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 [PID]</span><br><span class="line"><span class="built_in">kill</span> -s 9 [PID]</span><br><span class="line"><span class="built_in">kill</span> -s SIGKILL [PID]</span><br><span class="line"><span class="built_in">kill</span> -s sigkill [PID]</span><br><span class="line"><span class="built_in">kill</span> -s KILL [PID]</span><br><span class="line"><span class="built_in">kill</span> -s <span class="built_in">kill</span> [PID]</span><br></pre></td></tr></table></figure></div>
<p>大家可以把 <strong>SIGKILL</strong> 这个信号换成其他的也适用，但由于信号名称有点长，不太好记，因此，通常我们在操作命令的时候使用序号来执行 <code>kill</code> 命令。</p>
<p>那我们怎么知道有哪些信号？以及这些信号对应的序号呢？实际上 <code>kill</code> 命令还有一个参数 <code>-l</code>, 可以列出所有支持的 <strong>信号序号</strong> 以及 <strong>信号名</strong>：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1	64) SIGRTMAX</span><br></pre></td></tr></table></figure></div>
<p>大家也看到了，信号太多了，这里我挑选出最长用的信号进行说明：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">信号名	 信号序号	含义</span><br><span class="line">SIGHUP     1    终端断线</span><br><span class="line">SIGINT     2    中断（同 Ctrl + C）</span><br><span class="line">SIGQUIT    3    退出（同 Ctrl + \）</span><br><span class="line">SIGTERM   15    正常终止</span><br><span class="line">SIGKILL    9    强制终止</span><br><span class="line">SIGCONT   18    继续（与STOP相反， fg/bg命令）</span><br><span class="line">SIGSTOP   19    暂停（同 Ctrl + Z）</span><br><span class="line">SIGUSR1   10    用户自定义信号1</span><br><span class="line">SIGUSR2   12    用户自定义信号2</span><br></pre></td></tr></table></figure></div>
<p>这里我们只取其中的 <strong>结束进程的信号</strong> 来讲:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">SIGINT     2    中断（同 Ctrl + C）</span><br><span class="line">SIGTERM   15    正常终止</span><br><span class="line">SIGKILL    9    强制终止</span><br></pre></td></tr></table></figure></div>
<p>其中大家经常使用的 <code>ctrl + c</code> 快捷键就是发送了 <strong>SIGINT(2)</strong> 信号给进程的。另外，整个信号中，最特殊的命令就是 <strong>SIGKILL(9)</strong>, 它代表 <em>无条件结束进程</em>，也就是通常说的强制结束进程，这种方式结束进程有可能会导致进程内存中 <strong>数据丢失</strong>。而另外两个信号对于进程来说是可以选择性忽略的，但目前的绝大部分的进程都是可以通过这三个信号进行结束的。</p>
<p>那这三个结束命令到底有啥区别？对比如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">信号</th>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">正常结束</th>
<th style="text-align:center">无条件结束</th>
<th style="text-align:center">应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SIGINT(2)</td>
<td style="text-align:center">ctrl + c</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><strong>前台进程快捷终止</strong></td>
</tr>
<tr>
<td style="text-align:center">SIGTERM(15)</td>
<td style="text-align:center">无</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><strong>后台进程正常终止</strong></td>
</tr>
<tr>
<td style="text-align:center">SIGKILL(9)</td>
<td style="text-align:center">无</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><strong>后台进程强制终止</strong></td>
</tr>
</tbody>
</table>
<p>大家主要关注下各个信号的 <strong>应用场景</strong> 即可。</p>
<p>然而，我们的上线程序绝大部分都是后台进程在跑的，本篇内容也是讨论后台进程，因此我们主要看 <strong>后台进程的正常结束</strong>( <em>SIGINT(2)、SIGTERM(15)</em> ) 与 <strong>后台进程的强制结束</strong> ( <em>SIGKILL(9)</em> ) 的区别。</p>
<h2 id="正常与强制结束方式"><a href="#正常与强制结束方式" class="headerlink" title="正常与强制结束方式"></a>正常与强制结束方式</h2><hr>
<p>本篇讨论 <strong>Java</strong> 程序的后台程序 <strong>正常</strong> 与 <strong>强制结束</strong> 方式对比。在 Java 中，强制结束代表 <strong>直接立即结束</strong> 进程中的 <em>Main</em> 线程和其他所有线程，这里强调 <strong>直接和立即</strong>，也就是说通过强制方式，进程不会做任何收尾工作。而 <strong>正常结束</strong> 则非立即结束进程，而是先调用程序的 <strong>收尾线程</strong>，等收尾线程结束后再结束所有线程。</p>
<p>这里出现了 <strong>收尾线程</strong>，实际上这个就是 Java 程序中通过 <code>Runtime.getRuntime().addShutdownHook()</code> 方式注册的线程就是收尾线程。为了更详细地说明正常结束与强制结束的区别我们先定义一个工作线程 <code>JobThread</code>：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工作线程，每秒钟输出一个递增的数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Work Thread: "</span> + count++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>另外我们再定义一个收尾线程 <code>ShudownHookThread</code>：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 收尾线程，没 0.5 秒输出一个递减的数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShudownHookThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Shutdown Thread: "</span>+count--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>现在在 Main 函数中先注册收尾线程，然后再启动工作线程：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> ShudownHookThread());</span><br><span class="line">        JobThread jobThread = <span class="keyword">new</span> JobThread();</span><br><span class="line">        jobThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>然后打包成 Jar 包 ( 假设名字为 jvmexit-example.jar )，我们通过下面命令启动程序:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">java -jar jvmexit-example.jar</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure></div>
<p>我们可以看到工作线程每隔 <strong>1</strong> 秒输出一个数字，此时如果我们来通过正常和强制执行看看他们相应的输出。</p>
<p>正常结束 <code>kill -2 [PID]</code> 或者 <code>kill -15 [PID]</code>：</p>
<p><img src="http://img.godjiyi.cn/csdnblogjvmexit01.jpg" alt></p>
<p>强制结束 <code>kill -9 [PID]</code> :</p>
<p><img src="http://img.godjiyi.cn/csdnblogjvmexit02.jpg" alt></p>
<p>从中我们可以看出 <strong>正常结束</strong> 方式，会 <em>先调用收尾线程</em>，然后再结束，而 <strong>强制结束</strong> 则直接 <em>杀死所有线程</em>。因此，这里给出优雅结束进程说明：</p>
<ul>
<li>先定义自己的 <strong>收尾线程</strong> 要完成的任务，比如：清理内存，将未完成的 IO 操作完成，删除缓存文件等等；</li>
<li><em>Main</em> 函数里，在主任务启动之前注册 <strong>收尾线程</strong> 即可完成收尾任务的注册；</li>
<li>使用 <code>kill</code> 的 <strong>SIGIN(2)</strong> 和 <strong>SIGTERM(15)</strong> 两个信号进行进程结束，则 <strong>收尾线程</strong> 会被调用；</li>
</ul>
<h2 id="自定义-kill-信号处理"><a href="#自定义-kill-信号处理" class="headerlink" title="自定义 kill 信号处理"></a>自定义 kill 信号处理</h2><hr>
<p>我们前面也讲过，除了信号 <strong>SIGKILL(9)</strong> 外，其他信号对于进程来说都是可忽略的。而这个忽略就是自己在自己的任务进程里实现这些信号的监听。</p>
<p>Java 中有提供一个接口 <code>SignalHandler</code>，完整名 <code>sun.misc.SignalHandler</code>，我们只要实现该接口，就可以在接收到信号后进行一些相应处理了。</p>
<p>我们定义类 <code>SignalHandlerImp</code> 其实现接口 <code>SignalHandler</code>：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignalHandlerImp</span> <span class="keyword">implements</span> <span class="title">SignalHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Signal signal)</span> </span>&#123;</span><br><span class="line">        System.out.println(signal.getName()+<span class="string">":"</span>+signal.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>类内部只有一个要实现的方法 <code>public void handle(Signal signal)</code>, 而我们在方法里仅仅是打印了信号的名称和序号。然后在 <em>Main</em> 函数里注册一下</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 注册要监听的信号</span></span><br><span class="line">        SignalHandlerImp signalHandlerImp = <span class="keyword">new</span> SignalHandlerImp();</span><br><span class="line">        Signal.handle(<span class="keyword">new</span> Signal(<span class="string">"INT"</span>), signalHandlerImp);     <span class="comment">// 2  : 中断（同 ctrl + c ）</span></span><br><span class="line">        Signal.handle(<span class="keyword">new</span> Signal(<span class="string">"TERM"</span>), signalHandlerImp);    <span class="comment">// 15 : 正常终止</span></span><br><span class="line">        Signal.handle(<span class="keyword">new</span> Signal(<span class="string">"USR2"</span>), signalHandlerImp);    <span class="comment">// 12 : 用户自定义信号</span></span><br><span class="line">        </span><br><span class="line">        JobThread jobThread = <span class="keyword">new</span> JobThread();</span><br><span class="line">        jobThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>主函数里我们监听了三个信号：<strong>SIGINT(2)</strong>, <strong>SIGTERM(15)</strong>, <strong>SIGUSR2(12)</strong>, 同时我们也用到了上一节使用的工作线程 <code>JobThread</code> ( 注意这里没有用到上节的扫尾进程 ), 让我们来重新打包并启动任务 。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">java -jar jvmexit-example.jar</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure></div>
<p>执行结果是一样的，每秒输出一个数字，那我们来分别执行:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">// pid 换成自己的进程 ID</span><br><span class="line">kill -2 [PID]</span><br><span class="line">kill -15 [PID]</span><br><span class="line">kill -12 [PID]</span><br><span class="line">kill -9 [PID]</span><br></pre></td></tr></table></figure></div>
<p>得到的结果如下：</p>
<p><img src="http://img.godjiyi.cn/csdnblogjvmexit03.jpg" alt></p>
<p>从中我们可以看出自定义的信号处理方式，<strong>正常结束的信号</strong> ( <strong>SIGINT(2)</strong> 和 <strong>SIGTERM(15)</strong> ) 都不会结束进程，而只是执行自己自定义的方法，然而 <strong>强制结束信号</strong> ( <strong>SIGKILL(9)</strong> ) 则不会被自定义监控，大家自己可以尝试下在 <em>Main</em> 函数中注册 <em>KILL</em> 信号，如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">Signal.handle(<span class="keyword">new</span> Signal(<span class="string">"KILL"</span>), signalHandlerImp);    <span class="comment">// 9 : 强制终止</span></span><br></pre></td></tr></table></figure></div>
<p>这个在运行的时候就会报错，因此 <strong>SIGKILL(9)</strong> 信号是唯一不能够被自定义的信号。</p>
<p>那既然我们自己可以自定义信号，那我们通过自定义的信号来处理我们的收尾操作也是可行的。因此我们只要在 <code>SignalHandler</code> 接口的实现类中 <code>handle</code> 方法中处理自己的收尾操作就可以了。这里也整理下自定义信号处理进行收尾的说明：</p>
<ul>
<li>实现 <code>SignalHandler</code> 接口，在 <code>handle</code> 方法中实现自己的收尾操作；</li>
<li><em>Main</em> 函数里，在主任务启动之前注册 <strong>自定义信号名</strong> 即可完成收尾任务的注册，只需要注册一个就行了；</li>
<li>使用 <code>kill</code> 的 对应 <strong>自定义信号名</strong> 进行任务进程的结束，就可以正常收尾了。</li>
</ul>
<p>另外，在实际操作中使用自定义信号的方式通常是直接让 <strong>工作线程</strong> 实现 <code>SignalHandler</code> 接口的，我们上面是为了举例，以不至于发送对应信号后进程就停止了，而实际情况下是需要我们发送信号工作线程就应该停止，因此可以将上面的工作线程修改如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工作线程，每秒钟输出一个递增的数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">SignalHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isStop = fals;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!isStop) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Work Thread: "</span> + count++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Signal signal)</span> </span>&#123;</span><br><span class="line">    	  isStop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// do other something;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如上所示，加一个运行 <em>标识</em>，并在收到信号后进行 <em>标识</em> 的反赋值，这样工作线程就会自动停止，当然还可以进行其他相关操作。</p>
<h2 id="两种方式对比"><a href="#两种方式对比" class="headerlink" title="两种方式对比"></a>两种方式对比</h2><hr>
<p>本文接收两种优雅 ( 而非暴力 <code>kill -9</code> ) 结束进程方式：</p>
<ol>
<li>采用默认信号处理机制，通过 <code>Runtime.getRuntime().addShutdownHook(new ShudownHookThread());</code> 实现收尾进程的注册，这样在收到默认正常结束信号 ( <strong>SIGINT(2)</strong> 和 <strong>SIGTERM(15)</strong> ) 就可优雅退出；</li>
<li>采用自定义信号处理机制，通过 <code>Signal.handle(new Signal(&quot;USR2&quot;), new SignalHandlerImp());</code> 注册 <strong>自定义信号</strong> 以及 <strong>信号处理实现类</strong>，这样使用 <strong>kill -自定义信号 ( 如： SIGUSR2(12) ) [PID]</strong> 就可以达到收尾操作在 <strong>信号处理实现类</strong> 里实现，从而也可实现优雅退出。</li>
</ol>
<p>那这两种方式哪个更好点？或者说适应性更广泛一点？</p>
<p>这里我参考了 <a href="https://tech.imdada.cn/2017/06/18/jvm-safe-exit/" target="_blank" rel="noopener">JVM 安全退出</a> 这篇文章，它给出了 JVM 关闭的不止有 <strong>正常关闭</strong>、<strong>强制关闭</strong> 还有一种 <strong>异常关闭</strong> 如下图：</p>
<p><img src="http://img.godjiyi.cn/csdnblogjvmexit04.bmp" alt></p>
<p>这种方式还是会调用以 <code>Runtime.getRuntime().addShutdownHook(new ShudownHookThread());</code> 此方法注册的 <strong>收尾线程</strong> 的，而不会触发自定义的信号通信的。因此，还是第一种默认信号处理机制，通过 <strong>Hook</strong> 线程方式适应性更广泛。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://tech.imdada.cn/2017/06/18/jvm-safe-exit/" target="_blank" rel="noopener">JVM 安全退出</a></li>
<li><a href="https://blog.csdn.net/moonpure/article/details/80404390" target="_blank" rel="noopener">Java 程序优雅关闭的两种方法</a></li>
<li><a href="http://man.linuxde.net/kill" target="_blank" rel="noopener">kill 命令</a></li>
<li><a href="https://blog.csdn.net/dd864140130/article/details/49155179" target="_blank" rel="noopener">深入 JVM 关闭与关闭钩子</a></li>
<li><a href="http://www.baiyuxiong.com/?p=1002" target="_blank" rel="noopener">Java 通过 kill 命令关闭程序 DEMO 示例</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>论文收录平台 ( SCI、EI 等 ) 详细说明</title>
    <url>/2017/11/18/papersci/</url>
    <content><![CDATA[<p align="center" style="margin: 30px 0 35px;">学术论文平台一点通，毕业论文不再是难事</p>

<p>最近发论文的需求逐渐被提高上来，身边的同学也在忙碌自己的研究，准备发篇论文以应对论文开题。但我们学校对发的论文有一定要求，需要被至少 <strong>SCI、EI、北大核刊</strong> 录入才可以，但是全球期刊和会议多之又多，<em>怎么确定哪个会议被哪个平台是否录入，哪个学术会议或期刊价值更高点，以及怎么对各个平台进行索引搜索</em>，这就需要自己详细地了解各种平台以及各个名词，下面记录下自己的了解。</p>
<ul>
<li>主要关键词：<strong>ISI、SCI、SCIE、SSCI、JCR、ESI、EI、ISTP、IEEE、CCF</strong>等说明；</li>
<li>各个服务的<strong>检索网址说明</strong>；</li>
<li><strong>中国索引服务</strong>介绍</li>
</ul>
<h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><hr>
<h3 id="SCI"><a href="#SCI" class="headerlink" title="SCI"></a>SCI</h3><p><strong>SCI</strong> 的英文全称为 <em>Science Citation Index</em> ，即 <strong>《科学引文索引》</strong>，简称 <strong>《SCI》</strong>，是美国科技情报研究所（ <em>Institute for Scientific Information</em> 简称“ <strong>ISI</strong> ” ）于 1961 年创办的国际权威检索系统，其创始人为 <strong>尤金·加菲尔德</strong>（ Eugene Garfield, September 16, 1925～2017 ）。</p>
<a id="more"></a>
<h3 id="SCIE"><a href="#SCIE" class="headerlink" title="SCIE"></a>SCIE</h3><p><strong>SCIE</strong> 即 <em>SCI Expanded</em> 为 《科学引文索引扩展版》（即网络版），上面的 <strong>SCI</strong> 则主要 <em>指来源刊为3700多种的SCI印刷版和SCI光盘版</em>；而 <strong>SCIE</strong> <em>则收录了5600多种来源期刊，提供WEB检索服务</em>，随着网络的普及，现在我们 <strong>高校所讲的SCI</strong> 通常是包 <strong>原SCI+SCIE</strong> 的,而网络上能检索的通常是 <strong>SCIE</strong>，所以一般网上讲的 SCI 通常都是指 <strong>SCIE</strong>。</p>
<h3 id="SSCI"><a href="#SSCI" class="headerlink" title="SSCI"></a>SSCI</h3><p><strong>SSCI</strong> 即 <em>Social Sciences Citation Index</em> 为 <strong>《社会科学引文索引》</strong>，也由 <strong>ISI</strong> 创建，是 <strong>SCI(原SCI+SCIE)</strong> 的姊妹篇。主要收录 1809 种世界最重要的 <strong>社会科学</strong> 期刊，内容覆盖包括人类学、法律、经济、历史、地理、心理学等 55 个领域。收录文献类型包括：研究论文，书评，专题讨论，社论，人物自传，书信等。选择收录 ( Selectively Covered ) 期刊为 1300 多种。</p>
<h3 id="JCR"><a href="#JCR" class="headerlink" title="JCR"></a>JCR</h3><p><strong>JCR</strong> 即 <em>Journal Citation Reports</em> 为 <strong>《期刊引用报告》</strong>，也由 <strong>ISI</strong> 出版，每年出版一次，其主要是对 <strong>SCIE</strong> 和 <strong>SSCI</strong> 收录的期刊的引用和被引用数据进行统计、运算，并针对每种期刊定义了 <em>影响因子（Impact Factor，缩写IF）</em> 等指数加以报道。该指数主要作为 <strong>期刊(并非论文)的评价工具</strong>。一种刊物的影响因子越高，也即其刊载的文献被引用率越高，一方面说明这些文献报道的研究成果影响力大，另一方面也反映该刊物的学术水平高。</p>
<h3 id="ESI"><a href="#ESI" class="headerlink" title="ESI"></a>ESI</h3><p><strong>ESI</strong> 即 <em>Essential Science Indicators</em> 为 <strong>《基本科学指标》</strong>,也由 <strong>ISI</strong> 出版，于 2001 年推出的衡量科学研究绩效、跟踪科学发展趋势的基本分析评价工具，也是基于 SCI 和 SSCI 所收录的 12000 多种学术期刊的1000多万条文献记录而建立的计量分析数据库，这个可用于 <strong>评价论文、作者、高校、学术机构、国家/地区国际学术水平及影响力的重要评价指标</strong>，因此很多学校很看重这个。</p>
<p><strong>ESI</strong> 指标会每 <em>两个月更新一次</em>，其每次都会将评判的所有期刊和会议列表成文档，放在官网提供下载，因此也会有很多高校会要求学生发表的论文期刊或会议在此列表中。<strong>ESI</strong> 每次更新的文档下载地址：<a href="http://ipscience-help.thomsonreuters.com/incitesLive/ESIGroup/overviewESI/esiJournalsList.html" target="_blank" rel="noopener">ESI评价期刊列表下载</a></p>
<h3 id="Web-of-Science"><a href="#Web-of-Science" class="headerlink" title="Web of Science"></a>Web of Science</h3><p><strong>Web of Science</strong> 简称 <strong>WOS</strong> 是由 <strong>Thomson Scientific(汤姆森科技信息集团)</strong> 推出的综合性学术信息资源平台，其具有丰富而强大的检索功能–普通检索、被引文献检索、化学结构检索，您可以方便快速地找到有价值的科研信息，即可以越查越旧，也可以越查越新，全面了解有关某一学科、某一课题的研究信息。它的资源库 <em>除了SCIE，还有SSCI，还有A&amp;HCI ( 人文和艺术引文索引 ),也包括其他扩充的数据资源库 ( 如：KCI,韩国期刊数据库 )</em>。</p>
<h3 id="Web-of-Knowledge"><a href="#Web-of-Knowledge" class="headerlink" title="Web of Knowledge"></a>Web of Knowledge</h3><p><strong>Web of Knowledge</strong> 是由 <strong>Thomson Scientific(汤姆森科技信息集团)</strong> 开发的信息检索平台，该平台包含了 <strong>Web of Science(主要是学术论文、会议录和新增的学术图书数据库)</strong>，还有 <strong>专利数据库</strong>，还有 <strong>JCR(Journal Citation Reports)</strong>，以及 <strong>ESI(Essential Science Indicators)</strong> 等数据检索服务。这个是所有检索服务的入口平台，官网为：<a href="http://www.webofknowledge.com" target="_blank" rel="noopener">http://www.webofknowledge.com</a>。</p>
<p><em>对于 Web of Science 和 Web of Knowledge区别?</em>，可以打个比方：<em>Web of Knowledge</em> 就相当于Microsoft Windows操作系统，而 <em>Web of Science</em> 则相当于Microsoft Office一套办公软件，正如Microsoft Windows平台除了可以跑Microsoft Office之外，还可以跑各种应用程序一样，Web of Knowledge平台除了 <em>Web of Science</em> 还包括 <em>专利数据库服务</em>、<em>JCR服务</em>、<em>ESI服务</em> 等。详细说明可以查看 <a href="http://blog.sciencenet.cn/blog-408109-548440.html" target="_blank" rel="noopener">这里</a>。</p>
<blockquote>
<p><em>注意</em>：这个网址 <em>不是免费的</em>，各大高校访问会根据学校 ip 自动登录就可以检索了，因为高校通常购买了使用权，但如果使用的普通外网则不能够访问。</p>
</blockquote>
<p>官网首页–默认为 <strong>Web of Science</strong> 板块,查询 <strong>SCI</strong> 文章:</p>
<p><img src="http://img.godjiyi.cn/sciarticle2.jpg" alt></p>
<p>其次– <strong>JCR</strong> 板块，查询期刊影响因子:</p>
<p><img src="http://img.godjiyi.cn/sciarticle3.jpg" alt></p>
<p>另外– <strong>ESI</strong> 板块，查询论文、作者、机构等排名:</p>
<p><img src="http://img.godjiyi.cn/sciarticle4.jpg" alt></p>
<h3 id="EI"><a href="#EI" class="headerlink" title="EI"></a>EI</h3><p><strong>EI</strong> 即 <em>The Engineering Index</em> 为 <strong>《工程索引》</strong>，由 <em>美国工程师学会联合会</em> 于 1884 年创办的历史上最悠久的一部大型综合性检索工具,<strong>EI</strong> 每月出版1期，文摘 1.3 万至 1.4 万条；每期附有主题索引与作者索引；每年还另外出版年卷本和年度索引，年度索引还增加了作者单位索引。收录文献几乎涉及 <strong>工程技术</strong> 各个领域。例如：动力、电工、电子、自动控制、矿冶、金属工艺、机械制造、土建、水利等。它具有综合性强、资料来源广、地理覆盖面广、报道量大、报道质量高、权威性强等特点。</p>
<ul>
<li>这个是 <em>EI数据库官网</em>：<a href="http://www.engineeringvillage.com" target="_blank" rel="noopener">http://www.engineeringvillage.com</a></li>
<li>这个是 <em>EI公司的官网</em>：<a href="http://www.elsevier.com/" target="_blank" rel="noopener">http://www.elsevier.com</a> （ <em>查 EI 论文，这个网址不需要</em> ）</li>
<li>检索 <em>说明教程</em>：<a href="http://www.eipaperbx.com/mod_static-view-sc_id-3.html" target="_blank" rel="noopener">图文说明</a></li>
</ul>
<h3 id="ISTP"><a href="#ISTP" class="headerlink" title="ISTP"></a>ISTP</h3><p><strong>ISTP</strong> 即 <em>Index to Scientific &amp; Technical Proceedings</em>，为<strong>《科技会议录索引》</strong> 简称 <strong>ISTP</strong>，创刊于 1978 年，由 <em>美国科学情报研究所(ISI)</em> 编辑出版。<strong>SCI、EI、ISTP是世界著名的三大科技文献检索系统</strong>，是国际公认的进行科学统计与科学评价的主要检索工具,其中以SCI最为重要。<strong>ISI</strong> 基于 Web of Science 的检索平台，将 ISTP（ 科学技术会议录索引 ）和 ISSHP（ 社会科学及人文科学会议录索引 ）两大会议录索引集成为 ISI Proceedings。集成之后 ISTP 分为文科和理科两种检索，分别是 CPCI-SSH 和 CPCI-S。所以它们还统称为 <strong>ISTP</strong>，也有人叫它们 <strong>CPCI</strong>。</p>
<h3 id="IEEE"><a href="#IEEE" class="headerlink" title="IEEE"></a>IEEE</h3><p><strong>IEEE</strong> 即 <em>Instituteof Electrical and Electronics Engineers</em> 为 <strong>美国电气和电子工程师协会</strong> 是一个国际性的电子技术与信息科学工程师的协会，是世界上最大的专业技术组织之一（ 成员人数 ），拥有来自 175 个国家的 36 万会员( 到2005年 )。该组织在太空、计算机、电信、生物医学、电力及消费性电子产品等领域中都是主要的权威。</p>
<ol>
<li><em>IEEE</em> 就和IEE（现在是IET）是英国的，IEICE是日本，CIE（中国电子协会）是中国的一样，它属于一个 <em>学术组织</em> ，不是数据库</li>
<li>既然是学术组织，一般都有自己的学术刊物，对于IEEE主要有 <em>Transactions（汇刊，会刊或学报），Journal（学报），Magazine（杂志）和Letters（快报，通讯）等</em></li>
<li>而SCI和EI只是检索工具，严格来讲其不是论文内容数据库，因为检索内容和论文内容不是一个意思，例如：<em>你可以用SCI工具检索到大部分IEEE刊物论文信息，但是SCI（ISI<br>Thompson）是无法提供论文内容的，因为他们的检索信息是各个刊物提供的</em>，你要获取全文需要访问付费数据库，例如IEEExplore,Elsevier数据库等。</li>
<li>与IEEE相似概念的有：<strong>ACM</strong> (<em>Association for Computing Machinery</em> ) 中文：<em>国际计算机学会</em>。ACM是一个世界性的计算机从业员专业组织，创立于1947年。 <strong>CCF</strong> (<em>China Computer Federation</em>),<em>中国计算机学会</em>,成立于1962年，是中国计算机科学与技术领域群众性学术团体。</li>
</ol>
<h3 id="CCF"><a href="#CCF" class="headerlink" title="CCF"></a>CCF</h3><p><strong>CCF</strong> : 即 <em>China Computer Federation</em> 为 <strong>中国计算机学会</strong>，成立于 1962 年，是中国 <strong>计算机科学与技术领域</strong> 群众性学术团体。注意此处是专注 <strong>计算机科学与技术</strong>，因此很多计算机专业的学院都会要求发表的论文为 <em><a href="http://www.ccf.org.cn/xspj/gyml/" target="_blank" rel="noopener">CCF推荐会议或期刊</a></em> 论文,CCF自动将各个期刊和会议分为 <em>A、B、C类</em>，A 类为顶会期刊或会议。</p>
<p><img src="http://img.godjiyi.cn/sciarticle5.jpg" alt></p>
<h3 id="中科院JCR期刊分区"><a href="#中科院JCR期刊分区" class="headerlink" title="中科院JCR期刊分区"></a>中科院JCR期刊分区</h3><p><strong>中科院JCR期刊分区</strong> : 分区是为了区别期刊的影响力等级，这与 <strong>CCF</strong> 中的 A类、B类、C类是同一个意思，只不过这里通常划分为四个分区。而分区主要还是基于 <em>汤森路透公司</em>(ISI隶属于此公司)的 <em>JCR(《期刊引用报告》)</em>, JCR 中定义了的 <em>影响因子</em> ( Impact Factor 简称 IF )就是决定分区方法的主要因素。分区也主要分为两种分区方式，一个就是汤森路透公司自己的分区方法 – <strong>汤森路透分区法</strong>，另外就是我们中国中科院的分区方法– <strong>中国科学院分区法</strong>，两者分区区别请看 <a href="http://blog.163.com/ly7148@126/blog/static/16646527620153154302991/" target="_blank" rel="noopener">SCI汤森路透分区法和中国科学院分区法的区别</a></p>
<p>(1). <strong>汤森路透分区法</strong> : 检索是通过上文提到的 <em><a href="http://www.webofknowledge.com" target="_blank" rel="noopener">Web of Knowledge</a></em> 中的 JCR模块查询。</p>
<p>(2). <strong>中科院JCR期刊分区</strong> : 检索地址为：<a href="http://www.fenqubiao.com/" target="_blank" rel="noopener">http://www.fenqubiao.com/</a>,这也需要账号的，高校通常会提供。</p>
<p><em>首页登录</em></p>
<p><img src="http://img.godjiyi.cn/sciarticle6.jpg" alt></p>
<p><em>浏览期刊排名</em></p>
<p><img src="http://img.godjiyi.cn/sciarticle7.jpg" alt></p>
<p><em>检索服务</em></p>
<p><img src="http://img.godjiyi.cn/sciarticle8.jpg" alt><br><img src="http://img.godjiyi.cn/sciarticle9.jpg" alt></p>
<h3 id="国内索引服务"><a href="#国内索引服务" class="headerlink" title="国内索引服务"></a>国内索引服务</h3><p>上面讲的核心都是国外提供的索引服务，对于国内的，也是有的,下面这些来源于知乎，地址：<a href="https://www.zhihu.com/question/31558495" target="_blank" rel="noopener">https://www.zhihu.com/question/31558495</a></p>
<ol>
<li><strong>中文核心期刊要目总览</strong> ( <em>PKU</em> ): 因是北京大学 图书馆主持发布的，俗称中文核心，北大核心。内容包含全面，既有自然科学类又有人文社会科学类。(<em>北大图书馆带领一堆专家玩小聚会，玩出了境界，门类齐全但每个门类都很少，两千种左右。武林至尊谁敢不从，一般没有特别要求的核心都是说它</em>)</li>
<li><strong>中文社会科学引文索引</strong> ( <em>CSSCI</em> )，因为是南京大学 中国社会科学研究评价中心主持发布的，俗称南大核心。只包含人文社会科学类。(十几所高校联合起来搞高级酒会，搞出了高度，社科类就玩五百多种期刊啦，文科仔们都气冒烟了)</li>
<li><strong>中国科技论文统计源期刊</strong> ( <em>ISTIC</em> )，是中国科技部 中国科学技术信息研究所主持发布的 中国科技期刊引证报告 中的核心部分，俗称统计源核心，中国科技核心。包含自然科学类，极少部分人文社科类的。一千六百左右吧。( 还是我科技部的敞亮，理工仔们扬眉吐气了，自然期刊比北大多了不少种嘛。尤其吸收的医学生物学，医学类比例都占三分之一了，外号叫医学核心也不是没有道理。但后来竟然吸收了社科的我也不懂为什么。)</li>
<li><strong>中国科学引文数据库来源期刊</strong> ( <em>CSCD</em> )，是由中国科学院 文献情报中心发布的统计源的核心部分，俗称中科院核心。好像是申请国家基金项目的硬指标啊。只是包含自然科学类的。核心部分八百种左右。( 科学院也不想让理工仔们活的潇洒啊，勒紧你们的紧箍咒 )</li>
<li><strong>中国人文社会科学核心期刊</strong> ( <em>CHSSCD</em> )，中国社科院 文献计量与科学评价研究中心发布的 中国人文科学核心期刊要览 中的核心部分，俗称应该就是人文社科核心，社科院核心吧，包含人文社会科学类。五百种左右。(社科院的姿态，怒刷存在感)</li>
<li><strong>中国人文社会科学报核心期刊</strong>,评选出的都是大学学报的社科版啦，好像不受关注的样子。(大学学报们这也能搞出来个学会，城会玩。也来开个party，我发现社科仔们真会玩啊)</li>
<li><strong>中国核心期刊(遴选)数据库</strong>，<em><a href="http://www.wanfangdata.com.cn/" target="_blank" rel="noopener">万方数据</a>股份有限公司</em> 的(开个私人会所，没背景也没NB评审团的，倒是起了个招摇的名字，我服了你了，印在封面上唬人一来一来的。)</li>
<li><strong>中国期刊全文数据库</strong> ( <em>CJFD</em> )，<em><a href="http://www.cnki.net/" target="_blank" rel="noopener">中国知网CNKI</a></em>，原名中国期刊网，同方知网技术有限公司，全国八千多种期刊，(什么叫闷声发大财，垄断就在你的屏幕上摆着呢，我就问你买不买？)</li>
<li><strong>中国科技期刊数据库</strong>，<em><a href="http://qikan.cqvip.com/" target="_blank" rel="noopener">维普</a>，重庆维普资讯有限公司</em>，尽收一万两千多种期刊。(收破烂专家的样子)。</li>
<li><strong>中国权威学术期刊</strong> ( <em>RCCSE</em> )，在武汉大学中国科学评价研究中心与武汉大学图书馆和信息管理学院联合研发完成的 RCCSE 中国学术期刊评价研究报告——权威、核心学术期刊排行榜，俗称武大核心。三百多种。(威呜呜呜呜，权威两个字就问你们怕不怕，哈哈)</li>
<li><strong>中国学术期刊综合评价数据库</strong>，以中国学术期刊（光盘版）和中国期刊网专题全文数据库的评价数据为基础而建立起来的大型数据库。<em>中国知识资源总库（ CNKI ）</em>、清华大学主办、中国学术期刊（ 光盘版 ）电子杂志社出版、清华同方知网（ 北京 ）技术有限公司发行、数百位科学家、院士、学者参与建设，精心打造的大型知识服务平台和数字化学习系统。(圈地，<em>知网</em> 这步棋走的好啊，一统江湖)</li>
<li><strong>人大报刊复印资料</strong>，中国人民大学《复印报刊资料》由中国人民大学书报资料中心出版，该数据库从国内公开出版的近六千种核心期刊与专业特色期刊中精选全文并汇编而成，囊括了人文社会科学领域中的各个学科。( 普遍是白皮封装，文章被其收录是刊物和论文的一种荣誉吧 )</li>
<li><strong>新华文摘</strong>，新华文摘是人民出版社主办的是一个大型的综合性、学术性、资料性的文摘半月刊，其选登文章代表了诸领域的前沿思想。同上，收录的也是其他期刊已经发表的优秀文章。在有的职称评选条件中，人大复印资料和新华文摘被承认国家级核心刊物。</li>
</ol>
<h3 id="本校要求的索引平台"><a href="#本校要求的索引平台" class="headerlink" title="本校要求的索引平台"></a>本校要求的索引平台</h3><p>下面是我自己学校研究生论文要求平台而提供的说明：</p>
<p><img src="http://img.godjiyi.cn/sciarticle10.jpg" alt></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.zhihu.com/question/21111557" target="_blank" rel="noopener">SCI、EI、IEEE 是什么关系？国际会议、期刊、快报又有什么区别？</a></li>
<li><a href="http://blog.sciencenet.cn/blog-408109-548440.html" target="_blank" rel="noopener">Web of Knowledge 与 Web of Science 以及 SCIE 之间的关系</a></li>
<li><a href="http://blog.sciencenet.cn/blog-408109-902187.html" target="_blank" rel="noopener">影响因子本来是干什么的？看看SCI之父怎么说</a></li>
<li><a href="http://www.webofknowledge.com/" target="_blank" rel="noopener">Web of Knowledge 官网</a></li>
<li><a href="http://www.dxy.cn/bbs/thread/29300006#29300006" target="_blank" rel="noopener">SCI 与 SCIE 区别扫盲!</a></li>
<li><a href="http://www.lib.whu.edu.cn/dc/viewdc.asp?id=17" target="_blank" rel="noopener">工程索引网络版</a></li>
<li><a href="http://www.eipaperbx.com/mod_static-view-sc_id-3.html" target="_blank" rel="noopener">EI 检索查询</a></li>
<li><a href="https://www.douban.com/group/topic/11186089/" target="_blank" rel="noopener">IEEE 和 SCI 等的通俗简介</a></li>
<li><a href="http://blog.163.com/ly7148@126/blog/static/16646527620153154302991/" target="_blank" rel="noopener">SCI 汤森路透分区法和中国科学院分区法的区别</a></li>
<li><a href="https://www.zhihu.com/question/31558495" target="_blank" rel="noopener">SCI、EI、核心期刊 这些东西等级是怎么区分的？</a></li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>SCI</tag>
        <tag>EI</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Struts2 配置说明及后缀与路径设置</title>
    <url>/2016/01/11/structs2-config/</url>
    <content><![CDATA[<p><a href="http://struts.apache.org/" target="_blank" rel="noopener">Struts2</a> 作为传统 <em>WebWork</em> 的继承者，融合 <em>Struts1</em>, 使得它成为高度成熟的框架。<em>POJO</em> 与 <em>OGNL</em> 两大特性也使得它成为简单易用的框架，成为现在初学者的入手框架。其中 <em>Struts</em> 的配置文件 <strong>struts.xml</strong> 是领悟 <em>Struts2</em> 的核心。本文首先介绍 <em>Struts2</em> 的基本配置以免初学者感觉突兀，第二部分的路径部分为主要要讲解的内容 ( 本人实践多次的经验 )。</p>
<h2 id="一、如何学习Struts2框架"><a href="#一、如何学习Struts2框架" class="headerlink" title="一、如何学习Struts2框架"></a>一、如何学习Struts2框架</h2><h3 id="1、入手"><a href="#1、入手" class="headerlink" title="1、入手"></a>1、入手</h3><p>官网下载</p>
<p>所有我们所要学习的目标，我们都要找到其最原始的地方，通常都有其自己的官网。<em>Struts2</em> 官网地址：<a href="http://struts.apache.org/" target="_blank" rel="noopener">http://struts.apache.org/</a>, 下载 zip 包到本地，解压后目录如下</p>
<a id="more"></a>
<p><img src="http://img.godjiyi.cn/strut21.png" alt></p>
<p>目录介绍</p>
<ul>
<li><strong>apps</strong>为利用 <em>Struts2</em> 框架写的项目，后缀都是 <em>war</em>, 所以可以把他们放到 <em>Tomcat</em> 的 <em>webapps</em> 目录下直接运行。</li>
<li><strong>docs</strong>为 <em>Struts2</em> 框架的文档教程。</li>
<li><strong>lib</strong>为 <em>Struts2</em> 框架的所有用到的 jar 包，有很多，但是我们的项目用不到那么多的。只需要核心的几个。</li>
<li><strong>src</strong>为 <em>Struts2</em> 框架的源码。</li>
</ul>
<h3 id="2、使用-Struts2-框架"><a href="#2、使用-Struts2-框架" class="headerlink" title="2、使用 Struts2 框架"></a>2、使用 Struts2 框架</h3><p><em>使用框架实际上就是利用他们提供的依赖，使用他们的接口。所以我们只需将所用的框架的依赖添加到自己项目里，然后配置使用。</em></p>
<p><strong>手动添加 jar 包</strong></p>
<p>对于 <em>Struts2</em> 的依赖包都在 lib 文件夹里，但是 <em>lib</em> 下有很多包，当然不是每一个都加入项目。我们可以打开 <em>apps</em> 目录下的 <strong>struts2-blank.war</strong> 文件，直接解压缩得到文件夹，打开 <code>WEB-INF\lib</code> 目录，下面的包就是核心的几个需要包：</p>
<p><img src="http://img.godjiyi.cn/strut22.png" alt></p>
<p>把他们复制到自己的 web 项目 <code>WEB-INF/lib</code> 目录下面就可以用了。</p>
<p><strong>Maven 管理 jar 包</strong></p>
<p>用 <em>Maven</em> 管理则很简单，只需要在 <em>dependencies</em> 里加入</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.struts<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>struts2-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h3 id="3、Struts2-配置"><a href="#3、Struts2-配置" class="headerlink" title="3、Struts2 配置"></a>3、Struts2 配置</h3><p><em>web.xml</em> 里配置</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>在 <em>web</em> 配置里加入了全局 <em>action</em> 拦截器。</p>
<p><em>struts.xml</em> 配置</p>
<p>下面为我学习记录的：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</span></span><br><span class="line"><span class="meta">"http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果本配置里内容太多，不好管理，可以将配置文件分为多个配置文件。--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如下就包括了struts-login.xml，在所包括的配置里所有的struts的配置都字符都不能少的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"struts-login.xml"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认包  没有命名空间 默认为--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- action名是url访问名--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 访问地址http://127.0.0.1:8080/ProjectName/hello.action--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"default"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">result</span>&gt;</span>/hello.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 包名userlogin，包名主要是为了分类，对url没有影响。命名空间是/user，它只对url有影响--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- action名是url访问名 class是操作aciton的类--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将包的命名空间和action名 合并作为url访问的最终地址如下--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 访问地址http://127.0.0.1:8080/ProjectName/user/login.action--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"userlogin"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/user"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 这是本包里的全局result,本包里的所有action都可以用该result--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">global-results</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"error"</span>&gt;</span>/execption.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">global-results</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--下面为默认页面，如果访问到该目录下没有的地址，则会显示该界面--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;action name="errordefault"&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;result&gt;/error.jsp&lt;/result&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;/action&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;default-action-ref name="errordefault" &gt;&lt;/default-action-ref&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 下面这个没有指定方法名，默认调用的是UserLogin里的execute()方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"login"</span> <span class="attr">class</span>=<span class="string">"com.jiyiweb.action.UserLogin"</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 这个默认访问execute()方法--&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- http://127.0.0.1:8088/ProjectName/login.action--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 下面这个就是为了动态方法调用--&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 访问地址http://127.0.0.1:8088/ProjectName/login!add.action--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"add"</span>&gt;</span>/add.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--&lt;result name="error"&gt;/error.jsp&lt;/result&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 下面这个是方法名调用，在method等于UserLogin里的add()方法则将执行add()方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"loginadd"</span> <span class="attr">method</span>=<span class="string">"add"</span> <span class="attr">class</span>=<span class="string">"com.jiyiweb.action.UserLogin"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">result</span>&gt;</span>/add.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--&lt;result name="error"&gt;/error.jsp&lt;/result&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 下面为通配符访问方法，是官方推荐的方法--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 调用url http://localhost:8088/user/logintpf_add.action--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 注意：下划线后面的方法名，不写方法名默认调用的是execute方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"logintpf_*"</span> <span class="attr">method</span>=<span class="string">"&#123;1&#125;"</span> <span class="attr">class</span>=<span class="string">"com.jiyiweb.action.UserLogin"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"add"</span>&gt;</span>/&#123;1&#125;.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 常量配置，也可以配置在struts.properties文件里--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--http://blog.csdn.net/flfna/article/details/4900172--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 编码设置，请求参数中会出现编码问题，默认是UTF-8--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.i18n.encoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 是否设置为开发模式，默认false,开发阶段设置为true--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.devMode"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每次http请求到达时是否重新加载国际化资源，默认false,开发阶段设置为true--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.i18n.reload"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 请求后缀形如.action的都交由Struts2处理，值中多个值用逗号隔开--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.action.extension"</span> <span class="attr">value</span>=<span class="string">"action,do,struts2,"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个是动态方法调用，在action用感叹号访问action的方法--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 主要是在访问的时候http://127.0.0.1:8088/ProjectName/login!add.action--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.enable.DynamicMethodInvocation"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p><strong>简单说明</strong></p>
<p><strong>1、DOCTYPE 是 xml 里的申明，使得本 xml 可以使用配置里的 dtd</strong></p>
<p><strong>2、<include> 节点，如果项目太大，则应该将配置分写在不同的配置文件里，可以用 include 包括另外一个配置文件，另一文件的配置也需要DOCTYPE。</include></strong></p>
<p><strong>3、<package> 节点，用于分类，name 为包名，这个自己起，不重名就行，extends 通常继承自 struts-default, namespace 为访问路径。</package></strong></p>
<p><strong>4、<action> 节点，package 节点里配置若干个action，通常一个action 代表一个映射地址，也就是一个 url 地址，name 是 url 访问的地址，与 package 里的 namespace 一起构成 url 访问的最终地址：</action></strong> 如： <em><a href="http://127.0.0.1:8088/mtest/PackageNameSpace/ActionName" target="_blank" rel="noopener">http://127.0.0.1:8088/mtest/PackageNameSpace/ActionName</a></em></p>
<p><strong>5、<result> 就是结果返回的页面，name 应该对应于 action 类里的返回值 ,没有设置则是默认结果，形式为: /hello.jsp</result></strong></p>
<p><strong>6、<global-results> 是包下的全局返回结果，与 action 并列，可以在任意一个 action 使用</global-results></strong></p>
<h2 id="二、web访问路径-重点"><a href="#二、web访问路径-重点" class="headerlink" title="二、web访问路径(重点)"></a>二、web访问路径(重点)</h2><h3 id="1-路径配置说明"><a href="#1-路径配置说明" class="headerlink" title="1. 路径配置说明"></a>1. 路径配置说明</h3><p>关于 web 路径配置的地方有三处：</p>
<ol>
<li><em>web.xml</em> 里的 <code>&lt;welcome-file-list&gt;</code>, 这个是所有 java web 都有的。</li>
<li><em>web.xml</em> 里的 <em>struts</em> 拦截器设置的 <code>&lt;filter-mapping&gt;</code> 匹配配置。</li>
<li><em>struts.xml</em> 里的常量 <code>constant name=&quot;struts.action.extension</code>。</li>
</ol>
<p>下面分别说明：</p>
<h3 id="2-welcom-file-list"><a href="#2-welcom-file-list" class="headerlink" title="2. welcom-file-list"></a>2. welcom-file-list</h3><p>对于 <em>web.xml</em> 里的这个标签主要配置的是 web 项目的主页面。也就是当我们访问一个项目的根目录时所显示的界面。</p>
<p>举个例子：我们的项目名叫 <em>hellotest</em>, 我们配置 tomcat 时会有两种配置方法:</p>
<p>一种是将 tomcat 的 <em>webapps</em> 作为服务器根目录，这时我们的访问我们项目的根目录为<code>http://localhost:8080/hellotest</code>,</p>
<p>另一种方法是将我们的项目就作为 tomcat 服务器根目录了，那我们访问我们项目的根目录为 <code>http://localhost:8080</code>。通常我们用后一种tomcat 配置方法，因为这样可以与实际运行情况相符。那么不管哪一种配置方法，访问了我们项目的根目录，我们都没有指定访问哪个页面为什么还是会有界面显示呢？因为 <em>tomcat</em> 默认将项目的 <em>index.html, index.htm, index.jsp</em> 作为访问项目根目录而显示的界面。与在web.xml 里配置如下这种情况一样：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>这个是写在 <em>web.xml</em> 里的，上面的代码与默认配置是一样的，也就是说不写上面的这些代码也会有效果的。那它有什么用呢？它通常做为用户想自定义自己项目根目录访问界面的，比如我的项目下有 <em>index.jsp</em> 和<em>hello.jsp</em>, 而我就是想让 <em>hello.jsp</em> 作为默认界面，那我们就这么配置：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>hello.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>当我们访问项目根目录，比如: <code>http://localhost:8080</code> 时，显示的界面将会是 hello.jsp 的界面，而不会是 index.jsp. 因为当我们配置了该标签，就覆盖了默认的设置了，其所隐含的真正路径是： <code>http://localhost:8080/hello.jsp</code></p>
<h3 id="3-web-xml-里-struts-拦截器设置"><a href="#3-web-xml-里-struts-拦截器设置" class="headerlink" title="3.web.xml 里 struts 拦截器设置"></a>3.web.xml 里 struts 拦截器设置</h3><p>通常的配置：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>这里的意思是以 action 为后缀的访问路径和没有后缀的访问路径都会被 struts 的拦截器拦截，进入 action 里处理后再返回出视图，是的，没错，没有后缀的也会拦截的，struts 默认拦截的有两个的，一个是 action 后缀，一个就是没有后缀的。举个例子：</p>
<ul>
<li>当访问url为 <code>http://localhost:8080/add.action</code> 这个为以action结尾的访问路径，将会进入继承actionsupport的类里处理，然后返回出视图。</li>
<li>还有这样 <code>http://localhost:8080/index</code> 这个是没有后缀的访问路径，也会进入struts的拦截器里。</li>
<li>而 <code>http://localhost:8080/index.jsp</code> 以及 <code>http://localhost:8080/hello.html</code> 等都不会进入struts的拦截器的，直接由tomcat返回页面视图的。</li>
</ul>
<p>我们举个更实际点的例子吧：</p>
<ul>
<li>假设我们的项目根目录下有 index.jsp 和 hello.jsp，所有其他配置好后都默认，也就是说 Struts 拦截 action 后缀和无后缀的 url 路径。</li>
<li>在 struts.xml 里配置如下的包：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"default"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span>&gt;</span>hello.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>当我们</p>
<p>(1) 访问<code>http://localhost:8080</code>返回index.jsp视图</p>
<p>(2) 访问 <code>http://localhost:8080/index.jsp</code>返回index.jsp视图</p>
<p>(3) 访问 <code>http://localhost:8080/hello.jsp</code>返回hello.jsp视图</p>
<p>(4) 访问 <code>http://localhost:8080/index</code> 返回hello.jsp</p>
<p>(5) 访问 <code>http://localhost:8080/index.action</code> 返回hello.jsp</p>
<p>(1)、(2)、(3)访问机制是一样的，是直接由tomcat直接返回视图；(4)和(5)的机制相同但是与前面的不同，(4)、(5)是被struts拦截后通过配置文件的配置后返回视图的。</p>
<h3 id="4-struts-xml-里的常量配置"><a href="#4-struts-xml-里的常量配置" class="headerlink" title="4. struts.xml 里的常量配置"></a>4. struts.xml 里的常量配置</h3><p>其配置示例：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.action.extension"</span> <span class="attr">value</span>=<span class="string">"action,do,"</span>/&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>它的作用是让 <em>struts</em> 拦截哪些后缀结尾的 url 的。</p>
<p>当我们新建好项目时，<em>struts.xml</em> 里没有任何东西的，所以默认的拦截是 <strong>action</strong>和 <strong>没有后缀</strong> 的 url 路径。但是</p>
<p>若按如下配置：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.action.extension"</span> <span class="attr">value</span>=<span class="string">"action"</span>/&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>那么它将只会拦截 <strong>action</strong> 结尾的 url 路径了。</p>
<p>当我们写下:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.action.extension"</span> <span class="attr">value</span>=<span class="string">","</span>/&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>那么它将只会拦截 <strong>没有后缀</strong> 的 url 路径了。</p>
<p>当我们写下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.action.extension"</span> <span class="attr">value</span>=<span class="string">"action,do,"</span>/&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>那么它将会拦截 <strong>action, do 结尾的 url 以及没有后缀</strong> 的 url 路径。</p>
<p>当写下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.action.extension"</span> <span class="attr">value</span>=<span class="string">"action,do"</span>/&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>那么它将只会拦截 <strong>action</strong> 和 <strong>do</strong> 结尾的 url 路径了，没有后缀的将不会拦截。</p>
<p>在 <em>Struts</em> 中如果我们没有配置拦截后缀，则默认是所有的 <code>.action</code> 后缀的访问 url 将被 <em>Struts</em> 框架拦截，然后通过 <em>action</em> 返回视图。而所有的 <code>.jsp</code> 和 <code>.html</code> 将直接通过 url 是可访问的。</p>
<h2 id="三、实践理解路径控制—-设置主页"><a href="#三、实践理解路径控制—-设置主页" class="headerlink" title="三、实践理解路径控制—-设置主页"></a>三、实践理解路径控制—-设置主页</h2><p>方法有三种：</p>
<ol>
<li><p>什么都不用做，只要项目目录有 <em>index.html</em> 或者 <em>index.htm</em> 或者 <em>index.jsp</em>，那么这三中页面就会默认被配置为根目录下主页。</p>
</li>
<li><p>配置 <em>web.xml</em> 里的 <em>welcome-file-list</em>, 想让哪个界面作为主页都可以。配置后会覆盖默认 tomcat 的默认首页设置。</p>
</li>
<li><p>通过 <em>struts.xml</em> 里的配置来设置主页。</p>
</li>
</ol>
<p>这里简单介绍下：</p>
<p>拦截：因为要用 <em>struts</em> 来配置，所以要使 url 进入 <em>action</em>, 也就是说要拦截 <strong>tomcat</strong> 默认设置的 <strong>.html, .htm, .jsp</strong> 后缀的访问 url, 所以要将控制后缀常量设置为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.action.extension"</span> <span class="attr">value</span>=<span class="string">"action,html,htm,jsp,"</span>/&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>这样我们就拦截了主页默认的 index.html 或者 index.jsp 后缀 index.htm.</p>
<p>配置：然后配置 package 如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"default"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">default-action-ref</span> <span class="attr">name</span>=<span class="string">"myhome"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"myhome"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>这里的 <code>default-action-ref</code> 是包的默认 <em>action</em>，也就是说当拦截了的路径匹配到了包后没有匹配到action则此默认的action就作为视图返回的路径了。</p>
<p>访问思考：所以当我们访问 <code>http://localhost:8080</code> 时，经过tomcat的默认配置，隐含的实际访问路径为：<code>http://localhost:8080/index.jsp</code> 但是此时的 jsp 后缀 url 都会被 struts 拦截，所以就进 struts.xml 里的路径映射，因为只有一级路径所以映射到 default 包，而这个包里没有配置 index.jsp 名称，所以进入本包的默认 action, 则返回视图 /index.jsp。所以最后显示了主页 index.jsp。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>做一个web网站，最重要有三个：一是前端，二是后台，而第三个就是逻辑控制了；这个逻辑控制比较大，它包括了前后台的数据传输,用户与前端、后台的交互(如：资源访问)等。而最不好控制的就是暴露给用户的路径逻辑了，因为你不知道用户在浏览器里输入什么路径的，所以很多情况下我们都要在后台严格控制资源的访问权限，这些控制并不是可以通过写代码那么好实现的，通常要有一定的框架思维和全局观念，这也就是我们通常用框架的原因，解决逻辑控制，尤其是路径控制访问！</p>
<ul>
<li>通常 <em>web.xml</em> 中的 <em>welcome-list</em> 无须设置，因为我们项目几乎都应该含有index的页面的。</li>
<li>如果我们设置了 jsp 后缀的也拦截的话，一定记住要对每个 jsp 界面都应该设置对应的 action。</li>
<li>通常我们会在 html 里引用其他的页面，比如超链接等，这时要写的链接大家一定要注意是不是被你拦截的页面，如果拦截则一定要按照 <code>PackageName/ActionName</code> 这样配置。</li>
</ul>
]]></content>
      <categories>
        <category>Struts</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
</search>
